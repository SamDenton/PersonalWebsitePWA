@page "/EvolutionTFNEAT"
@inject IJSRuntime JSRuntime

<h2>Semi-NEAT Genetic Evolution Simulation</h2>

<p>My Implementation of the NEAT algorithm, adapted for TesnorFlow.JS</p>
<p>Like most of the site, this will work on mobile, but its not designed for it</p>
<p>The documentation below, and on the <a style="text-decoration: none" href="/Projects/all/all">Projects Page of the Wiki</a> will give an explanation of whats going on and how to get started</p>

<div id="canvas-container-NEAT"></div>

<div class="settings-preset-Buttons">
    <h2>Performance Settings presets</h2>
    <button class="preset-button mobile-button" title="Set mobile powered presets" @onclick="setMobilePresets">Mobile Power Settings Preset</button>
    <button class="preset-button low-button" title="Set low powered presets" @onclick="setLowPresets">Low Power Settings Preset</button>
    <button class="preset-button mid-button" title="Set medium powered presets" @onclick="setMidPresets">Medium Power Settings Preset</button>
    <button class="preset-button high-button" title="Set high powered presets" @onclick="setHighPresets">High Power Settings Preset</button>
    <button class="preset-button vHigh-button" title="Set very high powered presets" @onclick="setVHighPresets">Very High Power Settings Preset</button>
    <button class="preset-button reset-button" title="Resets settings to default everything" @onclick="resetSettings">Reset All Settings</button>
    <button class="preset-button save-button" title="Saves current settings to a JSON file" @onclick="saveSettings">Save Settings To File</button>
    <button class="preset-button upload-button" title="Uploaded saved settings JSON" @onclick="uploadSettings">Upload Settings File</button>
</div>

<div class="settings-container">
    <div class="settings-section">
        <h2>Performance Settings</h2>

        <!-- Number of Agents -->
        <div class="setting">
            <label for="numAgents" title="Total number of agents run at once">Number of Agents to Run at Once</label>
            <div class="slider-container">
                <input type="range" id="numAgents" @bind="stageProperties.numAgents" min="10" max="1000" step="1">
                <input type="number" @bind="stageProperties.numAgents" min="2" max="1000" step="1">
            </div>
        </div>

        <!-- Number of Agent Inter-gen Batches -->
        <div class="setting">
            <label for="totalNumAgentsMultiplier" title="Number of agents inter-gen batches.  Multiply Number of agents to run at once by this multiplier to get the total agents in the population.">Number of Agent Intergenerational Batches</label>
            <div class="slider-container">
                <input type="range" id="totalNumAgentsMultiplier" @bind="stageProperties.totalNumAgentsMultiplier" min="1" max="100" step="1">
                <input type="number" @bind="stageProperties.totalNumAgentsMultiplier" min="1" max="100" step="1">
            </div>
        </div>

        <!-- Agents updated per batch -->
        <div class="setting">
            <label for="muscleBatch" title="Update this many agents muscles, wait, then move to next batch.  Setting this equal to the population size will update every agent, every update cycle">Agents Per Batch of Joint Updates</label>
            <div class="slider-container">
                <input type="range" id="muscleBatch" @bind="stageProperties.muscleBatch" min="1" max="500" step="1">
                <input type="number" @bind="stageProperties.muscleBatch" min="1" max="500" step="1">
            </div>
        </div>

        <!-- Frames per batch -->
        <div class="setting">
            <label for="muscleDelay" title="1 means no delay between batches">Delay Between Batch of Joint Updates (frames)</label>
            <div class="slider-container">
                <input type="range" id="muscleDelay" @bind="stageProperties.muscleDelay" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.muscleDelay" min="1" max="50" step="1">
            </div>
        </div>

        <!-- Frames between muscle update rounds -->
        <div class="setting">
            <label for="totalMuscleUpdateTime" title="Frames between muscle update rounds. Combines with muscle batching.">Delay Between Muscle Update Rounds (frames)</label>
            <div class="slider-container">
                <input type="range" id="totalMuscleUpdateTime" @bind="stageProperties.totalMuscleUpdateTime" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.totalMuscleUpdateTime" min="1" max="50" step="1">
            </div>
        </div>

        <!-- Physics Speed -->
        <div class="setting">
            <label for="simSpeed" title="Physics Speed, the number of physics ticks per 60 rendered frames, approx 1 second (try slower speeds on slow computers).">Physics Updates Per Second (at 60 fps)</label>
            <div class="slider-container">
                <input type="range" id="simSpeed" @bind="stageProperties.simSpeed" min="6" max="480" step="6">
                <input type="number" @bind="stageProperties.simSpeed" min="6" max="480" step="6">
            </div>
        </div>

        <!-- Spawn Batch Size -->
        <div class="setting">
            <label for="BatchSize" title="Spawn agents in batches of this many.  Helps to distribute calculations over a few seconds">Spawn Batch Size</label>
            <div class="slider-container">
                <input type="range" id="BatchSize" @bind="stageProperties.BatchSize" min="1" max="200" step="1">
                <input type="number" @bind="stageProperties.BatchSize" min="1" max="200" step="1">
            </div>
        </div>

        <!-- Spawn Delay Between batches -->
        <div class="setting">
            <label for="delay" title="Spawn Delay Between batches (ms), more delay smooths out resource spikes when loading agents.">Spawn Delay Between Batches (ms)</label>
            <div class="slider-container">
                <input type="range" id="delay" @bind="stageProperties.delay" min="0" max="200" step="1">
                <input type="number" @bind="stageProperties.delay" min="0" max="200" step="1">
            </div>
        </div>

    </div>

    <div class="settings-section">
        <h2>Agent Properties</h2>

        <!-- Number of limbs per agent -->
@*        <div class="setting">
            <label for="numLimbs" title="Number of limbs per agent.">Number of Limbs per Agent</label>
            <div class="slider-container">
                <input type="range" id="numLimbs" @bind="stageProperties.numLimbs" min="1" max="20" step="1">
                <input type="number" @bind="stageProperties.numLimbs" min="1" max="20" step="1">
            </div>
        </div>*@

        <!-- Max Joint Speed -->
        <div class="setting">
            <label for="maxJointSpeed" title="Maximum joint speed.">Max Joint Speed</label>
            <div class="slider-container">
                <input type="range" id="maxJointSpeed" @bind="stageProperties.maxJointSpeed" min="0.5" max="5" step="0.5">
                <input type="number" @bind="stageProperties.maxJointSpeed" min="0.5" max="5" step="0.5">
            </div>
        </div>

        <!-- Number of limbs per agent -->
@*        <div class="setting">
            <label for="musculeTorque" title="Number of limbs per agent.">Max Torque Per Joint</label>
            <div class="slider-container">
                <input type="range" id="musculeTorque" @bind="stageProperties.musculeTorque" min="50000.0" max="5000000.0" step="5000.0">
                <input type="number" @bind="stageProperties.musculeTorque" min="50000.0" max="5000000.0" step="5000.0">
            </div>
        </div>*@

        <!-- Weight and Bias Mutation rate -->
        <div class="setting">
            <label for="offspringMutationRate" title="The mutation rate for weights and biases within the network">Mutation rate for weights and biases</label>
            <div class="slider-container">
                <input type="range" id="offspringMutationRate" @bind="stageProperties.offspringMutationRate" min="0" max="10" step="0.001">
                <input type="number" @bind="stageProperties.offspringMutationRate" min="0" max="10" step="0.001">
            </div>
        </div>

        <!-- Node Mutation rate -->
        <div class="setting">
            <label for="offspringNodeMutationRate" title="The Mutation rate for gaining or loosing a node in a random layer">Mutation rate for gaining or loosing a node</label>
            <div class="slider-container">
                <input type="range" id="offspringNodeMutationRate" @bind="stageProperties.offspringNodeMutationRate" min="0" max="10" step="0.001">
                <input type="number" @bind="stageProperties.offspringNodeMutationRate" min="0" max="10" step="0.001">
            </div>
        </div>

        <!-- Layer Mutation rate -->
        <div class="setting">
            <label for="offspringLayerMutationRate" title="The Mutation rate for gaining or loosing a network layer at a random position">Mutation rate for gaining or loosing a network layer</label>
            <div class="slider-container">
                <input type="range" id="offspringLayerMutationRate" @bind="stageProperties.offspringLayerMutationRate" min="0" max="10" step="0.001">
                <input type="number" @bind="stageProperties.offspringLayerMutationRate" min="0" max="10" step="0.001">
            </div>
        </div>

        <!-- Body Plan Mutation rate -->
        <div class="setting">
            <label for="offspringLimbMutationRate" title="The Mutation rate for the body plan, gaining or loosing limbs is half this amount">Mutation rate for the body plan, gaining or loosing limbs is half this amount</label>
            <div class="slider-container">
                <input type="range" id="offspringLimbMutationRate" @bind="stageProperties.offspringLimbMutationRate" min="0" max="10" step="0.001">
                <input type="number" @bind="stageProperties.offspringLimbMutationRate" min="0" max="10" step="0.001">
            </div>
        </div>

        <!-- Max limb movement -->
@*        <div class="setting">
            <label for="maxJointMoveDivider" title="Number of limbs per agent.">Joint Movement Restriction (0 means no restriction, 2 means half their possible movement)</label>
            <div class="slider-container">
                <input type="range" id="maxJointMoveDivider" @bind="stageProperties.maxJointMoveDivider" min="0" max="8" step="0.1">
                <input type="number" @bind="stageProperties.maxJointMoveDivider" min="0" max="8" step="0.1">
            </div>
        </div>*@

        <!-- liquid Viscosity -->
        <div class="setting">
            <label for="liquidViscosity" title="Movement decay factor for agents">Liquid Environment Viscosity</label>
            <div class="slider-container">
                <input type="range" id="liquidViscosity" @bind="stageProperties.liquidViscosity" min="0.9" max="1" step="0.001">
                <input type="number" @bind="stageProperties.liquidViscosity" min="0.9" max="1" step="0.001">
            </div>
        </div>

        <!-- swim Strength -->
        <div class="setting">
            <label for="swimStrength" title="Multiplier on the force applied to each limb for agent swimming">Swim Strength</label>
            <div class="slider-container">
                <input type="range" id="swimStrength" @bind="stageProperties.swimStrength" min="100000" max="50000000" step="10000">
                <input type="number" @bind="stageProperties.swimStrength" min="100000" max="50000000" step="10000">
            </div>
        </div>

        <!-- Max limb movement -->
        <div class="setting">
            <label for="swimBias" title="Adds a slight bias in the force applied, so 'limb strokes' apply more force than retuning to starting position, based on left right split of limbs on body">Swim Bias</label>
            <div class="slider-container">
                <input type="range" id="swimBias" @bind="stageProperties.swimBias" min="1" max="2" step="0.01">
                <input type="number" @bind="stageProperties.swimBias" min="1" max="2" step="0.01">
            </div>
        </div>

        <!-- Input List -->
        <div class="setting">

            <p title="Select the inputs available to the agents">Agent Input Selection</p>

            <label for="inputJointAngle" title="The current angle of each joint relative to the main body">Joint Angle</label>
            <input type="checkbox" id="inputJointAngle" @bind="stageProperties.inputJointAngle" />

            <label for="inputJointSpeed" title="The current speed of the joint/limb">Joint/Limb Speed</label>
            <input type="checkbox" id="inputJointSpeed" @bind="stageProperties.inputJointSpeed" />

            <label for="inputAgentPos" title="The agents position in the world">Agents Position</label>
            <input type="checkbox" id="inputAgentPos" @bind="stageProperties.inputAgentPos" />

            <label for="inputAgentV" title="The current velocity of the agent">Agent Velocity</label>
            <input type="checkbox" id="inputAgentV" @bind="stageProperties.inputAgentV" />

            <label for="inputScore" title="The agents current score">Current score</label>
            <input type="checkbox" id="inputScore" @bind="stageProperties.inputScore" />

            <label for="inputOrientation" title="Agents current orientation in the world">Agents MainBody Orientation</label>
            <input type="checkbox" id="inputOrientation" @bind="stageProperties.inputOrientation" />

            <label for="inputTimeRemaining" title="The time left in this round">Time Remaining</label>
            <input type="checkbox" id="inputTimeRemaining" @bind="stageProperties.inputTimeRemaining" />

            <label for="inputDistanceSensors" title="Sensors for distance from agent to closest object in 8 directions">Distance to object Sensors</label>
            <input type="checkbox" id="inputDistanceSensors" @bind="stageProperties.inputDistanceSensors" />

        </div>

        <!-- Output List -->
        <div class="setting">
            <p title="Select the outputs available to the agents">Agent Output Selection</p>

            <label for="outputsJointSpeed" title="The speed the angle is moving at">Joint Speed</label>
            <input type="checkbox" id="outputsJointSpeed" @bind="stageProperties.outputsJointSpeed" />

            <label for="outputsJointTorque" title="Torque of the joint">Joint Torque</label>
            <input type="checkbox" id="outputsJointTorque" @bind="stageProperties.outputsJointTorque" />

            <label for="outputsBias" title="The amount of bias towards direction agent is facing">Limb Directional Bias</label>
            <input type="checkbox" id="outputsBias" @bind="stageProperties.outputsBias" />
        </div>

    </div>

    <div class="settings-section">
        <h2>Score and Energy</h2>
        <!-- X Score Multiplier -->
        <div class="setting">
            <label for="xScoreMultiplier" title="Multiplier for score gained for moving in the x direction">X Score Multiplier</label>
            <div class="slider-container">
                <input type="range" id="xScoreMultiplier" @bind="stageProperties.xScoreMultiplier" min="0" max="10" step="0.5">
                <input type="number" @bind="stageProperties.xScoreMultiplier" min="0" max="10" step="0.5">
            </div>
        </div>

        <!-- Y Score Multiplier -->
        <div class="setting">
            <label for="yScoreMultiplier" title="Multiplier for score gained for moving in the y direction">Y Score Multiplier</label>
            <div class="slider-container">
                <input type="range" id="yScoreMultiplier" @bind="stageProperties.yScoreMultiplier" min="0" max="10" step="0.5">
                <input type="number" @bind="stageProperties.yScoreMultiplier" min="0" max="10" step="0.5">
            </div>
        </div>

        <!-- Movement Score Multiplier -->
        <div class="setting">
            <label for="movementScoreMultiplier" title="Multiplier for score gained for moving limbs about.  This decays for progressive movement.  Designed to create active agents early on">Limb Movement Score Multiplier</label>
            <div class="slider-container">
                <input type="range" id="movementScoreMultiplier" @bind="stageProperties.movementScoreMultiplier" min="0" max="10" step="0.5">
                <input type="number" @bind="stageProperties.movementScoreMultiplier" min="0" max="10" step="0.5">
            </div>
        </div>

        <!-- Exploration Score Multiplier -->
        <div class="setting">
            <label for="explorationScoreMultiplier" title="Multiplier for score gained for exploring more of the map.  Each 50x50 pixels explored is worth this much score. Max of 500x500 squares to explore.  No points are given for moving below or left of the starting position">Exploration Score Multiplier</label>
            <div class="slider-container">
                <input type="range" id="explorationScoreMultiplier" @bind="stageProperties.explorationScoreMultiplier" min="0" max="100" step="1">
                <input type="number" @bind="stageProperties.explorationScoreMultiplier" min="0" max="100" step="1">
            </div>
        </div>

        <!-- Size Score Multiplier -->
        <div class="setting">
            <label for="sizeScoreMultiplier" title="Small bonus given to score for being larger.  This is to combat agents all becoming tiny to move faster early in training, before the energy system has much effect">Size Score Multiplier</label>
            <div class="slider-container">
                <input type="range" id="sizeScoreMultiplier" @bind="stageProperties.sizeScoreMultiplier" min="0" max="1" step="0.01">
                <input type="number" @bind="stageProperties.sizeScoreMultiplier" min="0" max="1" step="0.01">
            </div>
        </div>

        <!-- Starting Energy -->
        <div class="setting">
            <label for="startingEnergyBase" title="Base energy for agents">Base Starting Energy</label>
            <div class="slider-container">
                <input type="range" id="startingEnergyBase" @bind="stageProperties.startingEnergyBase" min="0" max="1000" step="1">
                <input type="number" @bind="stageProperties.startingEnergyBase" min="0" max="1000" step="1">
            </div>
        </div>

        <!-- Starting Energy Power -->
        <div class="setting">
            <label for="startingEnergyMassPower" title="Power used for giving more energy based on mass">Starting Energy Mass Exponent</label>
            <div class="slider-container">
                <input type="range" id="startingEnergyMassPower" @bind="stageProperties.startingEnergyMassPower" min="1" max="5" step="1">
                <input type="number" @bind="stageProperties.startingEnergyMassPower" min="1" max="5" step="1">
            </div>
        </div>

        <!-- Starting Energy Body Mass Multiplier -->
        <div class="setting">
            <label for="startingEnergyBodyMassMult" title="Flat multiplier giving energy for main body mass">Starting Energy Body Mass Multiplier</label>
            <div class="slider-container">
                <input type="range" id="startingEnergyBodyMassMult" @bind="stageProperties.startingEnergyBodyMassMult" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.startingEnergyBodyMassMult" min="0" max="5" step="0.1">
            </div>
        </div>

        <!-- Starting Energy Limb Mass Multiplier -->
        <div class="setting">
            <label for="startingEnergyLimbMassMult" title="Flat multiplier giving energy for limbs masses">Starting Energy Limb Mass Multiplier</label>
            <div class="slider-container">
                <input type="range" id="startingEnergyLimbMassMult" @bind="stageProperties.startingEnergyLimbMassMult" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.startingEnergyLimbMassMult" min="0" max="5" step="0.1">
            </div>
        </div>

        <!-- Energy Use Limb Mass Multiplier -->
        <div class="setting">
            <label for="energyUseLimbSizeMult" title="Flat multiplier for how much energy is used based on limb mass">Energy Use From Limb Mass Multiplier</label>
            <div class="slider-container">
                <input type="range" id="energyUseLimbSizeMult" @bind="stageProperties.energyUseLimbSizeMult" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.energyUseLimbSizeMult" min="0" max="5" step="0.1">
            </div>
        </div>

        <!-- Energy Use Brain Size Multiplier -->
        <div class="setting">
            <label for="energyUseBrainSizeMult" title="Flat multiplier for how much energy is used based on size/complexity of the brain">Energy Use From Brain Size Multiplier</label>
            <div class="slider-container">
                <input type="range" id="energyUseBrainSizeMult" @bind="stageProperties.energyUseBrainSizeMult" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.energyUseBrainSizeMult" min="0" max="5" step="0.1">
            </div>
        </div>

        <!-- Energy Use Limb Mass Multiplier -->
        <div class="setting">
            <label for="energyUseForceSizeMult" title="Flat multiplier for how much energy is used based on limb movements">Energy Use From Limb Movements Multiplier</label>
            <div class="slider-container">
                <input type="range" id="energyUseForceSizeMult" @bind="stageProperties.energyUseForceSizeMult" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.energyUseForceSizeMult" min="0" max="5" step="0.1">
            </div>
        </div>

    </div>

    <div class="settings-section">
        <h2>Training Settings</h2>

        <!-- Starting Physics ticks per round -->
        <div class="setting">
            <label for="SimulationLength" title="Starting Physics ticks per round/generation, set alongside physics speed.">Starting Round Length (Physics Ticks)</label>
            <div class="slider-container">
                <input type="range" id="SimulationLength" @bind="stageProperties.SimulationLength" min="100" max="100000" step="100">
                <input type="number" @bind="stageProperties.SimulationLength" min="100" max="10000" step="100">
            </div>
        </div>

        <!-- Time increase per generation -->
        <div class="setting">
            <label for="timeIncrease" title="Increase the round length by * 1.005 each round">Increase Round Time Per Generation</label>
            <input type="checkbox" id="timeIncrease" @bind="stageProperties.timeIncrease" />
        </div>

        <!-- Increase in ticks per round -->
        <div class="setting">
            <label for="simulationLengthIncrease" title="Physics ticks per round/generation, set alongside physics speed.">Increase round by x ticks each generation</label>
            <div class="slider-container">
                <input type="range" id="simulationLengthIncrease" @bind="stageProperties.simulationLengthIncrease" min="1" max="500" step="1">
                <input type="number" @bind="stageProperties.simulationLengthIncrease" min="1" max="500" step="1">
            </div>
        </div>

        <!-- Maximum Physics ticks per round -->
        <div class="setting">
            <label for="maxSimulationLength" title="Maximum Physics ticks per round/generation, set alongside physics speed.">Maximum Round Length (Physics Ticks)</label>
            <div class="slider-container">
                <input type="range" id="maxSimulationLength" @bind="stageProperties.maxSimulationLength" min="1000" max="10000000" step="100">
                <input type="number" @bind="stageProperties.maxSimulationLength" min="1000" max="1000000" step="100">
            </div>
        </div>

        <!-- Group Tournament Size -->
        <div class="setting">
            <label for="tournamentSize" title="Group Tournament Size, the number of random agents picked to compete to be parents, mostly from within the same group.">Group Tournament Size</label>
            <div class="slider-container">
                <input type="range" id="tournamentSize" @bind="stageProperties.tournamentSize" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.tournamentSize" min="1" max="50" step="1">
            </div>
        </div>

        <!-- Migration rate between groups -->
        <div class="setting">
            <label for="migrationRate" title="Migration rate between groups, the chance a parent is selected from random group instead of the same.">Migration Rate Between Groups</label>
            <div class="slider-container">
                <input type="range" id="migrationRate" @bind="stageProperties.migrationRate" min="0.001" max="0.1" step="0.001">
                <input type="number" @bind="stageProperties.migrationRate" min="0.001" max="0.1" step="0.001">
            </div>
        </div>

        <!-- Minimum agents per population group -->
        <div class="setting">
            <label for="minPopGroupSize" title="Minimum agents per population group. If the total number is less than this, all agents will be in the same group.">Minimum Agents Per Population Group</label>
            <div class="slider-container">
                <input type="range" id="minPopGroupSize" @bind="stageProperties.minPopGroupSize" min="5" max="50" step="1">
                <input type="number" @bind="stageProperties.minPopGroupSize" min="5" max="50" step="1">
            </div>
        </div>

        <!-- Maximum agents per population group -->
        <div class="setting">
            <label for="maxPopGroupSize" title="Maximum agents per population group. Sets the number of groups as total population / Max agents per group, when total is more than max.">Maximum Agents Per Population Group</label>
            <div class="slider-container">
                <input type="range" id="maxPopGroupSize" @bind="stageProperties.maxPopGroupSize" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.maxPopGroupSize" min="1" max="50" step="1">
            </div>
        </div>

        <!-- Percentage of top agents kept between generations -->
        <div class="setting">
            <label for="topPerformerNumber" title="Percentage of top agents kept between generations.">Percentage of Top Agents Kept</label>
            <div class="slider-container">
                <input type="range" id="topPerformerNumber" @bind="stageProperties.topPerformerNumber" min="5" max="50" step="1">
                <input type="number" @bind="stageProperties.topPerformerNumber" min="5" max="50" step="1">
            </div>
        </div>

        <!-- Brain Decay -->
        <div class="setting">
            <label for="brainDecayOverTime" title="Decay all weights in agents brain by a small amount each round">Brain Decay Over Time</label>
            <input type="checkbox" id="brainDecayOverTime" @bind="stageProperties.brainDecayOverTime" />
        </div>

    </div>

    <div class="settings-section">
        <h2>World Properties</h2>

        <!-- Agent to fix camera on -->
        <div class="setting">
            <label for="agentInCentre" title="Agent to fix camera on (average can cause lag).">Agent to Fix Camera On</label>
            <select id="agentInCentre" @bind="stageProperties.agentInCentre">
                <option value="leader">leader</option>
                <option value="trailer">trailer</option>
                <option value="average">average</option>
            </select>
        </div>

        <!-- Randomize Map -->
        <div class="setting">
            <label for="randomMap" title="Select a random map each generation">Randomize Map</label>
            <input type="checkbox" id="randomMap" @bind="stageProperties.randomMap" />
        </div>

        <!-- Map -->
        <div class="setting">
            <label for="map" title="Pick between maps">Map Selector</label>
            <select id="map" @bind="stageProperties.map">
                <option value="0">1</option>
                <option value="1">2</option>
                <option value="2">3</option>
                <option value="3">4</option>
                <option value="4">5</option>
            </select>
        </div>

        <!-- Gravity Strength Multiplier -->
        <div class="setting">
            <label for="Gravity" title="Gravity Strength Multiplier.">Gravity Strength Multiplier</label>
            <div class="slider-container">
                <input type="range" id="Gravity" @bind="stageProperties.Gravity" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.Gravity" min="0" max="5" step="0.1">
            </div>
        </div>

        <!-- Friction Strength Multiplier -->
        <div class="setting">
            <label for="Friction" title="Friction Strength Multiplier.">Friction Strength Multiplier (Not implemented yet)</label>
            <div class="slider-container">
                <input type="range" id="Friction" @bind="stageProperties.Friction" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.Friction" min="0" max="5" step="0.1">
            </div>
        </div>

    </div>

    <button class="toggle-advanced" @onclick="ToggleAdvancedSettings">Show Advanced Settings</button>

    <div class="settings-section full-width advanced-settings" hidden="@showAdvancedSettings">
        <h2>Advanced Settings</h2>

        <!-- Number of random agents per group -->
        <div class="setting">
            <label for="renderedAgents" title="Number of random agents per group, plus the group leader, to render.">Number of Random Agents Per Group</label>
            <div class="slider-container">
                <input type="range" id="renderedAgents" @bind="stageProperties.renderedAgents" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.renderedAgents" min="1" max="50" step="1">
            </div>
        </div>

        <!-- UI (Neural Network and Text) Update Rate -->
        <div class="setting">
            <label for="uiRefreshRate" title="UI (Neural Network and Text) Update Rate in milliseconds.">UI Update Rate (ms)</label>
            <div class="slider-container">
                <input type="range" id="uiRefreshRate" @bind="stageProperties.uiRefreshRate" min="100" max="1000" step="100">
                <input type="number" @bind="stageProperties.uiRefreshRate" min="100" max="1000" step="100">
            </div>
        </div>

        <!-- velocityIteration for plank -->
        <div class="setting">
            <label for="velocityIteration" title="velocityIteration value for planck">Velocity Iterations</label>
            <div class="slider-container">
                <input type="range" id="velocityIteration" @bind="stageProperties.velocityIteration" min="1" max="10" step="1">
                <input type="number" @bind="stageProperties.velocityIteration" min="1" max="10" step="1">
            </div>
        </div>

        <!-- positionIteration for plank -->
        <div class="setting">
            <label for="positionIteration" title="UI (Neural Network and Text) Update Rate in milliseconds.">Position Iterations</label>
            <div class="slider-container">
                <input type="range" id="positionIteration" @bind="stageProperties.positionIteration" min="1" max="10" step="1">
                <input type="number" @bind="stageProperties.positionIteration" min="1" max="10" step="1">
            </div>
        </div>

        <!-- physicsGranularity for plank -->
        <div class="setting">
            <label for="physicsGranularityMultipliers" title="Physics Granularity">Physics Granularity</label>
            <div class="slider-container">
                <input type="range" id="physicsGranularityMultipliers" @bind="stageProperties.physicsGranularityMultipliers" min="0.1" max="3" step="0.1">
                <input type="number" @bind="stageProperties.physicsGranularityMultipliers" min="0.1" max="3" step="0.1">
            </div>
        </div>
    </div>

    <div class="simDescription">
        <h3>Documentation:</h3>
        <h4>Quick Start Guide:</h4>
        <p>Please select a pre-configuration from the top to get a good starting point.</p>
        <p>Click Start/Reset, Simplified Start or Super Simplified Start from the top right menu to begin.</p>
        <p>Start/Reset will respect all configurations, while Simplified Start will remove the energy system, some score bonuses, limb and layer number mutations, and a few other things</p>
        <p>Simplified Start should see much faster learning, with agents completing the maps with 50 generations or so, using full configurations will result in much more interesting behavior, but will take 100+ generations to see much progress</p>
        <p>Super Simplified Start will also give agents a small, fixed brain and preset body plan, and will see agents complete the maps in 20-30 generations</p>
        <p>Use the button bank in the top right to toggle rendering of the leading agents brain/neural network, their vision lines/ray casts, switch between the leading agent and training agent or fast-forward generations (only about twice as fast as normal currently)</p>
        <p>Logging the genomes writes the current population to the console, and retrieving genomes is the first step towards implementing an agent database online where pre-trained agents cam be stored and retrieved.</p>
        <p>The skip x generation buttons will disable the rendering and increase the physics update rate by 4x.  If you are already running at the limit of what your computer can handle, IE. your fps is below 30-40 at normal speed, this is not going to actually speed up much.  The rendering only adds about 10% to the processing time per frame.</p>
        <h4>Some Explanation:</h4>
        <p>This is my take on a NEAT genetic evolution simulation.</p>
        <p>I would describe this as a 'Semi-NEAT' algorithm since I have restriction on what network shapes can evolve.  This is due to TensorFlow.JS's restriction to static models, where a full NEAT implementation requires dynamic models, and more control over connections</p>
        <p>Resetting/updating is a little buggy, its currently best to refresh the page if you want to try new settings</p>
        <p>Showing the Neural Network on screen adds a fair amount of lag so its hidden by default</p>
        <p>I am making use of P5.JS for my rendering, Planck.JS; a port of Box2D, for my physics and TensorFlow.JS for my neural network processing</p>
        <h4>So whats going on?</h4>
        <p>If you start the simulation with default settings, you will see about 15 agents on the screen, representing the top scorer from each group, a random agent per group, the agent that has made it furthest right, and the furthest left agent</p>
        <p>Default settings will produce 200 agents in the population, split into batches of 25, as well as species groups.  25 agents from the run group are evaluated at a time, with a random selection of species</p>
        <p>On my PC, using a Ryzen 7 3700X CPU about 3.5Ghz per core, I can target about 150 agents at a time, with 10 Agents Per Batch of Joint Updates.  The Number of Inter-gen Batches will not effect performance, but will increase training time, as only 1 batch can be evaluated at a time</p>
        <p>Since i'm making use of JS, the bottleneck for most systems is going to be the speed of a single CPU core.  Some configurations may reach a browser memory limit before a CPU limit, if you have a high number of inter-gen batches.  Browsers I have tested seem ok up to about 1000 agents total</p>
        <p>The GPU is also utilized for any Neural Network functions, the most intense of which happen between rounds, so it doesn't really matter how long they take, but during the simulation, the actual decision making also utilities the GPU using WebGL.  I have not found a configuration where this is the bottleneck, but its possible</p>
        <p>Each round, the agents have 2000 ticks, about 34 seconds at 60 fps with default physics speed of 60, to move as far North East as possible.</p>
        <p>The agents are all given a randomly initialized neural network, with a random shape for a brain, the leaders brain is rendered.  They are given a random body plan.  Both the brain and the body plan will evolve over time based on a number of crossover and mutation functions</p>
        <p>Between rounds, the agents are sorted by score, where the top x% from each species are selected to remain unchanged, and the other 90% of the population is built using crossover and mutation.</p>
        <p>This is performed between generations, on the whole population</p>
        <p>Crossover is the function of picking 2 parent agents and combining the weights and biases in their brains, keeping some features from one, and some from the other.  There are a range of methods for this, I am currently using biased Arithmetic Crossover, where there is a weighted bias given by the relative scores of the parents.</p>
        <p>Mutation adds a small chance that each weight, bias, limb or body will be altered by a small, random amount.  Again, there are many methods, currently i am using the Box-Muller transform to get a Gaussian random number for my mutation amount.  I have a function that changes the mutation rate if agents brains get too close to the average</p>
        <p>I am currently also mutating the number of limbs and layers in the brain.  These are more complex to mutate than others, as they tend to produce 'dead' agents that need retaining from scratch, which naturaly cant compete with already trained agents.  I am playing with a number of methods to counter this.</p>
        <p>Now, when a new limb is mutated, it finds an existing limb with a similar starting angle, and copies the weights from that limb.  When a new layer is mutated, it should create a matching layer, where biases are copied from the previous layer, and weights are connected so the old node connects to its new copy with a weight of 1, and all other weights are 0 in the new layer, hopefully copying the previous layers function until new values are evolved.</p>
        <p>The parents for crossover can be selected in many ways, I am actually using 1 method for 1 parent, and another for the other.  The first is picked via tournament selection, where 10 random agents are selected from the group, and the best of those if picked.  The second is picked via a weighted random selection, where ever agent is entered into a lottery with more entries for a higher score, and a random agent is picked from the pool.</p>
        <p>I am also using 'Island Populations' or 'Island Speciation', where parents are always picked from the same distinct group.  This means, with default settings, 3 distinct populations should evolve with different strategies.  There is a small chance that parents are picked from a different group, allowing some sharing of strategies</p>
        <p>You should see some 'evolution' within  50 or so generations, and they can continue to improve indefinitely, however, they can get stuck in whats known as a 'local maxima' where the agents converge on 1 or a few ok strategies, and never seem to improve.  Through mutation, they might eventually, but in those situations, its best to restart.  A greater number of agents or distinct population groups can help with this</p>
        <p>If enabled, I am experimenting with a form of normalization which slowly decays all weights in the network over time.  It's meant to prevent any noise in the network over time, based on a 'use it or loose it' principal.  Useful connections should be maintained by re-selection and unused connections will drop away</p>
        <h4>Current Selective Pressures:</h4>
        <ol>
            <li>Score for movement North East</li>
            <li>Bonus for joint movement that diminishes over time</li>
            <li>Exploration bonus</li>
            <li>Size bonus</li>
            <li>Larger limbs give more swimming force</li>
        </ol>
        <h5>Energy System:</h5>
        <ol>
            <li>Starting energy based on body size, larger bodies can store more energy</li>
            <li>More energy is used to move larger limbs</li>
            <li>Agents limb movement speed is based on their remaining energy %, with no energy, they cant move at all</li>
        </ol>
        <h4>Future Plans</h4>
        <p>There is a lot of clean up work to do on the code, the genome and the agent objects.  I have lots of duplicated values and old structures.  I am not making use of 'const' enough, and I am duplicating functions in places</p>
        <p>I need to work on the maps.  They are too simple and not varied enough.  I want to implement some goals, like food, tied to the energy system.  A puzzle to open a door or similar could also be interesting</p>
        <p>I want to make all variables customizable, which is a huge number.  I need to find a nice way to arrange them</p>
        <p>I plan on adding further ways the agents can evolve. I want to allow more complex body plans with different types of limb and body segments, such as wings, thrusters, suckers, energy storage limbs etc</p>
        <p>I want to add a greater range of crossover, mutation and selection methods to increase diversity, and have them toggle in settings to play with different combinations</p>
        <p>I want to add a way to save and load agents, and a way to download and upload agents to a database</p>
        <p>I want to add the ability to see genomes on screen somehow</p>
        <p>I want to play around with a predator and prey scenario, where some agents learn to catch others</p>
        <p>There are many different ways to adjust the energy system to see more interesting evolution, such as food, recovering energy by resting, reducing update speed based on energy, adding limbs just for energy storage etc</p>
        <p>I have created a few different versions of my mutate and crossover functions, I would like to let the user pick which is used.  I need to get the old ones working first</p>
        <p>Could look at creating 4 routs for re-populating instead of 2; some top performers unchanged, some top performers mutated, some offspring, and some offspring mutated</p>
        <p>Could look at implementing another idea from NEAT, where agents are given a metric based on their properties, and have a higher chance to reproduce with similar agents.  This can create species groups even within my island populations, leading to a greater variety of solutions.  This may require larger populations to work well, 100-200 agents per group, where I currently have 25 per group.</p>
        <p>I would love to make use of parallelization to spread some load across CPU cores, but JS makes this difficult.  Initial inquiries suggest its doable, but sharing memory states across CPU cores will be a challenge</p>
        <p>I want to be able to pan the screen around with arrows, not just locked to the agent.  I can also position the agent better on the screen by default</p>
        <p>Currently, my crossover methods both treat each neuron independently, it would be good to also allow groups of neurons to be transfered together so learned features are maintained.</p>
    </div>

</div>

<div class="button-container">
    <button class="floating-button start-button rightColumn" title="Start simulation with full configured settings" @onclick="ResetSimulation">Start/Reset</button>
    <button class="floating-button simpleStart-button leftColumn" title="Start simulation with no energy or extra score bonuses.  Faster, but less interesting evolution" @onclick="ResetSimulationSimple">Simplified Start</button>
    <button class="floating-button superSimpleStart-button rightColumn" title="Start simulation with no energy, extra score bonuses and a fixed body plan.  Much faster, but less interesting evolution" @onclick="ResetSimulationSuperSimple">Super Simplified Start</button>
    <button class="floating-button update-button leftColumn" title="You can update any settings mid simulation, but some changes will break things" @onclick="UpdateSimulation">Update</button>
    <button class="floating-button toggleNN-button rightColumn" title="Toggle rendering of Neural Network.  Can cause some lag" @onclick="toggleNN">Toggle Neural Network</button>
    <button class="floating-button toggleLeader-button leftColumn" title="Toggle between following the leading vs trailing agents.  Switches rendered Neural Network as well" @onclick="toggleLeader">Toggle Leader vs Trailer</button>
    <button class="floating-button toggleRays-button rightColumn" title="Toggle rendering for agents vision lines" @onclick="toggleRayCasts">Toggle Ray-casts</button>
    <button class="floating-button logGenomes-button leftColumn" title="Post all agent genomes to console" @onclick="LogGenomes">Log Genomes</button>
    <button class="floating-button retrieveGenomes-button rightColumn" title="Save current agent genome pool to continue training later" @onclick="RetrieveGenomes">Save Genomes</button>
    <button class="floating-button uploadGenomes-button leftColumn" title="Upload agent genome pool to continue training" @onclick="UploadGenomes">Upload Genomes / Start</button>
    <button class="floating-button skip10Gen-button rightColumn" title="Skips 10 generations by disabling rendering and increasing physics speed.  This will still take a few minutes" @onclick="Skip10Gen">Skip 10 Generations</button>
    <button class="floating-button skip100Gen-button leftColumn" title="Skips 1 generation by disabling rendering and increasing physics speed. This will still take a few minutes" @onclick="Skip100Gen">Skip 1 Generations</button>
    <!--add a reset settings button-->
    <!--add a super simplified start button-->
</div>

@code {
    private StageProperties stageProperties = new StageProperties();
    public bool box2dPhysics { get; set; } = true;
    private bool showAdvancedSettings = true;
    public List<Genome> population = new List<Genome>();
    public List<Genome> evolvedPopulation = new List<Genome>();

    public class StageProperties
    {
        public float Width { get; set; } = 1600;
        public float Height { get; set; } = 800;
        public float GroundY { get; set; } = 700;
        public float Gravity { get; set; } = 1;
        public double Friction { get; set; } = 0.4;
        public int SimulationLength { get; set; } = 2000;
        public int renderedAgents { get; set; } = 1;
        public int simSpeed { get; set; } = 60;
        public double topPerformerNumber { get; set; } = 20;
        public int delay { get; set; } = 20;
        public int BatchSize { get; set; } = 10;
        public bool showNN { get; set; } = false;
        public bool showRays { get; set; } = true;
        public string agentInCentre { get; set; } = "leader";
        public int numAgents { get; set; } = 25;
        public int totalNumAgentsMultiplier { get; set; } = 8;
        public int tournamentSize { get; set; } = 10;
        public double migrationRate { get; set; } = 0.002;
        public int minPopGroupSize { get; set; } = 10;
        public int maxPopGroupSize { get; set; } = 25;
        public int uiRefreshRate { get; set; } = 500;
        public int muscleDelay { get; set; } = 2;
        public int muscleBatch { get; set; } = 5;
        public int totalMuscleUpdateTime { get; set; } = 2;
        public int velocityIteration { get; set; } = 4;
        public int positionIteration { get; set; } = 2;
        public double physicsGranularityMultipliers { get; set; } = 1;
        public bool timeIncrease { get; set; } = true;
        public int map { get; set; } = 1;
        public bool randomMap { get; set; } = true;
        public int simulationLengthIncrease { get; set; } = 25;
        public int maxSimulationLength { get; set; } = 50000;
        public double maxJointSpeed { get; set; } = 1;
        public double offspringMutationRate { get; set; } = 0.02;
        public double offspringNodeMutationRate { get; set; } = 0.005;
        public double offspringLayerMutationRate { get; set; } = 0.001;
        public double offspringLimbMutationRate { get; set; } = 0.01;
        public bool brainDecayOverTime { get; set; } = false;
        public bool inputJointAngle { get; set; } = true;
        public bool inputJointSpeed { get; set; } = false;
        public bool inputAgentPos { get; set; } = true;
        public bool inputAgentV { get; set; } = true;
        public bool inputScore { get; set; } = false;
        public bool inputOrientation { get; set; } = true;
        public bool inputTimeRemaining { get; set; } = true;
        public bool inputDistanceSensors { get; set; } = true;
        public bool outputsJointSpeed { get; set; } = true;
        public bool outputsJointTorque { get; set; } = false;
        public bool outputsBias { get; set; } = false;
        public double swimBias { get; set; } = 1.5; 
        public double xScoreMultiplier { get; set; } = 3;
        public double yScoreMultiplier { get; set; } = 3;
        public double movementScoreMultiplier { get; set; } = 3;
        public double explorationScoreMultiplier { get; set; } = 5;
        public double sizeScoreMultiplier { get; set; } = 0.2;
        public int startingEnergyBase { get; set; } = 10;
        public int startingEnergyMassPower { get; set; } = 3;
        public double startingEnergyBodyMassMult { get; set; } = 1;
        public double startingEnergyLimbMassMult { get; set; } = 1;
        public double energyUseForceSizeMult { get; set; } = 1;
        public double energyUseLimbSizeMult { get; set; } = 1;
        public double energyUseBrainSizeMult { get; set; } = 1;

        // New, need to copy to other start functions and make UI selectors
        // Performance
        public int updatesPerAgentStart { get; set; } = 1;
        public int framesPerUpdateStart { get; set; } = 1;
        public bool showGroupLeaders { get; set; } = true;
        public bool showGroupTrailers { get; set; } = true;
        public int agentStartSpawnGap { get; set; } = 5000;

        // Agent
        public int minLimbs { get; set; } = 2;
        public int maxLimbs { get; set; } = 5;
        public int minNNLayers { get; set; } = 1;
        public int maxNNLayers { get; set; } = 5;
        public int startingLimbChainLength { get; set; } = 1;
        public int maxTorqueMultiplier { get; set; } = 300000;
        public int limbMassForceDivider { get; set; } = 50;
        public int limbLengthForceDivider { get; set; } = 30;
        public int agentStartX { get; set; } = 200;
        public int agentStartY { get; set; } = 600;
        public double swimStrength { get; set; } = 17;

        // Score and Energy
        public int limbMassEnergyReductionDivider { get; set; } = 15;
        public int brainSizeEnergyReductionDivider { get; set; } = 100;
        public int forceMagnitudeEnergyReductionDivider { get; set; } = 1000000;
        public int bodyStartingMassEnergyReductionDivider { get; set; } = 400;
        public int limbStartingMassEnergyReductionDivider { get; set; } = 15;
        public int jointMovementRewardLimbMassDivider { get; set; } = 100;
        public int internalMapSize { get; set; } = 500;
        public int internalMapCellSize { get; set; } = 50;
        public bool massBonusIsDynamic { get; set; } = true;
        public int dynamicMassBonusDivider { get; set; } = 500;

        // Training
        public double chanceToIncludeTopPerformerInMutation { get; set; } = 0.1;
        public double chanceToIncludeOffspringInMutation { get; set; } = 0.5;
        public double neuronMutationStandardDeviation { get; set; } = 0.1;
        public double bodyPlanMutationStandardDeviation { get; set; } = 0.1;

        // World
        public double liquidViscosity { get; set; } = 0.0005;
        public int speedNormalizationForDrag { get; set; } = 2500;
        public int backgroundRed { get; set; } = 0;
        public int backgroundGreen { get; set; } = 0;
        public int backgroundBlue { get; set; } = 128;
        public int backgroundParticles { get; set; } = 100;
        public int bodyAngularDragPower { get; set; } = 10;
        public double surfaceAreaCoefficient { get; set; } = 0.0001;

        // Advanced
        public bool agentsRequireStablising { get; set; } = false;
        public double linearStabilityThresholdBody { get; set; } = 0.01;
        public double angularStabilityThresholdBody { get; set; } = 0.15;
        public double angularStabilityThresholdLimb { get; set; } = 0.1;
        public int stabilityFrames { get; set; } = 20;
        public int swimForceOverNFrames { get; set; } = 5;
        public int maxTorqueForDamping { get; set; } = 10000;
        public double threasholdAngleForDamping { get; set; } = 0.1;
        public int renderedNNLayerGap { get; set; } = 100;
        public int renderedNNNodeGap { get; set; } = 30;
        public int maxPosForNormalisation { get; set; } = 5000;
        public int maxVelForNormalisation { get; set; } = 50;
        public int stabilityCheckOverwriteFrames { get; set; } = 500;
        public bool showForceVectors { get; set; } = true;
        public int visualForceScale { get; set; } = 20;
        public int visualMaxForceLength { get; set; } = 300;
        public int speedForceNormilizer { get; set; } = 15;

        // Behind the scenes
        public double topScoreEver { get; set; } = 0;
        public int genCount { get; set; } = 1;

    }

    private async Task setMobilePresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 5;
        stageProperties.numAgents = 5;
        stageProperties.totalNumAgentsMultiplier = 20;
        stageProperties.muscleDelay = 5;
        stageProperties.muscleBatch = 1;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task setLowPresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 10;
        stageProperties.numAgents = 20;
        stageProperties.totalNumAgentsMultiplier = 10;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 5;
        stageProperties.totalMuscleUpdateTime = 2;
    }

    private async Task setMidPresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 20;
        stageProperties.numAgents = 50;
        stageProperties.totalNumAgentsMultiplier = 5;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 10;
        stageProperties.totalMuscleUpdateTime = 2;
    }

    private async Task setHighPresets()
    {
        stageProperties.delay = 5;
        stageProperties.BatchSize = 20;
        stageProperties.numAgents = 100;
        stageProperties.totalNumAgentsMultiplier = 4;
        stageProperties.muscleDelay = 1;
        stageProperties.muscleBatch = 10;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task setVHighPresets()
    {
        stageProperties.delay = 1;
        stageProperties.BatchSize = 20;
        stageProperties.numAgents = 150;
        stageProperties.totalNumAgentsMultiplier = 3;
        stageProperties.muscleDelay = 1;
        stageProperties.muscleBatch = 15;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task resetSettings()
    {
        stageProperties.Width = 1600;  // Canvas width
        stageProperties.Height = 800;  // Canvas height
        stageProperties.GroundY = 700;  // Y position of the ground in the canvas
        stageProperties.Gravity = 1;
        stageProperties.Friction = 0.4;
        stageProperties.SimulationLength = 2000;
        stageProperties.renderedAgents = 1;
        stageProperties.simSpeed = 60;
        stageProperties.topPerformerNumber = 5;
        stageProperties.delay = 20;
        stageProperties.BatchSize = 10;
        stageProperties.showNN = false;
        stageProperties.showRays = true;
        stageProperties.agentInCentre = "leader";
        stageProperties.numAgents = 25;
        stageProperties.totalNumAgentsMultiplier = 8;
        stageProperties.tournamentSize = 10;
        stageProperties.migrationRate = 0.002;
        stageProperties.minPopGroupSize = 10;
        stageProperties.maxPopGroupSize = 25;
        stageProperties.uiRefreshRate = 500;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 5;
        stageProperties.totalMuscleUpdateTime = 2;
        stageProperties.velocityIteration = 4;
        stageProperties.positionIteration = 2;
        stageProperties.physicsGranularityMultipliers = 1;
        stageProperties.liquidViscosity = 0.99;
        stageProperties.timeIncrease = true;
        stageProperties.map = 1;
        stageProperties.randomMap = true;
        stageProperties.simulationLengthIncrease = 25;
        stageProperties.maxSimulationLength = 50000;
        stageProperties.agentsRequireStablising = true;
        stageProperties.maxJointSpeed = 1.5;
        stageProperties.offspringMutationRate = 0.02;
        stageProperties.offspringNodeMutationRate = 0.001;
        stageProperties.offspringLayerMutationRate = 0.0005;
        stageProperties.offspringLimbMutationRate = 0.005;
        stageProperties.brainDecayOverTime = false;
        stageProperties.inputJointAngle = true;
        stageProperties.inputJointSpeed = false;
        stageProperties.inputAgentPos = true;
        stageProperties.inputAgentV = true;
        stageProperties.inputScore = false;
        stageProperties.inputOrientation = true;
        stageProperties.inputTimeRemaining = true;
        stageProperties.inputDistanceSensors = true;
        stageProperties.outputsJointSpeed = true;
        stageProperties.outputsJointTorque = false;
        stageProperties.outputsBias = false;
        stageProperties.swimStrength = 600000;
        stageProperties.swimBias = 1.5;
        stageProperties.xScoreMultiplier = 3;
        stageProperties.yScoreMultiplier = 3;
        stageProperties.movementScoreMultiplier = 3;
        stageProperties.explorationScoreMultiplier = 5;
        stageProperties.sizeScoreMultiplier = 0.2;
        stageProperties.startingEnergyBase = 100;
        stageProperties.startingEnergyMassPower = 3;
        stageProperties.startingEnergyBodyMassMult = 1;
        stageProperties.startingEnergyLimbMassMult = 1;
        stageProperties.energyUseForceSizeMult = 1;
        stageProperties.energyUseLimbSizeMult = 1;
        stageProperties.energyUseBrainSizeMult = 1;
        stageProperties.maxTorqueMultiplier = 300000;
        stageProperties.updatesPerAgentStart = 1;
        stageProperties.framesPerUpdateStart = 10;
        stageProperties.topScoreEver = 0;
        stageProperties.genCount = 1;
        stageProperties.backgroundRed = 0;
        stageProperties.backgroundGreen = 0;
        stageProperties.backgroundBlue = 128;
        stageProperties.backgroundParticles = 100;
        stageProperties.linearStabilityThresholdBody = 0.01;
        stageProperties.angularStabilityThresholdBody = 0.15;
        stageProperties.angularStabilityThresholdLimb = 0.1;
        stageProperties.stabilityFrames = 10;
        stageProperties.swimForceOverNFrames = 5;
        stageProperties.limbMassForceDivider = 50;
        stageProperties.limbLengthForceDivider = 30;
        stageProperties.limbMassEnergyReductionDivider = 15;
        stageProperties.brainSizeEnergyReductionDivider = 100;
        stageProperties.forceMagnitudeEnergyReductionDivider = 1000000;
        stageProperties.maxTorqueForDamping = 10000;
        stageProperties.threasholdAngleForDamping = 0.1;
        stageProperties.bodyStartingMassEnergyReductionDivider = 400;
        stageProperties.limbStartingMassEnergyReductionDivider = 15;
        stageProperties.jointMovementRewardLimbMassDivider = 100;
        stageProperties.internalMapSize = 500;
        stageProperties.internalMapCellSize = 50;
        stageProperties.massBonusIsDynamic = true;
        stageProperties.dynamicMassBonusDivider = 500;
        stageProperties.showGroupLeaders = true;
        stageProperties.showGroupTrailers = true;
        stageProperties.agentStartX = 200;
        stageProperties.agentStartY = 600;
        stageProperties.agentStartSpawnGap = 5000;
        stageProperties.chanceToIncludeTopPerformerInMutation = 0.25;
        stageProperties.chanceToIncludeOffspringInMutation = 0.5;
        stageProperties.neuronMutationStandardDeviation = 0.1;
        stageProperties.bodyPlanMutationStandardDeviation = 0.1;
        stageProperties.renderedNNLayerGap = 100;
        stageProperties.renderedNNNodeGap = 30;
        stageProperties.maxPosForNormalisation = 5000;
        stageProperties.maxVelForNormalisation = 500;
        stageProperties.minLimbs = 2;
        stageProperties.maxLimbs = 5;
        stageProperties.minNNLayers = 1;
        stageProperties.maxNNLayers = 5;
        stageProperties.startingLimbChainLength = 1;

    }

    private async Task saveSettings()
    {
        await JSRuntime.InvokeVoidAsync("saveSettings", stageProperties);
    }

    private async Task uploadSettings()
    {
        stageProperties = await JSRuntime.InvokeAsync<StageProperties>("uploadSettings");
    }

    private async Task ResetSimulation()
    {
        await InitializePopulation(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task ResetSimulationSimple()
    {
        stageProperties.energyUseForceSizeMult = 0;
        stageProperties.energyUseLimbSizeMult = 0;
        stageProperties.energyUseBrainSizeMult = 0;
        stageProperties.startingEnergyMassPower = 0;
        stageProperties.startingEnergyBase = 1;
        stageProperties.startingEnergyBodyMassMult = 0;
        stageProperties.startingEnergyLimbMassMult = 0;
        stageProperties.movementScoreMultiplier = 1;
        stageProperties.explorationScoreMultiplier = 0;
        stageProperties.sizeScoreMultiplier = 0;
        stageProperties.offspringLayerMutationRate = 0;
        stageProperties.offspringLimbMutationRate = 0.005;
        stageProperties.agentsRequireStablising = false;
        await InitializePopulation(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task ResetSimulationSuperSimple()
    {
        stageProperties.energyUseForceSizeMult = 0;
        stageProperties.energyUseLimbSizeMult = 0;
        stageProperties.energyUseBrainSizeMult = 0;
        stageProperties.startingEnergyMassPower = 0;
        stageProperties.startingEnergyBase = 1;
        stageProperties.startingEnergyBodyMassMult = 0;
        stageProperties.startingEnergyLimbMassMult = 0;
        stageProperties.movementScoreMultiplier = 1;
        stageProperties.explorationScoreMultiplier = 0;
        stageProperties.sizeScoreMultiplier = 0;
        stageProperties.offspringNodeMutationRate = 0;
        stageProperties.offspringLayerMutationRate = 0;
        stageProperties.offspringLimbMutationRate = 0.005;
        stageProperties.swimStrength = 17;
        stageProperties.randomMap = false;
        stageProperties.map = 1;
        stageProperties.agentsRequireStablising = false;
        await InitializePopulationSimple(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task toggleNN()
    {
        stageProperties.showNN = !stageProperties.showNN;
        await UpdateSimulation();
    }

    private async Task toggleRayCasts()
    {
        stageProperties.showRays = !stageProperties.showRays;
        await UpdateSimulation();
    }

    private void ToggleAdvancedSettings()
    {
        showAdvancedSettings = !showAdvancedSettings;
    }

    private async Task UpdateSimulation()
    {
        await JSRuntime.InvokeVoidAsync("updateSimulationNEAT", stageProperties);
    }

    private async Task toggleLeader()
    {
        if (stageProperties.agentInCentre == "leader")
        {
            stageProperties.agentInCentre = "trailer";
        }
        else
        {
            stageProperties.agentInCentre = "leader";
        }

        await UpdateSimulation();
    }

    private async Task LogGenomes()
    {
        await JSRuntime.InvokeVoidAsync("logGenomes");
    }

    public override string ToString()
    {
        return JsonSerializer.Serialize(this);
    }

    private async Task RetrieveGenomes()
    {
        await JSRuntime.InvokeAsync<string>("saveGenomes");
    }

    private async Task UploadGenomes()
    {
        stageProperties = await JSRuntime.InvokeAsync<StageProperties>("uploadGenomes");
    }

    public async Task Skip10Gen()
    {
        await JSRuntime.InvokeVoidAsync("skipGen", 10);
    }

    public async Task Skip100Gen()
    {
        await JSRuntime.InvokeVoidAsync("skipGen", 1);
    }

    void Shuffle<T>(List<T> list, Random random)
    {
        int n = list.Count;
        while (n > 1)
        {
            n--;
            int k = random.Next(n + 1);
            T value = list[k];
            list[k] = list[n];
            list[n] = value;
        }
    }

    public async Task InitializePopulation(int populationSize)
    {
        population = new List<Genome>();
        Random random = new Random();
        //let agentsPerGroup = Math.ceil(totalPopulationGenomes.length / numGroups);
        // For now, set manual total population size as 10 * numAgents
        int totalPopulation = populationSize * stageProperties.totalNumAgentsMultiplier;
        // Calculate the number of groups
        int numGroups = Math.Max(1, (int)Math.Ceiling((double)totalPopulation / stageProperties.maxPopGroupSize));
        List<int> runGroups = Enumerable.Range(0, stageProperties.totalNumAgentsMultiplier)
                                         .SelectMany(x => Enumerable.Repeat(x, totalPopulation / stageProperties.totalNumAgentsMultiplier))
                                         .ToList();

        // If the total population isn't perfectly divisible by stageProperties.totalNumAgentsMultiplier,
        // add extra run groups to fill up the list
        while (runGroups.Count < totalPopulation)
        {
            runGroups.Add(new Random().Next(0, stageProperties.totalNumAgentsMultiplier));
        }

        // Shuffle the list
        runGroups = runGroups.OrderBy(x => Guid.NewGuid()).ToList();

        for (int i = 0; i < totalPopulation; i++)
        {
            Genome genome = new Genome();
            genome.Metadata.AgentIndex = i;

            int numLimbs = random.Next(stageProperties.minLimbs, stageProperties.maxLimbs);

            // Initialize genes, examples used for now, will be randomized once the constructor is complete
            genome.InputLayerGenes.Add(InitializeInputLayer(numLimbs * stageProperties.startingLimbChainLength));

            int numLayers = random.Next(stageProperties.minNNLayers, stageProperties.maxNNLayers);

            // assuming you want to add 3 layers, and the layer numbers are between 1 and 3, and sizes between 10 and 20
            for (int j = 0; j < numLayers; j++)
            {
                int randomSize = random.Next(3, 20); // Generates a random integer between 3 and 20
                genome.LayerGenes.Add(InitializeLayer(j, randomSize));
            }

            genome.OutputLayerGenes.Add(InitializeOutputLayer(numLimbs * stageProperties.startingLimbChainLength));
            genome.MainBody = InitializeBodyPlan(numLimbs);
            // initialize genome.Metadata.AgentName as random string in the format cvccvc (consonant vowel consonant consonant vowel consonant)
            var randomName = new Random();
            var consonants = "bcdfghjklmnpqrstvwxyz";
            var vowels = "aeiou";
            var agentName = $"{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}";
            genome.Metadata.AgentName = agentName;
            genome.Metadata.RunGroup = runGroups[i];
            genome.Metadata.AgentGroup = i % numGroups;
            genome.Hyperparameters.MutationRate = stageProperties.offspringMutationRate;
            genome.Hyperparameters.NodeMutationRate = stageProperties.offspringNodeMutationRate;
            genome.Hyperparameters.LayerMutationRate = stageProperties.offspringLayerMutationRate;
            genome.Hyperparameters.LimbMutationRate = stageProperties.offspringLimbMutationRate;

            // add ids to usedLayerIDs, 1 to numLayers
            genome.UsedLayerIDs = Enumerable.Range(1, numLayers).ToList();

            population.Add(genome);
        }
    }

    public async Task InitializePopulationSimple(int populationSize)
    {
        population = new List<Genome>();
        Random random = new Random();
        //let agentsPerGroup = Math.ceil(totalPopulationGenomes.length / numGroups);
        // For now, set manual total population size as 10 * numAgents
        int totalPopulation = populationSize * stageProperties.totalNumAgentsMultiplier;
        // Calculate the number of groups
        int numGroups = Math.Max(1, (int)Math.Ceiling((double)totalPopulation / stageProperties.maxPopGroupSize));
        List<int> runGroups = Enumerable.Range(0, stageProperties.totalNumAgentsMultiplier)
                                         .SelectMany(x => Enumerable.Repeat(x, totalPopulation / stageProperties.totalNumAgentsMultiplier))
                                         .ToList();

        // If the total population isn't perfectly divisible by stageProperties.totalNumAgentsMultiplier,
        // add extra run groups to fill up the list
        while (runGroups.Count < totalPopulation)
        {
            runGroups.Add(new Random().Next(0, stageProperties.totalNumAgentsMultiplier));
        }

        // Shuffle the list
        runGroups = runGroups.OrderBy(x => Guid.NewGuid()).ToList();

        for (int i = 0; i < totalPopulation; i++)
        {
            Genome genome = new Genome();
            genome.Metadata.AgentIndex = i;

            int numLimbs = 3;

            genome.InputLayerGenes.Add(InitializeInputLayer(numLimbs * stageProperties.startingLimbChainLength));

            int numLayers = 3;

            genome.LayerGenes.Add(InitializeLayer(0, 18));
            genome.LayerGenes.Add(InitializeLayer(1, 10));

            genome.OutputLayerGenes.Add(InitializeOutputLayer(numLimbs * stageProperties.startingLimbChainLength));
            genome.MainBody = InitializeBodyPlanSimple(numLimbs);
            // initialize genome.Metadata.AgentName as random string in the format cvccvc (consonant vowel consonant consonant vowel consonant)
            var randomName = new Random();
            var consonants = "bcdfghjklmnpqrstvwxyz";
            var vowels = "aeiou";
            var agentName = $"{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}";
            genome.Metadata.AgentName = agentName;
            genome.Metadata.RunGroup = runGroups[i];
            genome.Metadata.AgentGroup = i % numGroups;
            genome.Hyperparameters.MutationRate = stageProperties.offspringMutationRate;
            genome.Hyperparameters.NodeMutationRate = stageProperties.offspringNodeMutationRate;
            genome.Hyperparameters.LayerMutationRate = stageProperties.offspringLayerMutationRate;
            genome.Hyperparameters.LimbMutationRate = stageProperties.offspringLimbMutationRate;

            // add ids to usedLayerIDs, 1 to numLayers
            genome.UsedLayerIDs = Enumerable.Range(1, numLayers).ToList();

            population.Add(genome);
        }
    }

    public async Task UploadExistingPopulation()
    {
        //foreach (Genome in UploadedGenomes)
        //{
        //    Genome genome = new Genome();
        //    genome.Metadata.AgentIndex = i;

        //    // Initialize genes, examples used for now, will be randomised once the constructor is complete
        //    genome.InputLayerGenes.Add();
        //    genome.LayerGenes.Add(); // First hidden layer with 10 neurons
        //    genome.LayerGenes.Add();  // Second hidden layer with 5 neurons
        //    genome.OutputLayerGenes.Add();
        //    genome.BodyPlan = ;

        //    // Further initialization

        //    population.Add(genome);
        //}
    }

    private InputLayerGene InitializeInputLayer(int numLimbs)
    {
        return new InputLayerGene
            {
                NumberOfNeurons = 10 + numLimbs, 
                ActivationType = ActivationType.ReLU,
                Inputs = Enumerable.Range(1, 10 + numLimbs).ToList()
            };
    }

    private LayerGene InitializeLayer(int layerId, int numberOfNeurons)
    {
        return new LayerGene
            {
                LayerID = layerId,
                LayerType = LayerType.Dense,
                NumberOfNeurons = numberOfNeurons,
                ActivationType = ActivationType.ReLU
            };
    }

    private OutputLayerGene InitializeOutputLayer(int numLimbs)
    {
        return new OutputLayerGene
            {
                NumberOfNeurons = numLimbs, // 3 outputs
                ActivationType = ActivationType.Tanh,
                Outputs = Enumerable.Range(1, numLimbs).ToList() // List of outputs from 1 to 3
            };
    }

    private MainBody InitializeBodyPlan(int numLimbs)
    {
        Random random = new Random();

        MainBody mainBody = new MainBody
            {
                PartID = 0,
                NumberInChain = 0,
                Shape = "Circle",
                Size = 10 + random.NextDouble() * 30.0,
                Density = 0.1 + random.NextDouble() * 0.6,
                Arms = new List<Arm>() // Initializing the Limbs list
            };

        for (int i = 1; i <= numLimbs; i++)
        {
            double angle = random.NextDouble() * 2 * Math.PI; // Random angle in radians

            int id = i;

            Arm arm = new Arm
                {
                    PartID = id,
                    ParentPartID = 0,
                    NumberInChain = 1,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            Arm subArm = new Arm
                {
                    PartID = id + numLimbs,
                    ParentPartID = id,
                    NumberInChain = 2,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = random.NextDouble() * 2 * Math.PI,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            Arm subArm2 = new Arm
                {
                    PartID = id + numLimbs * 2,
                    ParentPartID = subArm.PartID,
                    NumberInChain = 3,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = random.NextDouble() * 2 * Math.PI,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            if (stageProperties.startingLimbChainLength > 1)
            {
                arm.SubArms.Add(subArm);
                if (stageProperties.startingLimbChainLength > 2)
                {
                    subArm.SubArms.Add(subArm2);
                }
            }

            mainBody.Arms.Add(arm);
        }

        return mainBody;
    }


    private MainBody InitializeBodyPlanSimple(int numLimbs)
    {
        Random random = new Random();

        MainBody mainBody = new MainBody
            {
                PartID = 0,
                NumberInChain = 0,
                Shape = "Circle",
                Size = 25,
                Density = 0.3,
                Arms = new List<Arm>() // Initializing the Limbs list
            };

        for (int i = 1; i <= numLimbs; i++)
        {
            double angle = ((i - 1) * 2 * Math.PI) / numLimbs;

            // reserve ids 0 to 10 for body segments
            int id = i + 10;

            Arm arm = new Arm
                {
                    PartID = id,
                    ParentPartID = 0,
                    NumberInChain = 1,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 50.0,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            Arm subArm = new Arm
                {
                    PartID = id + numLimbs,
                    ParentPartID = id,
                    NumberInChain = 2,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 40,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            Arm subArm2 = new Arm
                {
                    PartID = id + numLimbs * 2,
                    ParentPartID = subArm.PartID,
                    NumberInChain = 3,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 40,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            if (stageProperties.startingLimbChainLength > 1)
            {
                arm.SubArms.Add(subArm);
                if (stageProperties.startingLimbChainLength > 2)
                {
                    subArm.SubArms.Add(subArm2);
                }
            }

            mainBody.Arms.Add(arm);
        }

        return mainBody;
    }

    public class Genome
    {
        public List<InputLayerGene> InputLayerGenes { get; set; }
        public List<LayerGene> LayerGenes { get; set; }
        public List<OutputLayerGene> OutputLayerGenes { get; set; }
        // public List<InnovationEntry> InnovationLog { get; set; }
        public MainBody MainBody { get; set; }
        public AgentHistory AgentHistory { get; set; }
        public Hyperparameters Hyperparameters { get; set; }
        public Metadata Metadata { get; set; }
        public List<int>? UsedBiasIDs { get; set; }
        public List<int>? UsedLayerIDs { get; set; }

        public Genome()
        {
            // Initialize properties with defaults or random values.
            this.InputLayerGenes = new List<InputLayerGene>();
            this.LayerGenes = new List<LayerGene>();
            this.OutputLayerGenes = new List<OutputLayerGene>();
            // this.InnovationLog = new List<InnovationEntry>();
            this.MainBody = new MainBody();
            this.AgentHistory = new AgentHistory();
            this.Hyperparameters = new Hyperparameters();
            this.Metadata = new Metadata();
        }
    }

    public class MainBody
    {
        public int PartID { get; set; }
        public int NumberInChain { get; set; }
        public string Shape { get; set; }
        public double Size { get; set; }
        public double Density { get; set; }
        public List<Arm> Arms { get; set; } = new List<Arm>();
        public List<Wing> Wings { get; set; } = new List<Wing>();
        public List<Thruster> Thrusters { get; set; } = new List<Thruster>();
        public List<BodySegment> BodySegments { get; set; } = new List<BodySegment>();
        public List<int> UsedLimbIDs { get; set; } = new List<int>();
    }

    public class BodySegment
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Size { get; set; }
        public double Density { get; set; }
        public JointConstraints? Constraints { get; set; }
        public AttachmentPoint Attachment { get; set; }
        public List<Arm> Arms { get; set; } = new List<Arm>();
        public List<Wing> Wings { get; set; } = new List<Wing>();
        public List<Thruster> Thrusters { get; set; } = new List<Thruster>();
    }

    public class Arm
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
        public List<Arm> SubArms { get; set; } = new List<Arm>(); 
        public List<Wing> SubWings { get; set; } = new List<Wing>(); 
        public List<Thruster> SubThrusters { get; set; } = new List<Thruster>(); 
    }

    public class Wing
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
    }

    public class Thruster
    {
        public double ThrustForce { get; set; }
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
    }

    public class AttachmentPoint
    {
        public double? X { get; set; }
        public double? Y { get; set; }
    }

    public class JointConstraints
    {
        public double? MaxTorque { get; set; }
        public double? MinAngle { get; set; }
        public double? MaxAngle { get; set; }
    }

    // Encode the agents history into the genome:

    public class AgentHistory
    {
        public bool RunThisGeneration { get; set; }
        public ScoreHistory? LastScore { get; set; }
        public List<ScoreHistory>? ScoreHistory { get; set; }
        public int RoundsAsTopPerformer { get; set; }
        public int UsedAsParent { get; set; }
        public List<String>? Mutations { get; set; }
        public double RankInGroup { get; set; }
        public double RankInPop { get; set; }

        public AgentHistory()
        {
            this.LastScore = new ScoreHistory();
            this.RunThisGeneration = false;
            this.ScoreHistory = new List<ScoreHistory>();
            this.RoundsAsTopPerformer = 0;
            this.UsedAsParent = 0;
            this.Mutations = new List<String>();
        }
    }

    public class ScoreHistory
    {
        public float Score { get; set; }
        public int Map { get; set; }
        public int Generation { get; set; }
    }

    public class Hyperparameters
    {
        public double MutationRate { get; set; }
        public double NodeMutationRate { get; set; }
        public double LayerMutationRate { get; set; }
        public double LimbMutationRate { get; set; }
    }

    public class Metadata
    {
        public int RunGroup { get; set; }
        public int AgentGroup { get; set; }
        public string AgentName { get; set; }
        public int AgentIndex { get; set; }
        public string GroupName { get; set; }
        public string Species { get; set; }
        public double BestScore { get; set; }
        public int CompatabilityDistance { get; set; }

        public Metadata()
        {
            // Initialize with default values, or leave them null.  Should maybe have these as parameters in the call
            this.AgentName = "Unnamed"; // Set randomly on initialization, unique to an agent
            this.AgentIndex = 0; // Set randomly on initialization, unique to an agent
            this.GroupName = "DefaultGroup"; // set randomly on initialization, the same for all agents in a population
            this.Species = "Unspecified"; // set randomly on initialization, same for agents in the same spices.  might need to set this later after distinct spices groups form.
            this.BestScore = 0; // Set to 0 on initialization, updated after each round
            this.CompatabilityDistance = 0; // Set to 0 on initialization, updated after each round
        }
    }

    public class InputLayerGene
    {
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<Bias>? Biases { get; set; }
        public List<int>? Inputs { get; set; }

        public InputLayerGene()
        {
            this.Biases = new List<Bias>();
            this.Inputs = new List<int>();
        }
    }

    public class LayerGene
    {
        public int LayerID { get; set; }
        public LayerType LayerType { get; set; }  // "Dense", "Conv", "LSTM", etc.
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<List<Weight>>? Weights { get; set; }
        public List<Bias>? Biases { get; set; }

        public LayerGene()
        {
            this.Weights = new List<List<Weight>>();
            this.Biases = new List<Bias>();            
        }
    }

    public class OutputLayerGene
    {
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<List<Weight>>? Weights { get; set; }
        public List<Bias>? Biases { get; set; }
        public List<int>? Outputs { get; set; }

        public OutputLayerGene()
        {
            this.Weights = new List<List<Weight>>();
            this.Biases = new List<Bias>();
            this.Outputs = new List<int>();
        }
    }

    public class Weight
    {
        //public int ID { get; set; }
        public int FromNodeID { get; set; }
        public int ToNodeID { get; set; }
        public double? Value { get; set; }
    }

    public class Bias
    {
        public int ID { get; set; }
        public double? Value { get; set; }
    }

    public enum LayerType
    {
        Dense,
        Convolutional,
        LSTM,
        // ...other types
    }

    public enum ActivationType
    {
        ReLU,
        Sigmoid,
        Tanh,
        // ...other types
    }
}

