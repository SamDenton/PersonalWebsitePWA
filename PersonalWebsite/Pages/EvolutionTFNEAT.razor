@page "/EvolutionTFNEAT"
@inject IJSRuntime JSRuntime

<h2 class="pageTitle">Semi-NEAT Genetic Evolution Simulation</h2>

@* <p>My Implementation of the NEAT algorithm, adapted for TesnorFlow.JS</p>
<p>Like most of the site, this will work on mobile, but its not designed for it</p>
<p>The documentation below, and on the <a style="text-decoration: none" href="/Projects/all/all">Projects Page of the Wiki</a> will give an explanation of whats going on and how to get started</p>
 *@
<div id="canvas-container-NEAT"></div>

<div class="settings-preset-Buttons">
    @* <h4 class="presetsTitle">Presets</h4> *@
    <button class="preset-button mobile-button" title="Set mobile powered presets" @onclick="setMobilePresets">Mobile Power Settings Preset</button>
    <button class="preset-button low-button" title="Set low powered presets" @onclick="setLowPresets">Low Power Settings Preset</button>
    <button class="preset-button mid-button" title="Set medium powered presets" @onclick="setMidPresets">Medium Power Settings Preset</button>
    <button class="preset-button high-button" title="Set high powered presets" @onclick="setHighPresets">High Power Settings Preset</button>
    <button class="preset-button vHigh-button" title="Set very high powered presets" @onclick="setVHighPresets">Very High Power Settings Preset</button>
    <button class="preset-button reset-button" title="Resets settings to default everything" @onclick="resetSettings">Reset All Settings</button>
    <button class="preset-button save-button" title="Saves current settings to a JSON file" @onclick="saveSettings">Save Settings To File</button>
    <button class="preset-button upload-button" title="Uploaded saved settings JSON" @onclick="uploadSettings">Upload Settings File</button>
</div>

<div class="tabs">
    @foreach (var tab in tabs)
    {
        <button class="@(tab == activeTab ? "tab-button active" : "tab-button")" @onclick="() => SetActiveTab(tab)">
            @tab.Title
        </button>
    }
</div>

<div class="tab-content">
    @if (activeTab != null)
    {
        @if (activeTab.Title == "Home")
        {
            <div class="simDescription">
                <h4>Welcome to My Genetic Evolution Simulator!</h4>
                <p class="tagline">Read on to get started!</p>
                <h5>Quick Start Guide:</h5>
                <p>Please select a pre-configuration from the top to get a good starting point.</p>
                <p>You can then use the settings tabs to alter specific settings.</p>
                <p>Click Start/Reset, Simplified Start or Super Simplified Start from the top right menu to begin.</p>
                <p>Start/Reset will respect all configurations, while Simplified Start will remove the energy system, some score bonuses, limb and layer number mutations, and a few other things</p>
                <p>Simplified Start should see much faster learning, with agents completing the maps with 50 generations or so, using full configurations will result in much more interesting behavior, but will take 100+ generations to see much progress</p>
                <p>Super Simplified Start will also give agents a small, fixed brain and preset body plan, and will see agents complete the maps in 20-30 generations</p>
                <p>Use the button bank in the top right to toggle rendering of the leading agents brain/neural network, their vision lines/ray casts, switch between the leading agent and training agent or fast-forward generations (only about twice as fast as normal currently)</p>
                <p>Logging the genomes writes the current population to the console, and retrieving genomes is the first step towards implementing an agent database online where pre-trained agents cam be stored and retrieved.</p>
                <p>The skip x generation buttons will disable the rendering and increase the physics update rate by 4x.  If you are already running at the limit of what your computer can handle, IE. your fps is below 30-40 at normal speed, this is not going to actually speed up much.  The rendering only adds about 10% to the processing time per frame.</p>
                <h5>Some Explanation:</h5>
                <p>This is my take on a NEAT genetic evolution simulation.</p>
                <p>I would describe this as a 'Semi-NEAT' algorithm since I have restriction on what network shapes can evolve.  This is due to TensorFlow.JS's restriction to static models, where a full NEAT implementation requires dynamic models, and more control over connections</p>
                <p>Resetting/updating is a little buggy, its currently best to refresh the page if you want to try new settings</p>
                <p>Showing the Neural Network on screen adds a fair amount of lag so its hidden by default</p>
                <p>I am making use of P5.JS for my rendering, Planck.JS; a port of Box2D, for my physics and TensorFlow.JS for my neural network processing</p>
                <h5>So whats going on?</h5>
                <p>If you start the simulation with default settings, you will see about 15 agents on the screen, representing the top scorer from each group, a random agent per group, the agent that has made it furthest right, and the furthest left agent</p>
                <p>Default settings will produce 200 agents in the population, split into batches of 25, as well as species groups.  25 agents from the run group are evaluated at a time, with a random selection of species</p>
                <p>On my PC, using a Ryzen 7 3700X CPU about 3.5Ghz per core, I can target about 150 agents at a time, with 10 Agents Per Batch of Joint Updates.  The Number of Inter-gen Batches will not effect performance, but will increase training time, as only 1 batch can be evaluated at a time</p>
                <p>Since i'm making use of JS, the bottleneck for most systems is going to be the speed of a single CPU core.  Some configurations may reach a browser memory limit before a CPU limit, if you have a high number of inter-gen batches.  Browsers I have tested seem ok up to about 1000 agents total</p>
                <p>The GPU is also utilized for any Neural Network functions, the most intense of which happen between rounds, so it doesn't really matter how long they take, but during the simulation, the actual decision making also utilities the GPU using WebGL.  I have not found a configuration where this is the bottleneck, but its possible</p>
                <p>Each round, the agents have 2000 ticks, about 34 seconds at 60 fps with default physics speed of 60, to move as far North East as possible.</p>
                <p>The agents are all given a randomly initialized neural network, with a random shape for a brain, the leaders brain is rendered.  They are given a random body plan.  Both the brain and the body plan will evolve over time based on a number of crossover and mutation functions</p>
                <p>Between rounds, the agents are sorted by score, where the top x% from each species are selected to remain unchanged, and the other 90% of the population is built using crossover and mutation.</p>
                <p>This is performed between generations, on the whole population</p>
                <p>Crossover is the function of picking 2 parent agents and combining the weights and biases in their brains, keeping some features from one, and some from the other.  There are a range of methods for this, I am currently using biased Arithmetic Crossover, where there is a weighted bias given by the relative scores of the parents.</p>
                <p>Mutation adds a small chance that each weight, bias, limb or body will be altered by a small, random amount.  Again, there are many methods, currently i am using the Box-Muller transform to get a Gaussian random number for my mutation amount.  I have a function that changes the mutation rate if agents brains get too close to the average</p>
                <p>I am currently also mutating the number of limbs and layers in the brain.  These are more complex to mutate than others, as they tend to produce 'dead' agents that need retaining from scratch, which naturaly cant compete with already trained agents.  I am playing with a number of methods to counter this.</p>
                <p>Now, when a new limb is mutated, it finds an existing limb with a similar starting angle, and copies the weights from that limb.  When a new layer is mutated, it should create a matching layer, where biases are copied from the previous layer, and weights are connected so the old node connects to its new copy with a weight of 1, and all other weights are 0 in the new layer, hopefully copying the previous layers function until new values are evolved.</p>
                <p>The parents for crossover can be selected in many ways, I am actually using 1 method for 1 parent, and another for the other.  The first is picked via tournament selection, where 10 random agents are selected from the group, and the best of those if picked.  The second is picked via a weighted random selection, where ever agent is entered into a lottery with more entries for a higher score, and a random agent is picked from the pool.</p>
                <p>I am also using 'Island Populations' or 'Island Speciation', where parents are always picked from the same distinct group.  This means, with default settings, 3 distinct populations should evolve with different strategies.  There is a small chance that parents are picked from a different group, allowing some sharing of strategies</p>
                <p>You should see some 'evolution' within  50 or so generations, and they can continue to improve indefinitely, however, they can get stuck in whats known as a 'local maxima' where the agents converge on 1 or a few ok strategies, and never seem to improve.  Through mutation, they might eventually, but in those situations, its best to restart.  A greater number of agents or distinct population groups can help with this</p>
                <p>If enabled, I am experimenting with a form of normalization which slowly decays all weights in the network over time.  It's meant to prevent any noise in the network over time, based on a 'use it or loose it' principal.  Useful connections should be maintained by re-selection and unused connections will drop away</p>
                <h5>Current Selective Pressures:</h5>
                <ol>
                    <li>Score for movement North East</li>
                    <li>Bonus for joint movement that diminishes over time</li>
                    <li>Exploration bonus</li>
                    <li>Size bonus</li>
                    <li>Larger limbs give more swimming force</li>
                </ol>
                <h6>Energy System:</h6>
                <ol>
                    <li>Starting energy based on body size, larger bodies can store more energy</li>
                    <li>More energy is used to move larger limbs</li>
                    <li>Agents limb movement speed is based on their remaining energy %, with no energy, they cant move at all</li>
                </ol>
                <h5>Future Plans</h5>
                <p>There is a lot of clean up work to do on the code, the genome and the agent objects.  I have lots of duplicated values and old structures.  I am not making use of 'const' enough, and I am duplicating functions in places</p>
                <p>I need to work on the maps.  They are too simple and not varied enough.  I want to implement some goals, like food, tied to the energy system.  A puzzle to open a door or similar could also be interesting</p>
                <p>I want to make all variables customizable, which is a huge number.  I need to find a nice way to arrange them</p>
                <p>I plan on adding further ways the agents can evolve. I want to allow more complex body plans with different types of limb and body segments, such as wings, thrusters, suckers, energy storage limbs etc</p>
                <p>I want to add a greater range of crossover, mutation and selection methods to increase diversity, and have them toggle in settings to play with different combinations</p>
                <p>I want to add a way to save and load agents, and a way to download and upload agents to a database</p>
                <p>I want to add the ability to see genomes on screen somehow</p>
                <p>I want to play around with a predator and prey scenario, where some agents learn to catch others</p>
                <p>There are many different ways to adjust the energy system to see more interesting evolution, such as food, recovering energy by resting, reducing update speed based on energy, adding limbs just for energy storage etc</p>
                <p>I have created a few different versions of my mutate and crossover functions, I would like to let the user pick which is used.  I need to get the old ones working first</p>
                <p>Could look at creating 4 routs for re-populating instead of 2; some top performers unchanged, some top performers mutated, some offspring, and some offspring mutated</p>
                <p>Could look at implementing another idea from NEAT, where agents are given a metric based on their properties, and have a higher chance to reproduce with similar agents.  This can create species groups even within my island populations, leading to a greater variety of solutions.  This may require larger populations to work well, 100-200 agents per group, where I currently have 25 per group.</p>
                <p>I would love to make use of parallelization to spread some load across CPU cores, but JS makes this difficult.  Initial inquiries suggest its doable, but sharing memory states across CPU cores will be a challenge</p>
                <p>I want to be able to pan the screen around with arrows, not just locked to the agent.  I can also position the agent better on the screen by default</p>
                <p>Currently, my crossover methods both treat each neuron independently, it would be good to also allow groups of neurons to be transfered together so learned features are maintained.</p>
            </div>
        }
        else if (activeTab.Title == "Favourites")
        {
            <div class="settings-container">
                @foreach (var favSettingName in stageProperties.FavouriteSettings)
                {
                    var favSetting = tabs.SelectMany(tab => tab.Settings)
                    .FirstOrDefault(setting => setting.Name == favSettingName);

                    if (favSetting == null)
                    {
                        favSetting = tabs.SelectMany(tab => tab.AdvancedSettings)
                        .FirstOrDefault(setting => setting.Name == favSettingName);
                    }

                    if (favSetting != null)
                    {
                        <div class="@(favSetting.Type == SettingType.Slider || favSetting.Type == SettingType.Dropdown ? "setting large" : "setting")">
                            <label>@favSetting.Name</label>
                            @switch (favSetting.Type)
                            {
                                case SettingType.Slider:
                                    <input type="range" @bind="favSetting.Value" min="@favSetting.Min" max="@favSetting.Max" step="@favSetting.Step" />
                                    <input type="number" @bind="favSetting.Value" min="@favSetting.Min" max="@favSetting.Max" step="@favSetting.Step" />
                                    break;
                                case SettingType.Dropdown:
                                    <select @bind="favSetting.SelectedValue">
                                        @foreach (var option in favSetting.Options)
                                        {
                                            <option value="@option">@option</option>
                                        }
                                    </select>
                                    break;
                                case SettingType.Checkbox:
                                    <label class="switch">
                                        <input type="checkbox" @bind="favSetting.BooleanValue" />
                                        <span class="slider"></span>
                                    </label>
                                    break;
                            }
                            <button @onclick="@(() => ToggleFavourite(favSetting.Name))" class="favourite-button">
                                @if (stageProperties.FavouriteSettings.Contains(favSetting.Name))
                                {
                                    <span class="favourited">★</span> <!-- Marked as favourite -->
                                }
                                else
                                {
                                    <span>☆</span> <!-- Not favourite -->
                                }
                            </button>
                            <p class="setting-details">@favSetting.Details</p>
                        </div>
                    }
                }
            </div>
        }
        else
        {
            <p class="tabDesc">@activeTab.Description</p>
            <div class="settings-container">
                @foreach (var setting in activeTab.Settings)
                {
                    <div class="@(setting.Type == SettingType.Slider || setting.Type == SettingType.Dropdown ? "setting large" : "setting")">
                        <label>@setting.Name</label>
                        @switch (setting.Type)
                        {
                            case SettingType.Slider:
                                <input type="range" @bind="setting.Value" min="@setting.Min" max="@setting.Max" step="@setting.Step" />
                                <input type="number" @bind="setting.Value" min="@setting.Min" max="@setting.Max" step="@setting.Step" />
                                break;
                            case SettingType.Dropdown:
                                <select @bind="setting.SelectedValue">
                                    @foreach (var option in setting.Options)
                                    {
                                        <option value="@option">@option</option>
                                    }
                                </select>
                                break;
                            case SettingType.Checkbox:
                                <label class="switch">
                                    <input type="checkbox" @bind="setting.BooleanValue" />
                                    <span class="slider"></span>
                                </label>
                                break;
                        }
                        <button @onclick="@(() => ToggleFavourite(setting.Name))" class="favourite-button">
                            @if (stageProperties.FavouriteSettings.Contains(setting.Name))
                            {
                                <span class="favourited">★</span> <!-- Marked as favourite -->
                            }
                            else
                            {
                                <span>☆</span> <!-- Not favourite -->
                            }
                        </button>
                        <p class="setting-details">@setting.Details</p>
                    </div>
                }
                @if (activeTab.HasAdvanced)
                {
                    <button class="toggleAdvanced" @onclick="() => ToggleAdvanced(activeTab)">Toggle Advanced</button>
                    @if (activeTab.ShowAdvanced)
                    {
                        @foreach (var advancedSetting in activeTab.AdvancedSettings)
                        {
                            <div class="@(advancedSetting.Type == SettingType.Slider || advancedSetting.Type == SettingType.Dropdown ? "setting large" : "setting")">
                                <label>@advancedSetting.Name</label>
                                @switch (advancedSetting.Type)
                                {
                                    case SettingType.Slider:
                                        <input type="range" @bind="advancedSetting.Value" min="@advancedSetting.Min" max="@advancedSetting.Max" step="@advancedSetting.Step" />
                                        <input type="number" @bind="advancedSetting.Value" min="@advancedSetting.Min" max="@advancedSetting.Max" step="@advancedSetting.Step" />
                                        break;
                                    case SettingType.Dropdown:
                                        <select @bind="advancedSetting.SelectedValue">
                                            @foreach (var option in advancedSetting.Options)
                                            {
                                                <option value="@option">@option</option>
                                            }
                                        </select>
                                        break;
                                    case SettingType.Checkbox:
                                        <label class="switch">
                                            <input type="checkbox" @bind="advancedSetting.BooleanValue" />
                                            <span class="slider"></span>
                                        </label>
                                        break;
                                }
                                <button @onclick="@(() => ToggleFavourite(advancedSetting.Name))" class="favourite-button">
                                    @if (stageProperties.FavouriteSettings.Contains(advancedSetting.Name))
                                    {
                                        <span class="favourited">★</span> <!-- Marked as favourite -->
                                    }
                                    else
                                    {
                                        <span>☆</span> <!-- Not favourite -->
                                    }
                                </button>
                                <p class="setting-details">@advancedSetting.Details</p>
                            </div>
                        }
                    }
                }
            </div>
        }
    }
</div>

<div class="button-container">
    <button class="floating-button start-button rightColumn" title="Start simulation with full configured settings" @onclick="ResetSimulation">Start/Reset</button>
    <button class="floating-button simpleStart-button leftColumn" title="Start simulation with no energy or extra score bonuses.  Faster, but less interesting evolution" @onclick="ResetSimulationSimple">Simplified Start</button>
    <button class="floating-button superSimpleStart-button rightColumn" title="Start simulation with no energy, extra score bonuses and a fixed body plan.  Much faster, but less interesting evolution" @onclick="ResetSimulationSuperSimple">Super Simplified Start</button>
    <button class="floating-button update-button leftColumn" title="You can update any settings mid simulation, but some changes will break things" @onclick="UpdateSimulation">Update</button>
    <button class="floating-button toggleNN-button rightColumn" title="Toggle rendering of Neural Network.  Can cause some lag" @onclick="toggleNN">Toggle Neural Network</button>
    <button class="floating-button toggleLeader-button leftColumn" title="Toggle between following the leading vs trailing agents.  Switches rendered Neural Network as well" @onclick="toggleLeader">Toggle Leader vs Trailer</button>
    <button class="floating-button toggleRays-button rightColumn" title="Toggle rendering for agents vision lines" @onclick="toggleRayCasts">Toggle Ray-casts</button>
    <button class="floating-button logGenomes-button leftColumn" title="Post all agent genomes to console" @onclick="LogGenomes">Log Genomes</button>
    <button class="floating-button retrieveGenomes-button rightColumn" title="Save current agent genome pool to continue training later" @onclick="RetrieveGenomes">Save Genomes</button>
    <button class="floating-button uploadGenomes-button leftColumn" title="Upload agent genome pool to continue training" @onclick="UploadGenomes">Upload Genomes / Start</button>
    <button class="floating-button skip10Gen-button rightColumn" title="Skips 10 generations by disabling rendering and increasing physics speed.  This will still take a few minutes" @onclick="Skip10Gen">Skip 10 Generations</button>
    <button class="floating-button skip100Gen-button leftColumn" title="Skips 1 generation by disabling rendering and increasing physics speed. This will still take a few minutes" @onclick="Skip100Gen">Skip 1 Generations</button>
</div>

@code {

    private TabModel activeTab;

    protected override void OnInitialized()
    {
        InitializeTabs();
        activeTab = tabs.FirstOrDefault(); // Set the first tab as active by default
    }

    private List<TabModel> tabs;
    private void InitializeTabs()
    {
        tabs = new List<TabModel>
        {
            new TabModel
            {
                Title = "Home",
                Description = "This is the home tab.  I will have the whole introduction here.",
                HasAdvanced = false
            },
            new TabModel
            {
                Title = "Favourites",
                Settings = new List<Setting>(), // This will be populated dynamically
                HasAdvanced = false
            },
            new TabModel
            {
                Title = "Performance",
                Description = "Configure the performance-related aspects of the simulation.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Number of Agents",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.numAgents,
                        ValueChanged = val => stageProperties.numAgents = val,
                        Min = 1,
                        Max = 100,
                        Step = 1,
                        Details = "Determines the number of agents active at any given time."
                    },
                    new Setting
                    {
                        Name = "Agent Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.totalNumAgentsMultiplier,
                        ValueChanged = val => stageProperties.totalNumAgentsMultiplier = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier to increase the total number of agents in the population."
                    },
                    new Setting
                    {
                        Name = "Muscle Update Delay",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.muscleDelay,
                        ValueChanged = val => stageProperties.muscleDelay = val,
                        Min = 0,
                        Max = 10,
                        Step = 1,
                        Details = "Delay between muscle updates, affecting agent movement fluidity."
                    },
                    new Setting
                    {
                        Name = "Muscle Batch Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.muscleBatch,
                        ValueChanged = val => stageProperties.muscleBatch = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Number of muscle updates processed together in a batch."
                    },
                    new Setting
                    {
                        Name = "Simulation Speed",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.simSpeed,
                        ValueChanged = val => stageProperties.simSpeed = val,
                        Min = 10,
                        Max = 120,
                        Step = 1,
                        Details = "Adjusts the physics speed of the simulation."
                    },
                    new Setting
                    {
                        Name = "Brain Decay",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.brainDecayOverTime,
                        BooleanValueChanged = val => stageProperties.brainDecayOverTime = val,
                        Details = "Toggles whether the agents' brains decay over time."
                    },
                    new Setting
                    {
                        Name = "Agent in Centre",
                        Type = SettingType.Dropdown,
                        SelectedValueExpression = () => stageProperties.agentInCentre,
                        SelectedValueChanged = val => stageProperties.agentInCentre = val,
                        Options = new List<string> { "leader", "trailer", "average" },
                        Details = "Selects the agent to focus the camera on."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Total Muscle Update Time",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.totalMuscleUpdateTime,
                        ValueChanged = val => stageProperties.totalMuscleUpdateTime = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Defines the total time for muscle updates."
                    },
                    new Setting
                    {
                        Name = "Delay",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.delay,
                        ValueChanged = val => stageProperties.delay = val,
                        Min = 0,
                        Max = 50,
                        Step = 1,
                        Details = "Sets the delay parameter for processing."
                    },
                    new Setting
                    {
                        Name = "Batch Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.BatchSize,
                        ValueChanged = val => stageProperties.BatchSize = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Determines the size of each batch in processing."
                    },
                    new Setting
                    {
                        Name = "Updates Per Agent Start",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.updatesPerAgentStart,
                        ValueChanged = val => stageProperties.updatesPerAgentStart = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Specifies the number of updates per agent at the start."
                    },
                    new Setting
                    {
                        Name = "Frames Per Update Start",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.framesPerUpdateStart,
                        ValueChanged = val => stageProperties.framesPerUpdateStart = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the number of frames per update at the start."
                    },
                    new Setting
                    {
                        Name = "Rendered Agents",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.renderedAgents,
                        ValueChanged = val => stageProperties.renderedAgents = val,
                        Min = 1,
                        Max = 50,
                        Step = 1,
                        Details = "Controls the number of agents rendered in the simulation."
                    },
                    new Setting
                    {
                        Name = "Show Group Leaders",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showGroupLeaders,
                        BooleanValueChanged = val => stageProperties.showGroupLeaders = val,
                        Details = "Toggle to show or hide group leaders in the simulation."
                    },
                    new Setting
                    {
                        Name = "Show Group Trailers",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showGroupTrailers,
                        BooleanValueChanged = val => stageProperties.showGroupTrailers = val,
                        Details = "Toggle to show or hide group trailers in the simulation."
                    },
                    new Setting
                    {
                        Name = "Agent Start Spawn Gap",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.agentStartSpawnGap,
                        ValueChanged = val => stageProperties.agentStartSpawnGap = val,
                        Min = 1000,
                        Max = 10000,
                        Step = 500,
                        Details = "Defines the gap between agent spawns at the start."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
            Title = "Agent",
            Description = "Configure the properties of the agents.",
            Settings = new List<Setting>
            {
                new Setting
                {
                    Name = "Minimum Limbs",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.minLimbs,
                    ValueChanged = val => stageProperties.minLimbs = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Sets the minimum number of limbs for an agent."
                },
                new Setting
                {
                    Name = "Maximum Limbs",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.maxLimbs,
                    ValueChanged = val => stageProperties.maxLimbs = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Sets the maximum number of limbs for an agent."
                },
                new Setting
                {
                    Name = "Minimum Neural Network Layers",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.minNNLayers,
                    ValueChanged = val => stageProperties.minNNLayers = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Determines the minimum number of neural network layers in an agent."
                },
                new Setting
                {
                    Name = "Maximum Neural Network Layers",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.maxNNLayers,
                    ValueChanged = val => stageProperties.maxNNLayers = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Determines the maximum number of neural network layers in an agent."
                },
                new Setting
                {
                    Name = "Starting Limb Chain Length",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.startingLimbChainLength,
                    ValueChanged = val => stageProperties.startingLimbChainLength = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Sets the initial limb chain length for each agent."
                },
                new Setting
                {
                    Name = "Swim Strength",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.swimStrength,
                    ValueChanged = val => stageProperties.swimStrength = val,
                    Min = 0,
                    Max = 50,
                    Step = 1,
                    Details = "Adjusts the swim strength of agents in aquatic environments."
                },
                new Setting
                {
                    Name = "Swim Bias",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.swimBias,
                    ValueChanged = val => stageProperties.swimBias = val,
                    Min = 0,
                    Max = 20,
                    Step = 1,
                    Details = "Modifies the bias applied to swimming actions of agents."
                },
                new Setting
                {
                    Name = "Maximum Joint Speed",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.maxJointSpeed,
                    ValueChanged = val => stageProperties.maxJointSpeed = val,
                    Min = 5,
                    Max = 20,
                    Step = 1,
                    Details = "Controls the maximum speed of joint movements for agents."
                },
            },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Max Torque Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxTorqueMultiplier,
                        ValueChanged = val => stageProperties.maxTorqueMultiplier = val,
                        Min = 100000,
                        Max = 500000,
                        Step = 10000,
                        Details = "Adjusts the maximum torque multiplier for agents."
                    },
                    new Setting
                    {
                        Name = "Limb Mass Force Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbMassForceDivider,
                        ValueChanged = val => stageProperties.limbMassForceDivider = val,
                        Min = 10,
                        Max = 100,
                        Step = 5,
                        Details = "Determines the force divider for limb mass."
                    },
                    new Setting
                    {
                        Name = "Limb Length Force Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbLengthForceDivider,
                        ValueChanged = val => stageProperties.limbLengthForceDivider = val,
                        Min = 10,
                        Max = 100,
                        Step = 5,
                        Details = "Sets the force divider based on the limb length."
                    },
                    new Setting
                    {
                        Name = "Agent Start X Position",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.agentStartX,
                        ValueChanged = val => stageProperties.agentStartX = val,
                        Min = 100,
                        Max = 1000,
                        Step = 50,
                        Details = "Initial X-axis position of the agent in the environment."
                    },
                    new Setting
                    {
                        Name = "Agent Start Y Position",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.agentStartY,
                        ValueChanged = val => stageProperties.agentStartY = val,
                        Min = 100,
                        Max = 1000,
                        Step = 50,
                        Details = "Initial Y-axis position of the agent in the environment."
                    },
                    new Setting
                    {
                        Name = "Swim Force Over N Frames",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.swimForceOverNFrames,
                        ValueChanged = val => stageProperties.swimForceOverNFrames = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Number of frames over which swim force is applied."
                    },
                    new Setting
                    {
                        Name = "Speed Force Normalizer",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.speedForceNormilizer,
                        ValueChanged = val => stageProperties.speedForceNormilizer = val,
                        Min = 5,
                        Max = 30,
                        Step = 1,
                        Details = "Normalizes the speed force applied to agents."
                    },
                    new Setting
                    {
                        Name = "Speed Normalization for Drag",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.speedNormalizationForDrag,
                        ValueChanged = val => stageProperties.speedNormalizationForDrag = val,
                        Min = 1000,
                        Max = 5000,
                        Step = 100,
                        Details = "Adjusts speed normalization factor for drag calculations."
                    },
                    new Setting
                    {
                        Name = "Body Angular Drag Power",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.bodyAngularDragPower,
                        ValueChanged = val => stageProperties.bodyAngularDragPower = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Controls the angular drag power on the agent's body."
                    },
                    new Setting
                    {
                        Name = "Max Torque for Damping",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxTorqueForDamping,
                        ValueChanged = val => stageProperties.maxTorqueForDamping = val,
                        Min = 5000,
                        Max = 20000,
                        Step = 500,
                        Details = "Sets the maximum torque value for damping."
                    },
                    new Setting
                    {
                        Name = "Threshold Angle for Damping",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.threasholdAngleForDamping,
                        ValueChanged = val => stageProperties.threasholdAngleForDamping = val,
                        Min = 5,
                        Max = 20,
                        Step = 1,
                        Details = "Determines the threshold angle for applying damping."
                    },
                    new Setting
                    {
                        Name = "Input Joint Angle",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputJointAngle,
                        BooleanValueChanged = val => stageProperties.inputJointAngle = val,
                        Details = "Enables or disables the input of joint angles to the agent's brain."
                    },
                    new Setting
                    {
                        Name = "Input Joint Speed",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputJointSpeed,
                        BooleanValueChanged = val => stageProperties.inputJointSpeed = val,
                        Details = "Determines if joint speed information is fed into the agent's brain."
                    },
                    new Setting
                    {
                        Name = "Input Agent Position",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputAgentPos,
                        BooleanValueChanged = val => stageProperties.inputAgentPos = val,
                        Details = "Controls whether the agent's position is used as input to its brain."
                    },
                    new Setting
                    {
                        Name = "Input Agent Velocity",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputAgentV,
                        BooleanValueChanged = val => stageProperties.inputAgentV = val,
                        Details = "Enables or disables the use of agent velocity as a brain input."
                    },
                    new Setting
                    {
                        Name = "Input Current Score",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputScore,
                        BooleanValueChanged = val => stageProperties.inputScore = val,
                        Details = "Determines if the agent's current score is input to the brain."
                    },
                    new Setting
                    {
                        Name = "Input Orientation",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputOrientation,
                        BooleanValueChanged = val => stageProperties.inputOrientation = val,
                        Details = "Toggles whether the agent's orientation is an input for its brain."
                    },
                    new Setting
                    {
                        Name = "Input Time Remaining",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputTimeRemaining,
                        BooleanValueChanged = val => stageProperties.inputTimeRemaining = val,
                        Details = "Allows the remaining time to be an input parameter to the agent's brain."
                    },
                    new Setting
                    {
                        Name = "Input Distance Sensors",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputDistanceSensors,
                        BooleanValueChanged = val => stageProperties.inputDistanceSensors = val,
                        Details = "Enables distance sensors as inputs to the agent's decision-making process."
                    },
                    new Setting
                    {
                        Name = "Output Joint Speed",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.outputsJointSpeed,
                        BooleanValueChanged = val => stageProperties.outputsJointSpeed = val,
                        Details = "Controls if the agent's brain can output joint speed commands."
                    },
                    new Setting
                    {
                        Name = "Output Joint Torque",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.outputsJointTorque,
                        BooleanValueChanged = val => stageProperties.outputsJointTorque = val,
                        Details = "Determines whether the brain can output joint torque instructions."
                    },
                    new Setting
                    {
                        Name = "Output Bias",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.outputsBias,
                        BooleanValueChanged = val => stageProperties.outputsBias = val,
                        Details = "Enables or disables the output of bias values from the agent's brain."
                    }
                    // public bool brainDecayOverTime { get; set; } = false; // Not implemented
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "Score and Energy",
                Description = "Configure the scoring and energy systems.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "X-Axis Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.xScoreMultiplier,
                        ValueChanged = val => stageProperties.xScoreMultiplier = val,
                        Min = 0,
                        Max = 100,
                        Step = 1,
                        Details = "Multiplier for the score gained when moving along the X-axis."
                    },
                    new Setting
                    {
                        Name = "Y-Axis Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.yScoreMultiplier,
                        ValueChanged = val => stageProperties.yScoreMultiplier = val,
                        Min = 0,
                        Max = 100,
                        Step = 1,
                        Details = "Multiplier for the score gained when moving along the Y-axis."
                    },
                    new Setting
                    {
                        Name = "Movement Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.movementScoreMultiplier,
                        ValueChanged = val => stageProperties.movementScoreMultiplier = val,
                        Min = 0,
                        Max = 100,
                        Step = 1,
                        Details = "Multiplier for the score based on agent's movement."
                    },
                    new Setting
                    {
                        Name = "Exploration Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.explorationScoreMultiplier,
                        ValueChanged = val => stageProperties.explorationScoreMultiplier = val,
                        Min = 0,
                        Max = 100,
                        Step = 1,
                        Details = "Multiplier for the score based on agent's exploration."
                    },
                    new Setting
                    {
                        Name = "Size Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.sizeScoreMultiplier,
                        ValueChanged = val => stageProperties.sizeScoreMultiplier = val,
                        Min = 0,
                        Max = 100,
                        Step = 1,
                        Details = "Multiplier for the score based on agent's size."
                    },
                    new Setting
                    {
                        Name = "Dynamic Mass Bonus",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.massBonusIsDynamic,
                        BooleanValueChanged = val => stageProperties.massBonusIsDynamic = val,
                        Details = "Toggles dynamic mass bonus for scoring."
                    },
                    new Setting
                    {
                        Name = "Starting Energy Base",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.startingEnergyBase,
                        ValueChanged = val => stageProperties.startingEnergyBase = val,
                        Min = 0,
                        Max = 100,
                        Step = 1,
                        Details = "Base energy level for agents at the start."
                    },
                    new Setting
                    {
                        Name = "Starting Energy Mass Power",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.startingEnergyMassPower,
                        ValueChanged = val => stageProperties.startingEnergyMassPower = val,
                        Min = 0,
                        Max = 10,
                        Step = 1,
                        Details = "Determines how agent mass affects starting energy."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Starting Energy Body Mass Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.startingEnergyBodyMassMult,
                        ValueChanged = val => stageProperties.startingEnergyBodyMassMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for starting energy based on body mass."
                    },
                    new Setting
                    {
                        Name = "Starting Energy Limb Mass Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.startingEnergyLimbMassMult,
                        ValueChanged = val => stageProperties.startingEnergyLimbMassMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for starting energy based on limb mass."
                    },
                    new Setting
                    {
                        Name = "Energy Use Force Size Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.energyUseForceSizeMult,
                        ValueChanged = val => stageProperties.energyUseForceSizeMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for energy use based on force size."
                    },
                    new Setting
                    {
                        Name = "Energy Use Force Size Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.energyUseLimbSizeMult,
                        ValueChanged = val => stageProperties.energyUseLimbSizeMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for energy use based on force size."
                    },
                    new Setting
                    {
                        Name = "Energy Use Force Size Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.energyUseBrainSizeMult,
                        ValueChanged = val => stageProperties.energyUseBrainSizeMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for energy use based on force size."
                    },
                    new Setting
                    {
                        Name = "Limb Mass Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbMassEnergyReductionDivider,
                        ValueChanged = val => stageProperties.limbMassEnergyReductionDivider = val,
                        Min = 10,
                        Max = 50,
                        Step = 5,
                        Details = "Divider for energy reduction based on limb mass."
                    },
                    new Setting
                    {
                        Name = "Limb Mass Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbMassEnergyReductionDivider,
                        ValueChanged = val => stageProperties.limbMassEnergyReductionDivider = val,
                        Min = 10,
                        Max = 50,
                        Step = 5,
                        Details = "Divider for energy reduction based on limb mass."
                    },
                    new Setting
                    {
                        Name = "Brain Size Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.brainSizeEnergyReductionDivider,
                        ValueChanged = val => stageProperties.brainSizeEnergyReductionDivider = val,
                        Min = 50,
                        Max = 150,
                        Step = 10,
                        Details = "Divider for energy reduction based on brain size."
                    },
                    new Setting
                    {
                        Name = "Force Magnitude Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.forceMagnitudeEnergyReductionDivider,
                        ValueChanged = val => stageProperties.forceMagnitudeEnergyReductionDivider = val,
                        Min = 500000,
                        Max = 1500000,
                        Step = 100000,
                        Details = "Divider for energy reduction based on force magnitude."
                    },
                    new Setting
                    {
                        Name = "Body Starting Mass Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.bodyStartingMassEnergyReductionDivider,
                        ValueChanged = val => stageProperties.bodyStartingMassEnergyReductionDivider = val,
                        Min = 200,
                        Max = 600,
                        Step = 50,
                        Details = "Divider for energy reduction based on body starting mass."
                    },
                    new Setting
                    {
                        Name = "Limb Starting Mass Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbStartingMassEnergyReductionDivider,
                        ValueChanged = val => stageProperties.limbStartingMassEnergyReductionDivider = val,
                        Min = 10,
                        Max = 30,
                        Step = 5,
                        Details = "Divider for energy reduction based on limb starting mass."
                    },
                    new Setting
                    {
                        Name = "Joint Movement Reward Limb Mass Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.jointMovementRewardLimbMassDivider,
                        ValueChanged = val => stageProperties.jointMovementRewardLimbMassDivider = val,
                        Min = 50,
                        Max = 150,
                        Step = 10,
                        Details = "Divider for calculating joint movement reward based on limb mass."
                    },
                    new Setting
                    {
                        Name = "Internal Map Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.internalMapSize,
                        ValueChanged = val => stageProperties.internalMapSize = val,
                        Min = 100,
                        Max = 1000,
                        Step = 100,
                        Details = "Size of the internal map used in simulations."
                    },
                    new Setting
                    {
                        Name = "Internal Map Cell Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.internalMapCellSize,
                        ValueChanged = val => stageProperties.internalMapCellSize = val,
                        Min = 10,
                        Max = 100,
                        Step = 10,
                        Details = "Size of each cell in the internal map."
                    },
                    new Setting
                    {
                        Name = "Dynamic Mass Bonus Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.dynamicMassBonusDivider,
                        ValueChanged = val => stageProperties.dynamicMassBonusDivider = val,
                        Min = 100,
                        Max = 1000,
                        Step = 100,
                        Details = "Divider for dynamic mass bonus calculation."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "Training",
                Description = "Configure the training and evolution systems.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Offspring Mutation Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.offspringMutationRate,
                        ValueChanged = val => stageProperties.offspringMutationRate = val,
                        Min = 10,
                        Max = 500,
                        Step = 10,
                        Details = "Adjusts the mutation rate for offspring."
                    },
                    new Setting
                    {
                        Name = "Offspring Node Mutation Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.offspringNodeMutationRate,
                        ValueChanged = val => stageProperties.offspringNodeMutationRate = val,
                        Min = 10,
                        Max = 500,
                        Step = 10,
                        Details = "Adjusts the node mutation rate for offspring."
                    },
                    new Setting
                    {
                        Name = "Offspring Layer Mutation Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.offspringLayerMutationRate,
                        ValueChanged = val => stageProperties.offspringLayerMutationRate = val,
                        Min = 1,
                        Max = 100,
                        Step = 1,
                        Details = "Adjusts the layer mutation rate for offspring."
                    },
                    new Setting
                    {
                        Name = "Offspring Limb Mutation Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.offspringLimbMutationRate,
                        ValueChanged = val => stageProperties.offspringLimbMutationRate = val,
                        Min = 1,
                        Max = 500,
                        Step = 1,
                        Details = "Adjusts the limb mutation rate for offspring."
                    },
                    new Setting
                    {
                        Name = "Top Performer Number",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.topPerformerNumber,
                        ValueChanged = val => stageProperties.topPerformerNumber = val,
                        Min = 10,
                        Max = 50,
                        Step = 1,
                        Details = "Sets the number of top performers in the population."
                    },
                    new Setting
                    {
                        Name = "Migration Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.migrationRate,
                        ValueChanged = val => stageProperties.migrationRate = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the rate of migration in the population."
                    },
                    new Setting
                    {
                        Name = "Minimum Population Group Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.minPopGroupSize,
                        ValueChanged = val => stageProperties.minPopGroupSize = val,
                        Min = 5,
                        Max = 20,
                        Step = 1,
                        Details = "Sets the minimum size of a population group."
                    },
                    new Setting
                    {
                        Name = "Maximum Population Group Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxPopGroupSize,
                        ValueChanged = val => stageProperties.maxPopGroupSize = val,
                        Min = 20,
                        Max = 50,
                        Step = 1,
                        Details = "Sets the maximum size of a population group."
                    },
                    new Setting
                    {
                        Name = "Agents Require Stabilizing",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.agentsRequireStablising,
                        BooleanValueChanged = val => stageProperties.agentsRequireStablising = val,
                        Details = "Determines if agents require stabilization."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Tournament Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.tournamentSize,
                        ValueChanged = val => stageProperties.tournamentSize = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Sets the size of the tournament for selection."
                    },
                    new Setting
                    {
                        Name = "Linear Stability Threshold for Body",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.linearStabilityThresholdBody,
                        ValueChanged = val => stageProperties.linearStabilityThresholdBody = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the linear stability threshold for the agent's body."
                    },
                    new Setting
                    {
                        Name = "Angular Stability Threshold for Body",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.angularStabilityThresholdBody,
                        ValueChanged = val => stageProperties.angularStabilityThresholdBody = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the angular stability threshold for the agent's body."
                    },
                    new Setting
                    {
                        Name = "Angular Stability Threshold for Limb",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.angularStabilityThresholdLimb,
                        ValueChanged = val => stageProperties.angularStabilityThresholdLimb = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the angular stability threshold for the agent's limbs."
                    },
                    new Setting
                    {
                        Name = "Stability Frames",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.stabilityFrames,
                        ValueChanged = val => stageProperties.stabilityFrames = val,
                        Min = 10,
                        Max = 50,
                        Step = 1,
                        Details = "Sets the number of frames for checking stability."
                    },
                    new Setting
                    {
                        Name = "Stability Check Overwrite Frames",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.stabilityCheckOverwriteFrames,
                        ValueChanged = val => stageProperties.stabilityCheckOverwriteFrames = val,
                        Min = 100,
                        Max = 1000,
                        Step = 50,
                        Details = "Sets the number of frames for overwriting stability check."
                    },
                    new Setting
                    {
                        Name = "Chance to Include Top Performer in Mutation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.chanceToIncludeTopPerformerInMutation,
                        ValueChanged = val => stageProperties.chanceToIncludeTopPerformerInMutation = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "The probability of including top performers in mutation processes."
                    },
                    new Setting
                    {
                        Name = "Chance to Include Offspring in Mutation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.chanceToIncludeOffspringInMutation,
                        ValueChanged = val => stageProperties.chanceToIncludeOffspringInMutation = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "The probability of including offspring in mutation processes."
                    },
                    new Setting
                    {
                        Name = "Neuron Mutation Standard Deviation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.neuronMutationStandardDeviation,
                        ValueChanged = val => stageProperties.neuronMutationStandardDeviation = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "Standard deviation for neuron mutation."
                    },
                    new Setting
                    {
                        Name = "Body Plan Mutation Standard Deviation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.bodyPlanMutationStandardDeviation,
                        ValueChanged = val => stageProperties.bodyPlanMutationStandardDeviation = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "Standard deviation for body plan mutation."
                    },
                    new Setting
                    {
                        Name = "Max Position for Normalisation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxPosForNormalisation,
                        ValueChanged = val => stageProperties.maxPosForNormalisation = val,
                        Min = 1000,
                        Max = 10000,
                        Step = 500,
                        Details = "Maximum position value for normalisation."
                    },
                    new Setting
                    {
                        Name = "Max Velocity for Normalisation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxVelForNormalisation,
                        ValueChanged = val => stageProperties.maxVelForNormalisation = val,
                        Min = 10,
                        Max = 100,
                        Step = 5,
                        Details = "Maximum velocity value for normalisation."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "World",
                Description = "Configure the properties of the world.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "timeIncrease",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.timeIncrease,
                        BooleanValueChanged = val => stageProperties.timeIncrease = val,
                        Details = "Toggles the display of agent names."
                    },
                    new Setting
                    {
                        Name = "agentInCentre",
                        Type = SettingType.Dropdown,
                        SelectedValueExpression = () => stageProperties.agentInCentre,
                        SelectedValueChanged = val => stageProperties.agentInCentre = val,
                        Options = new List<string> { "leader", "trailer", "average" },
                        Details = "Selects the type of environment for the simulation."
                    },
                    new Setting
                    {
                        Name = "Liquid Viscosity",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.liquidViscosity,
                        ValueChanged = val => stageProperties.liquidViscosity = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Adjusts the viscosity of the liquid in the world."
                    },
                    new Setting
                    {
                        Name = "Map Type",
                        Type = SettingType.Dropdown,
                        SelectedValueExpression = () => stageProperties.map.ToString(),
                        SelectedValueChanged = val => stageProperties.map = int.Parse(val),
                        Options = new List<string> { "1", "2", "3" }, // Assuming map types are numbered
                        Details = "Selects the type of map for the simulation."
                    },
                    new Setting
                    {
                        Name = "Random Map",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.randomMap,
                        BooleanValueChanged = val => stageProperties.randomMap = val,
                        Details = "Toggles the use of a random map in the simulation."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    // public float Gravity { get; set; } = 1; // not implemented
                    // public double Friction { get; set; } = 0.4; // not implemented
                    new Setting
                    {
                        Name = "Simulation Length",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.SimulationLength,
                        ValueChanged = val => stageProperties.SimulationLength = val,
                        Min = 500,
                        Max = 5000,
                        Step = 50,
                        Details = "Adjusts the total length of the simulation in ticks."
                    },
                    new Setting
                    {
                        Name = "Simulation Width",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.Width,
                        ValueChanged = val => stageProperties.Width = val,
                        Min = 800,
                        Max = 2400,
                        Step = 50,
                        Details = "Sets the width of the simulation area."
                    },
                    new Setting
                    {
                        Name = "Simulation Height",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.Height,
                        ValueChanged = val => stageProperties.Height = val,
                        Min = 400,
                        Max = 1200,
                        Step = 50,
                        Details = "Sets the height of the simulation area."
                    },
                    new Setting
                    {
                        Name = "Ground Level",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.GroundY,
                        ValueChanged = val => stageProperties.GroundY = val,
                        Min = 500,
                        Max = 900,
                        Step = 10,
                        Details = "Adjusts the Y-coordinate of the ground level."
                    },
                    new Setting
                    {
                        Name = "Simulation Length Increase",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.simulationLengthIncrease,
                        ValueChanged = val => stageProperties.simulationLengthIncrease = val,
                        Min = 10,
                        Max = 100,
                        Step = 5,
                        Details = "Increases the simulation length incrementally per generation."
                    },
                    new Setting
                    {
                        Name = "Max Simulation Length",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxSimulationLength,
                        ValueChanged = val => stageProperties.maxSimulationLength = val,
                        Min = 10000,
                        Max = 100000,
                        Step = 1000,
                        Details = "Sets the maximum limit for the simulation length."
                    },
                    new Setting
                    {
                        Name = "Velocity Iterations",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.velocityIteration,
                        ValueChanged = val => stageProperties.velocityIteration = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the number of velocity calculations per simulation tick."
                    },
                    new Setting
                    {
                        Name = "Position Iterations",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.positionIteration,
                        ValueChanged = val => stageProperties.positionIteration = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the number of position calculations per simulation tick."
                    },
                    new Setting
                    {
                        Name = "Physics Granularity Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.physicsGranularityMultipliers,
                        ValueChanged = val => stageProperties.physicsGranularityMultipliers = val,
                        Min = 5,
                        Max = 20,
                        Step = 1,
                        Details = "Adjusts the granularity of physics calculations."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "Visualization",
                Description = "Configure the visualization and UI.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Background Red",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.backgroundRed,
                        ValueChanged = val => stageProperties.backgroundRed = val,
                        Min = 0,
                        Max = 255,
                        Step = 1,
                        Details = "Adjusts the red component of the background color."
                    },
                    new Setting
                    {
                        Name = "Background Green",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.backgroundGreen,
                        ValueChanged = val => stageProperties.backgroundGreen = val,
                        Min = 0,
                        Max = 255,
                        Step = 1,
                        Details = "Adjusts the green component of the background color."
                    },
                    new Setting
                    {
                        Name = "Background Blue",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.backgroundBlue,
                        ValueChanged = val => stageProperties.backgroundBlue = val,
                        Min = 0,
                        Max = 255,
                        Step = 1,
                        Details = "Adjusts the blue component of the background color."
                    },
                    new Setting
                    {
                        Name = "Background Particles",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.backgroundParticles,
                        ValueChanged = val => stageProperties.backgroundParticles = val,
                        Min = 0,
                        Max = 500,
                        Step = 10,
                        Details = "Controls the number of particles in the background."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Show Neural Network",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showNN,
                        BooleanValueChanged = val => stageProperties.showNN = val,
                        Details = "Toggles the visibility of the neural network representation."
                    },
                    new Setting
                    {
                        Name = "Show Rays",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showRays,
                        BooleanValueChanged = val => stageProperties.showRays = val,
                        Details = "Controls whether rays used for sensing the environment are displayed."
                    },
                    new Setting
                    {
                        Name = "UI Refresh Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.uiRefreshRate,
                        ValueChanged = val => stageProperties.uiRefreshRate = val,
                        Min = 100,
                        Max = 1000,
                        Step = 50,
                        Details = "Adjusts the refresh rate of the user interface."
                    },
                    new Setting
                    {
                        Name = "NN Layer Gap",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.renderedNNLayerGap,
                        ValueChanged = val => stageProperties.renderedNNLayerGap = val,
                        Min = 50,
                        Max = 200,
                        Step = 10,
                        Details = "Sets the gap between layers in the rendered neural network."
                    },
                    new Setting
                    {
                        Name = "NN Node Gap",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.renderedNNNodeGap,
                        ValueChanged = val => stageProperties.renderedNNNodeGap = val,
                        Min = 20,
                        Max = 100,
                        Step = 5,
                        Details = "Defines the spacing between nodes in each neural network layer."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "Debugging",
                Description = "Configure the debugging and diagnostics.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Show Force Vectors",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showForceVectors,
                        BooleanValueChanged = val => stageProperties.showForceVectors = val,
                        Details = "Enables or disables the display of force vectors on agents."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Visual Force Scale",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.visualForceScale,
                        ValueChanged = val => stageProperties.visualForceScale = val,
                        Min = 10,
                        Max = 100,
                        Step = 1,
                        Details = "Adjusts the scale of visual representation of forces."
                    },
                    new Setting
                    {
                        Name = "Max Force Length",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.visualMaxForceLength,
                        ValueChanged = val => stageProperties.visualMaxForceLength = val,
                        Min = 100,
                        Max = 500,
                        Step = 10,
                        Details = "Sets the maximum length for force vector visualization."
                    }
                },
                HasAdvanced = true
            },
        };
    }

    private void SetActiveTab(TabModel tab)
    {
        activeTab = tab;
    }

    private void ToggleAdvanced(TabModel tab)
    {
        tab.ShowAdvanced = !tab.ShowAdvanced;
    }

    private void ToggleFavourite(string settingName)
    {
        if (stageProperties.FavouriteSettings.Contains(settingName))
        {
            stageProperties.FavouriteSettings.Remove(settingName);
        }
        else
        {
            stageProperties.FavouriteSettings.Add(settingName);
        }
    }

    public enum SettingType
    {
        Slider,
        Checkbox,
        Dropdown,
        Info
    }

    public class TabModel
    {
        public string Title { get; set; }
        public string Description { get; set; }
        public List<Setting> Settings { get; set; } = new List<Setting>();
        public List<Setting> AdvancedSettings { get; set; } = new List<Setting>();
        public bool HasAdvanced { get; set; }
        public bool ShowAdvanced { get; set; }
    }

    public class Setting
    {
        public string Name { get; set; }
        public SettingType Type { get; set; }
        public Func<int> ValueExpression { get; set; }
        public Action<int> ValueChanged { get; set; }
        public Func<bool> BooleanValueExpression { get; set; }
        public Action<bool> BooleanValueChanged { get; set; }
        public Func<string> SelectedValueExpression { get; set; }
        public Action<string> SelectedValueChanged { get; set; }
        public int Min { get; set; }
        public int Max { get; set; }
        public int Step { get; set; }
        public string Details { get; set; }
        public List<string> Options { get; set; } = new List<string>();

        public int Value
        {
            get => ValueExpression?.Invoke() ?? 0;
            set => ValueChanged?.Invoke(value);
        }

        public bool BooleanValue
        {
            get => BooleanValueExpression.Invoke();
            set => BooleanValueChanged?.Invoke(value);
        }

        public string SelectedValue
        {
            get => SelectedValueExpression?.Invoke();
            set => SelectedValueChanged?.Invoke(value);
        }
    }


    private StageProperties stageProperties = new StageProperties();
    public bool box2dPhysics { get; set; } = true;
    private bool showAdvancedSettings = true;
    public List<Genome> population = new List<Genome>();
    public List<Genome> evolvedPopulation = new List<Genome>();

    public class StageProperties
    {
        public List<string> FavouriteSettings { get; set; } = new List<string> { "Number of Agents", "Agent Multiplier", "Minimum Limbs", "Maximum Limbs", "Minimum Neural Network Layers", "Maximum Neural Network Layers", "Starting Limb Chain Length", "Swim Strength", "Size Score Multiplier", "Offspring Mutation Rate", "Offspring Limb Mutation Rate", "Top Performer Number", "Migration Rate", "Maximum Population Group Size", "Liquid Viscosity", "Simulation Length" };
        
        // Performance
        public int numAgents { get; set; } = 25;
        public int totalNumAgentsMultiplier { get; set; } = 8;
        public int muscleDelay { get; set; } = 2;
        public int muscleBatch { get; set; } = 5;
        public int simSpeed { get; set; } = 60;
        // Advanced Performance
        public int totalMuscleUpdateTime { get; set; } = 2;
        public int delay { get; set; } = 20;
        public int BatchSize { get; set; } = 10;
        public int updatesPerAgentStart { get; set; } = 1;
        public int framesPerUpdateStart { get; set; } = 1;
        public int renderedAgents { get; set; } = 1;
        public bool showGroupLeaders { get; set; } = true;
        public bool showGroupTrailers { get; set; } = true;
        public int agentStartSpawnGap { get; set; } = 5000;

        // Agent
        public int minLimbs { get; set; } = 2;
        public int maxLimbs { get; set; } = 5;
        public int minNNLayers { get; set; } = 1;
        public int maxNNLayers { get; set; } = 5;
        public int startingLimbChainLength { get; set; } = 1;
        public int swimStrength { get; set; } = 17;
        public int swimBias { get; set; } = 15; 
        public int maxJointSpeed { get; set; } = 10;
        // Advanced Agent
        public int maxTorqueMultiplier { get; set; } = 300000;
        public int limbMassForceDivider { get; set; } = 50;
        public int limbLengthForceDivider { get; set; } = 30;
        public int agentStartX { get; set; } = 200;
        public int agentStartY { get; set; } = 600;
        public int swimForceOverNFrames { get; set; } = 5;
        public int speedForceNormilizer { get; set; } = 15;
        public int speedNormalizationForDrag { get; set; } = 2500;
        public int bodyAngularDragPower { get; set; } = 10;
        public int maxTorqueForDamping { get; set; } = 10000;
        public int threasholdAngleForDamping { get; set; } = 10;
        public bool inputJointAngle { get; set; } = true;
        public bool inputJointSpeed { get; set; } = false;
        public bool inputAgentPos { get; set; } = true;
        public bool inputAgentV { get; set; } = true;
        public bool inputScore { get; set; } = false;
        public bool inputOrientation { get; set; } = true;
        public bool inputTimeRemaining { get; set; } = true;
        public bool inputDistanceSensors { get; set; } = true;
        public bool outputsJointSpeed { get; set; } = true;
        public bool outputsJointTorque { get; set; } = false;
        public bool outputsBias { get; set; } = false;
        public bool brainDecayOverTime { get; set; } = false; // Not implemented

        // Score and Energy
        public int xScoreMultiplier { get; set; } = 30;
        public int yScoreMultiplier { get; set; } = 30;
        public int movementScoreMultiplier { get; set; } = 30;
        public int explorationScoreMultiplier { get; set; } = 50;
        public int sizeScoreMultiplier { get; set; } = 20;
        public bool massBonusIsDynamic { get; set; } = true;
        public int startingEnergyBase { get; set; } = 10;
        public int startingEnergyMassPower { get; set; } = 3;
        // Advanced Score and Energy
        public int startingEnergyBodyMassMult { get; set; } = 10;
        public int startingEnergyLimbMassMult { get; set; } = 10;
        public int energyUseForceSizeMult { get; set; } = 10;
        public int energyUseLimbSizeMult { get; set; } = 10;
        public int energyUseBrainSizeMult { get; set; } = 10;
        public int limbMassEnergyReductionDivider { get; set; } = 15;
        public int brainSizeEnergyReductionDivider { get; set; } = 100;
        public int forceMagnitudeEnergyReductionDivider { get; set; } = 1000000;
        public int bodyStartingMassEnergyReductionDivider { get; set; } = 400;
        public int limbStartingMassEnergyReductionDivider { get; set; } = 15;
        public int jointMovementRewardLimbMassDivider { get; set; } = 100;
        public int internalMapSize { get; set; } = 500;
        public int internalMapCellSize { get; set; } = 50;
        public int dynamicMassBonusDivider { get; set; } = 500;

        // Training and Evolution
        public int offspringMutationRate { get; set; } = 200;
        public int offspringNodeMutationRate { get; set; } = 50;
        public int offspringLayerMutationRate { get; set; } = 10;
        public int offspringLimbMutationRate { get; set; } = 100;
        public int topPerformerNumber { get; set; } = 20;
        public int migrationRate { get; set; } = 2;
        public int minPopGroupSize { get; set; } = 10;
        public int maxPopGroupSize { get; set; } = 25;
        public bool agentsRequireStablising { get; set; } = false;
        // Advanced Training and Evolution
        public int tournamentSize { get; set; } = 10;
        public int linearStabilityThresholdBody { get; set; } = 15;
        public int angularStabilityThresholdBody { get; set; } = 20;
        public int angularStabilityThresholdLimb { get; set; } = 15;
        public int stabilityFrames { get; set; } = 20;
        public int stabilityCheckOverwriteFrames { get; set; } = 500;
        public int chanceToIncludeTopPerformerInMutation { get; set; } = 10;
        public int chanceToIncludeOffspringInMutation { get; set; } = 50;
        public int neuronMutationStandardDeviation { get; set; } = 10;
        public int bodyPlanMutationStandardDeviation { get; set; } = 10;
        public int maxPosForNormalisation { get; set; } = 5000;
        public int maxVelForNormalisation { get; set; } = 50;

        // World Properties
        public int liquidViscosity { get; set; } = 5;
        public bool timeIncrease { get; set; } = true;
        public int map { get; set; } = 1;
        public bool randomMap { get; set; } = true;
        public int SimulationLength { get; set; } = 2000;
        // Advanced World Properties
        public int Width { get; set; } = 1600;
        public int Height { get; set; } = 800;
        public int GroundY { get; set; } = 700;
        public int Gravity { get; set; } = 1; // not implemented
        public double Friction { get; set; } = 0.4; // not implemented
        public int simulationLengthIncrease { get; set; } = 25;
        public int maxSimulationLength { get; set; } = 50000;
        public int velocityIteration { get; set; } = 4;
        public int positionIteration { get; set; } = 2;
        public int physicsGranularityMultipliers { get; set; } = 10;

        // Visualization and UI
        public int backgroundRed { get; set; } = 0;
        public int backgroundGreen { get; set; } = 0;
        public int backgroundBlue { get; set; } = 128;
        public int backgroundParticles { get; set; } = 100;
        // Advanced Visualization and UI
        public bool showNN { get; set; } = false;
        public bool showRays { get; set; } = true;
        public string agentInCentre { get; set; } = "leader";
        public int uiRefreshRate { get; set; } = 500;
        public int renderedNNLayerGap { get; set; } = 100;
        public int renderedNNNodeGap { get; set; } = 30;

        // Debugging and Diagnostics
        public bool showForceVectors { get; set; } = true;
        // Advanced Debugging and Diagnostics
        public int visualForceScale { get; set; } = 20;
        public int visualMaxForceLength { get; set; } = 300;

        // Behind the scenes
        public double topScoreEver { get; set; } = 0;
        public int genCount { get; set; } = 1;

    }

    private async Task setMobilePresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 5;
        stageProperties.numAgents = 5;
        stageProperties.totalNumAgentsMultiplier = 20;
        stageProperties.muscleDelay = 5;
        stageProperties.muscleBatch = 1;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task setLowPresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 10;
        stageProperties.numAgents = 20;
        stageProperties.totalNumAgentsMultiplier = 10;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 5;
        stageProperties.totalMuscleUpdateTime = 2;
    }

    private async Task setMidPresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 20;
        stageProperties.numAgents = 50;
        stageProperties.totalNumAgentsMultiplier = 5;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 10;
        stageProperties.totalMuscleUpdateTime = 2;
    }

    private async Task setHighPresets()
    {
        stageProperties.delay = 5;
        stageProperties.BatchSize = 20;
        stageProperties.numAgents = 100;
        stageProperties.totalNumAgentsMultiplier = 4;
        stageProperties.muscleDelay = 1;
        stageProperties.muscleBatch = 10;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task setVHighPresets()
    {
        stageProperties.delay = 1;
        stageProperties.BatchSize = 20;
        stageProperties.numAgents = 150;
        stageProperties.totalNumAgentsMultiplier = 3;
        stageProperties.muscleDelay = 1;
        stageProperties.muscleBatch = 15;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task resetSettings()
    {
        stageProperties.Width = 1600;  // Canvas width
        stageProperties.Height = 800;  // Canvas height
        stageProperties.GroundY = 700;  // Y position of the ground in the canvas
        stageProperties.Gravity = 1;
        stageProperties.Friction = 0.4;
        stageProperties.SimulationLength = 2000;
        stageProperties.renderedAgents = 1;
        stageProperties.simSpeed = 60;
        stageProperties.topPerformerNumber = 5;
        stageProperties.delay = 20;
        stageProperties.BatchSize = 10;
        stageProperties.showNN = false;
        stageProperties.showRays = true;
        stageProperties.agentInCentre = "leader";
        stageProperties.numAgents = 25;
        stageProperties.totalNumAgentsMultiplier = 8;
        stageProperties.tournamentSize = 10;
        stageProperties.migrationRate = 2;
        stageProperties.minPopGroupSize = 10;
        stageProperties.maxPopGroupSize = 25;
        stageProperties.uiRefreshRate = 500;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 5;
        stageProperties.totalMuscleUpdateTime = 2;
        stageProperties.velocityIteration = 4;
        stageProperties.positionIteration = 2;
        stageProperties.physicsGranularityMultipliers = 10;
        stageProperties.liquidViscosity = 5;
        stageProperties.timeIncrease = true;
        stageProperties.map = 1;
        stageProperties.randomMap = true;
        stageProperties.simulationLengthIncrease = 25;
        stageProperties.maxSimulationLength = 50000;
        stageProperties.agentsRequireStablising = true;
        stageProperties.maxJointSpeed = 10;
        stageProperties.offspringMutationRate = 200;
        stageProperties.offspringNodeMutationRate = 10;
        stageProperties.offspringLayerMutationRate = 5;
        stageProperties.offspringLimbMutationRate = 50;
        stageProperties.brainDecayOverTime = false;
        stageProperties.inputJointAngle = true;
        stageProperties.inputJointSpeed = false;
        stageProperties.inputAgentPos = true;
        stageProperties.inputAgentV = true;
        stageProperties.inputScore = false;
        stageProperties.inputOrientation = true;
        stageProperties.inputTimeRemaining = true;
        stageProperties.inputDistanceSensors = true;
        stageProperties.outputsJointSpeed = true;
        stageProperties.outputsJointTorque = false;
        stageProperties.outputsBias = false;
        stageProperties.swimStrength = 600000;
        stageProperties.swimBias = 15;
        stageProperties.xScoreMultiplier = 30;
        stageProperties.yScoreMultiplier = 30;
        stageProperties.movementScoreMultiplier = 3;
        stageProperties.explorationScoreMultiplier = 50;
        stageProperties.sizeScoreMultiplier = 20;
        stageProperties.startingEnergyBase = 100;
        stageProperties.startingEnergyMassPower = 3;
        stageProperties.startingEnergyBodyMassMult = 10;
        stageProperties.startingEnergyLimbMassMult = 10;
        stageProperties.energyUseForceSizeMult = 10;
        stageProperties.energyUseLimbSizeMult = 10;
        stageProperties.energyUseBrainSizeMult = 10;
        stageProperties.maxTorqueMultiplier = 300000;
        stageProperties.updatesPerAgentStart = 1;
        stageProperties.framesPerUpdateStart = 10;
        stageProperties.topScoreEver = 0;
        stageProperties.genCount = 1;
        stageProperties.backgroundRed = 0;
        stageProperties.backgroundGreen = 0;
        stageProperties.backgroundBlue = 128;
        stageProperties.backgroundParticles = 100;
        stageProperties.linearStabilityThresholdBody = 10;
        stageProperties.angularStabilityThresholdBody = 15;
        stageProperties.angularStabilityThresholdLimb = 10;
        stageProperties.stabilityFrames = 10;
        stageProperties.swimForceOverNFrames = 5;
        stageProperties.limbMassForceDivider = 50;
        stageProperties.limbLengthForceDivider = 30;
        stageProperties.limbMassEnergyReductionDivider = 15;
        stageProperties.brainSizeEnergyReductionDivider = 100;
        stageProperties.forceMagnitudeEnergyReductionDivider = 1000000;
        stageProperties.maxTorqueForDamping = 10000;
        stageProperties.threasholdAngleForDamping = 10;
        stageProperties.bodyStartingMassEnergyReductionDivider = 400;
        stageProperties.limbStartingMassEnergyReductionDivider = 15;
        stageProperties.jointMovementRewardLimbMassDivider = 100;
        stageProperties.internalMapSize = 500;
        stageProperties.internalMapCellSize = 50;
        stageProperties.massBonusIsDynamic = true;
        stageProperties.dynamicMassBonusDivider = 500;
        stageProperties.showGroupLeaders = true;
        stageProperties.showGroupTrailers = true;
        stageProperties.agentStartX = 200;
        stageProperties.agentStartY = 600;
        stageProperties.agentStartSpawnGap = 5000;
        stageProperties.chanceToIncludeTopPerformerInMutation = 10;
        stageProperties.chanceToIncludeOffspringInMutation = 80;
        stageProperties.neuronMutationStandardDeviation = 10;
        stageProperties.bodyPlanMutationStandardDeviation = 10;
        stageProperties.renderedNNLayerGap = 100;
        stageProperties.renderedNNNodeGap = 30;
        stageProperties.maxPosForNormalisation = 5000;
        stageProperties.maxVelForNormalisation = 500;
        stageProperties.minLimbs = 2;
        stageProperties.maxLimbs = 5;
        stageProperties.minNNLayers = 1;
        stageProperties.maxNNLayers = 5;
        stageProperties.startingLimbChainLength = 1;

    }

    private async Task saveSettings()
    {
        await JSRuntime.InvokeVoidAsync("saveSettings", stageProperties);
    }

    private async Task uploadSettings()
    {
        stageProperties = await JSRuntime.InvokeAsync<StageProperties>("uploadSettings");
    }

    private async Task ResetSimulation()
    {
        await InitializePopulation(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task ResetSimulationSimple()
    {
        stageProperties.energyUseForceSizeMult = 0;
        stageProperties.energyUseLimbSizeMult = 0;
        stageProperties.energyUseBrainSizeMult = 0;
        stageProperties.startingEnergyMassPower = 0;
        stageProperties.startingEnergyBase = 1;
        stageProperties.startingEnergyBodyMassMult = 0;
        stageProperties.startingEnergyLimbMassMult = 0;
        stageProperties.movementScoreMultiplier = 1;
        stageProperties.explorationScoreMultiplier = 0;
        stageProperties.sizeScoreMultiplier = 0;
        stageProperties.offspringLayerMutationRate = 0;
        stageProperties.offspringLimbMutationRate = 50;
        stageProperties.agentsRequireStablising = false;
        await InitializePopulation(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task ResetSimulationSuperSimple()
    {
        stageProperties.energyUseForceSizeMult = 0;
        stageProperties.energyUseLimbSizeMult = 0;
        stageProperties.energyUseBrainSizeMult = 0;
        stageProperties.startingEnergyMassPower = 0;
        stageProperties.startingEnergyBase = 1;
        stageProperties.startingEnergyBodyMassMult = 0;
        stageProperties.startingEnergyLimbMassMult = 0;
        stageProperties.movementScoreMultiplier = 1;
        stageProperties.explorationScoreMultiplier = 0;
        stageProperties.sizeScoreMultiplier = 0;
        stageProperties.offspringNodeMutationRate = 0;
        stageProperties.offspringLayerMutationRate = 0;
        stageProperties.offspringLimbMutationRate = 50;
        stageProperties.swimStrength = 17;
        stageProperties.randomMap = false;
        stageProperties.map = 1;
        stageProperties.agentsRequireStablising = false;
        await InitializePopulationSimple(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task toggleNN()
    {
        stageProperties.showNN = !stageProperties.showNN;
        await UpdateSimulation();
    }

    private async Task toggleRayCasts()
    {
        stageProperties.showRays = !stageProperties.showRays;
        await UpdateSimulation();
    }

    private void ToggleAdvancedSettings()
    {
        showAdvancedSettings = !showAdvancedSettings;
    }

    private async Task UpdateSimulation()
    {
        await JSRuntime.InvokeVoidAsync("updateSimulationNEAT", stageProperties);
    }

    private async Task toggleLeader()
    {
        if (stageProperties.agentInCentre == "leader")
        {
            stageProperties.agentInCentre = "trailer";
        }
        else
        {
            stageProperties.agentInCentre = "leader";
        }

        await UpdateSimulation();
    }

    private async Task LogGenomes()
    {
        await JSRuntime.InvokeVoidAsync("logGenomes");
    }

    public override string ToString()
    {
        return JsonSerializer.Serialize(this);
    }

    private async Task RetrieveGenomes()
    {
        await JSRuntime.InvokeAsync<string>("saveGenomes");
    }

    private async Task UploadGenomes()
    {
        stageProperties = await JSRuntime.InvokeAsync<StageProperties>("uploadGenomes");
    }

    public async Task Skip10Gen()
    {
        await JSRuntime.InvokeVoidAsync("skipGen", 10);
    }

    public async Task Skip100Gen()
    {
        await JSRuntime.InvokeVoidAsync("skipGen", 1);
    }

    void Shuffle<T>(List<T> list, Random random)
    {
        int n = list.Count;
        while (n > 1)
        {
            n--;
            int k = random.Next(n + 1);
            T value = list[k];
            list[k] = list[n];
            list[n] = value;
        }
    }

    public async Task InitializePopulation(int populationSize)
    {
        population = new List<Genome>();
        Random random = new Random();
        //let agentsPerGroup = Math.ceil(totalPopulationGenomes.length / numGroups);
        // For now, set manual total population size as 10 * numAgents
        int totalPopulation = populationSize * stageProperties.totalNumAgentsMultiplier;
        // Calculate the number of groups
        int numGroups = Math.Max(1, (int)Math.Ceiling((double)totalPopulation / stageProperties.maxPopGroupSize));
        List<int> runGroups = Enumerable.Range(0, stageProperties.totalNumAgentsMultiplier)
                                         .SelectMany(x => Enumerable.Repeat(x, totalPopulation / stageProperties.totalNumAgentsMultiplier))
                                         .ToList();

        // If the total population isn't perfectly divisible by stageProperties.totalNumAgentsMultiplier,
        // add extra run groups to fill up the list
        while (runGroups.Count < totalPopulation)
        {
            runGroups.Add(new Random().Next(0, stageProperties.totalNumAgentsMultiplier));
        }

        // Shuffle the list
        runGroups = runGroups.OrderBy(x => Guid.NewGuid()).ToList();

        for (int i = 0; i < totalPopulation; i++)
        {
            Genome genome = new Genome();
            genome.Metadata.AgentIndex = i;

            int numLimbs = random.Next(stageProperties.minLimbs, stageProperties.maxLimbs);

            // Initialize genes, examples used for now, will be randomized once the constructor is complete
            genome.InputLayerGenes.Add(InitializeInputLayer(numLimbs * stageProperties.startingLimbChainLength));

            int numLayers = random.Next(stageProperties.minNNLayers, stageProperties.maxNNLayers);

            // assuming you want to add 3 layers, and the layer numbers are between 1 and 3, and sizes between 10 and 20
            for (int j = 0; j < numLayers; j++)
            {
                int randomSize = random.Next(3, 20); // Generates a random integer between 3 and 20
                genome.LayerGenes.Add(InitializeLayer(j, randomSize));
            }

            genome.OutputLayerGenes.Add(InitializeOutputLayer(numLimbs * stageProperties.startingLimbChainLength));
            genome.MainBody = InitializeBodyPlan(numLimbs);
            // initialize genome.Metadata.AgentName as random string in the format cvccvc (consonant vowel consonant consonant vowel consonant)
            var randomName = new Random();
            var consonants = "bcdfghjklmnpqrstvwxyz";
            var vowels = "aeiou";
            var agentName = $"{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}";
            genome.Metadata.AgentName = agentName;
            genome.Metadata.RunGroup = runGroups[i];
            genome.Metadata.AgentGroup = i % numGroups;
            genome.Hyperparameters.MutationRate = stageProperties.offspringMutationRate / 1000;
            genome.Hyperparameters.NodeMutationRate = stageProperties.offspringNodeMutationRate / 1000;
            genome.Hyperparameters.LayerMutationRate = stageProperties.offspringLayerMutationRate / 1000;
            genome.Hyperparameters.LimbMutationRate = stageProperties.offspringLimbMutationRate / 1000;

            // add ids to usedLayerIDs, 1 to numLayers
            genome.UsedLayerIDs = Enumerable.Range(1, numLayers).ToList();

            population.Add(genome);
        }
    }

    public async Task InitializePopulationSimple(int populationSize)
    {
        population = new List<Genome>();
        Random random = new Random();
        //let agentsPerGroup = Math.ceil(totalPopulationGenomes.length / numGroups);
        // For now, set manual total population size as 10 * numAgents
        int totalPopulation = populationSize * stageProperties.totalNumAgentsMultiplier;
        // Calculate the number of groups
        int numGroups = Math.Max(1, (int)Math.Ceiling((double)totalPopulation / stageProperties.maxPopGroupSize));
        List<int> runGroups = Enumerable.Range(0, stageProperties.totalNumAgentsMultiplier)
                                         .SelectMany(x => Enumerable.Repeat(x, totalPopulation / stageProperties.totalNumAgentsMultiplier))
                                         .ToList();

        // If the total population isn't perfectly divisible by stageProperties.totalNumAgentsMultiplier,
        // add extra run groups to fill up the list
        while (runGroups.Count < totalPopulation)
        {
            runGroups.Add(new Random().Next(0, stageProperties.totalNumAgentsMultiplier));
        }

        // Shuffle the list
        runGroups = runGroups.OrderBy(x => Guid.NewGuid()).ToList();

        for (int i = 0; i < totalPopulation; i++)
        {
            Genome genome = new Genome();
            genome.Metadata.AgentIndex = i;

            int numLimbs = 3;

            genome.InputLayerGenes.Add(InitializeInputLayer(numLimbs * stageProperties.startingLimbChainLength));

            int numLayers = 3;

            genome.LayerGenes.Add(InitializeLayer(0, 18));
            genome.LayerGenes.Add(InitializeLayer(1, 10));

            genome.OutputLayerGenes.Add(InitializeOutputLayer(numLimbs * stageProperties.startingLimbChainLength));
            genome.MainBody = InitializeBodyPlanSimple(numLimbs);
            // initialize genome.Metadata.AgentName as random string in the format cvccvc (consonant vowel consonant consonant vowel consonant)
            var randomName = new Random();
            var consonants = "bcdfghjklmnpqrstvwxyz";
            var vowels = "aeiou";
            var agentName = $"{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}";
            genome.Metadata.AgentName = agentName;
            genome.Metadata.RunGroup = runGroups[i];
            genome.Metadata.AgentGroup = i % numGroups;
            genome.Hyperparameters.MutationRate = stageProperties.offspringMutationRate / 1000;
            genome.Hyperparameters.NodeMutationRate = stageProperties.offspringNodeMutationRate / 1000;
            genome.Hyperparameters.LayerMutationRate = stageProperties.offspringLayerMutationRate / 1000;
            genome.Hyperparameters.LimbMutationRate = stageProperties.offspringLimbMutationRate / 1000;

            // add ids to usedLayerIDs, 1 to numLayers
            genome.UsedLayerIDs = Enumerable.Range(1, numLayers).ToList();

            population.Add(genome);
        }
    }

    public async Task UploadExistingPopulation()
    {
        //foreach (Genome in UploadedGenomes)
        //{
        //    Genome genome = new Genome();
        //    genome.Metadata.AgentIndex = i;

        //    // Initialize genes, examples used for now, will be randomised once the constructor is complete
        //    genome.InputLayerGenes.Add();
        //    genome.LayerGenes.Add(); // First hidden layer with 10 neurons
        //    genome.LayerGenes.Add();  // Second hidden layer with 5 neurons
        //    genome.OutputLayerGenes.Add();
        //    genome.BodyPlan = ;

        //    // Further initialization

        //    population.Add(genome);
        //}
    }

    private InputLayerGene InitializeInputLayer(int numLimbs)
    {
        return new InputLayerGene
            {
                NumberOfNeurons = 10 + numLimbs, 
                ActivationType = ActivationType.ReLU,
                Inputs = Enumerable.Range(1, 10 + numLimbs).ToList()
            };
    }

    private LayerGene InitializeLayer(int layerId, int numberOfNeurons)
    {
        return new LayerGene
            {
                LayerID = layerId,
                LayerType = LayerType.Dense,
                NumberOfNeurons = numberOfNeurons,
                ActivationType = ActivationType.ReLU
            };
    }

    private OutputLayerGene InitializeOutputLayer(int numLimbs)
    {
        return new OutputLayerGene
            {
                NumberOfNeurons = numLimbs, // 3 outputs
                ActivationType = ActivationType.Tanh,
                Outputs = Enumerable.Range(1, numLimbs).ToList() // List of outputs from 1 to 3
            };
    }

    private MainBody InitializeBodyPlan(int numLimbs)
    {
        Random random = new Random();

        MainBody mainBody = new MainBody
            {
                PartID = 0,
                NumberInChain = 0,
                Shape = "Circle",
                Size = 10 + random.NextDouble() * 30.0,
                Density = 0.1 + random.NextDouble() * 0.6,
                Arms = new List<Arm>() // Initializing the Limbs list
            };

        for (int i = 1; i <= numLimbs; i++)
        {
            double angle = random.NextDouble() * 2 * Math.PI; // Random angle in radians

            int id = i;

            Arm arm = new Arm
                {
                    PartID = id,
                    ParentPartID = 0,
                    NumberInChain = 1,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            Arm subArm = new Arm
                {
                    PartID = id + numLimbs,
                    ParentPartID = id,
                    NumberInChain = 2,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = random.NextDouble() * 2 * Math.PI,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            Arm subArm2 = new Arm
                {
                    PartID = id + numLimbs * 2,
                    ParentPartID = subArm.PartID,
                    NumberInChain = 3,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = random.NextDouble() * 2 * Math.PI,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            if (stageProperties.startingLimbChainLength > 1)
            {
                arm.SubArms.Add(subArm);
                if (stageProperties.startingLimbChainLength > 2)
                {
                    subArm.SubArms.Add(subArm2);
                }
            }

            mainBody.Arms.Add(arm);
        }

        return mainBody;
    }


    private MainBody InitializeBodyPlanSimple(int numLimbs)
    {
        Random random = new Random();

        MainBody mainBody = new MainBody
            {
                PartID = 0,
                NumberInChain = 0,
                Shape = "Circle",
                Size = 25,
                Density = 0.3,
                Arms = new List<Arm>() // Initializing the Limbs list
            };

        for (int i = 1; i <= numLimbs; i++)
        {
            double angle = ((i - 1) * 2 * Math.PI) / numLimbs;

            // reserve ids 0 to 10 for body segments
            int id = i + 10;

            Arm arm = new Arm
                {
                    PartID = id,
                    ParentPartID = 0,
                    NumberInChain = 1,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 50.0,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            Arm subArm = new Arm
                {
                    PartID = id + numLimbs,
                    ParentPartID = id,
                    NumberInChain = 2,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 40,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            Arm subArm2 = new Arm
                {
                    PartID = id + numLimbs * 2,
                    ParentPartID = subArm.PartID,
                    NumberInChain = 3,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 40,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            if (stageProperties.startingLimbChainLength > 1)
            {
                arm.SubArms.Add(subArm);
                if (stageProperties.startingLimbChainLength > 2)
                {
                    subArm.SubArms.Add(subArm2);
                }
            }

            mainBody.Arms.Add(arm);
        }

        return mainBody;
    }

    public class Genome
    {
        public List<InputLayerGene> InputLayerGenes { get; set; }
        public List<LayerGene> LayerGenes { get; set; }
        public List<OutputLayerGene> OutputLayerGenes { get; set; }
        // public List<InnovationEntry> InnovationLog { get; set; }
        public MainBody MainBody { get; set; }
        public AgentHistory AgentHistory { get; set; }
        public Hyperparameters Hyperparameters { get; set; }
        public Metadata Metadata { get; set; }
        public List<int>? UsedBiasIDs { get; set; }
        public List<int>? UsedLayerIDs { get; set; }

        public Genome()
        {
            // Initialize properties with defaults or random values.
            this.InputLayerGenes = new List<InputLayerGene>();
            this.LayerGenes = new List<LayerGene>();
            this.OutputLayerGenes = new List<OutputLayerGene>();
            // this.InnovationLog = new List<InnovationEntry>();
            this.MainBody = new MainBody();
            this.AgentHistory = new AgentHistory();
            this.Hyperparameters = new Hyperparameters();
            this.Metadata = new Metadata();
        }
    }

    public class MainBody
    {
        public int PartID { get; set; }
        public int NumberInChain { get; set; }
        public string Shape { get; set; }
        public double Size { get; set; }
        public double Density { get; set; }
        public List<Arm> Arms { get; set; } = new List<Arm>();
        public List<Wing> Wings { get; set; } = new List<Wing>();
        public List<Thruster> Thrusters { get; set; } = new List<Thruster>();
        public List<BodySegment> BodySegments { get; set; } = new List<BodySegment>();
        public List<int> UsedLimbIDs { get; set; } = new List<int>();
    }

    public class BodySegment
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Size { get; set; }
        public double Density { get; set; }
        public JointConstraints? Constraints { get; set; }
        public AttachmentPoint Attachment { get; set; }
        public List<Arm> Arms { get; set; } = new List<Arm>();
        public List<Wing> Wings { get; set; } = new List<Wing>();
        public List<Thruster> Thrusters { get; set; } = new List<Thruster>();
    }

    public class Arm
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
        public List<Arm> SubArms { get; set; } = new List<Arm>(); 
        public List<Wing> SubWings { get; set; } = new List<Wing>(); 
        public List<Thruster> SubThrusters { get; set; } = new List<Thruster>(); 
    }

    public class Wing
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
    }

    public class Thruster
    {
        public double ThrustForce { get; set; }
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
    }

    public class AttachmentPoint
    {
        public double? X { get; set; }
        public double? Y { get; set; }
    }

    public class JointConstraints
    {
        public double? MaxTorque { get; set; }
        public double? MinAngle { get; set; }
        public double? MaxAngle { get; set; }
    }

    // Encode the agents history into the genome:

    public class AgentHistory
    {
        public bool RunThisGeneration { get; set; }
        public ScoreHistory? LastScore { get; set; }
        public List<ScoreHistory>? ScoreHistory { get; set; }
        public int RoundsAsTopPerformer { get; set; }
        public int UsedAsParent { get; set; }
        public List<String>? Mutations { get; set; }
        public double RankInGroup { get; set; }
        public double RankInPop { get; set; }

        public AgentHistory()
        {
            this.LastScore = new ScoreHistory();
            this.RunThisGeneration = false;
            this.ScoreHistory = new List<ScoreHistory>();
            this.RoundsAsTopPerformer = 0;
            this.UsedAsParent = 0;
            this.Mutations = new List<String>();
        }
    }

    public class ScoreHistory
    {
        public float Score { get; set; }
        public int Map { get; set; }
        public int Generation { get; set; }
    }

    public class Hyperparameters
    {
        public double MutationRate { get; set; }
        public double NodeMutationRate { get; set; }
        public double LayerMutationRate { get; set; }
        public double LimbMutationRate { get; set; }
    }

    public class Metadata
    {
        public int RunGroup { get; set; }
        public int AgentGroup { get; set; }
        public string AgentName { get; set; }
        public int AgentIndex { get; set; }
        public string GroupName { get; set; }
        public string Species { get; set; }
        public double BestScore { get; set; }
        public int CompatabilityDistance { get; set; }

        public Metadata()
        {
            // Initialize with default values, or leave them null.  Should maybe have these as parameters in the call
            this.AgentName = "Unnamed"; // Set randomly on initialization, unique to an agent
            this.AgentIndex = 0; // Set randomly on initialization, unique to an agent
            this.GroupName = "DefaultGroup"; // set randomly on initialization, the same for all agents in a population
            this.Species = "Unspecified"; // set randomly on initialization, same for agents in the same spices.  might need to set this later after distinct spices groups form.
            this.BestScore = 0; // Set to 0 on initialization, updated after each round
            this.CompatabilityDistance = 0; // Set to 0 on initialization, updated after each round
        }
    }

    public class InputLayerGene
    {
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<Bias>? Biases { get; set; }
        public List<int>? Inputs { get; set; }

        public InputLayerGene()
        {
            this.Biases = new List<Bias>();
            this.Inputs = new List<int>();
        }
    }

    public class LayerGene
    {
        public int LayerID { get; set; }
        public LayerType LayerType { get; set; }  // "Dense", "Conv", "LSTM", etc.
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<List<Weight>>? Weights { get; set; }
        public List<Bias>? Biases { get; set; }

        public LayerGene()
        {
            this.Weights = new List<List<Weight>>();
            this.Biases = new List<Bias>();            
        }
    }

    public class OutputLayerGene
    {
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<List<Weight>>? Weights { get; set; }
        public List<Bias>? Biases { get; set; }
        public List<int>? Outputs { get; set; }

        public OutputLayerGene()
        {
            this.Weights = new List<List<Weight>>();
            this.Biases = new List<Bias>();
            this.Outputs = new List<int>();
        }
    }

    public class Weight
    {
        //public int ID { get; set; }
        public int FromNodeID { get; set; }
        public int ToNodeID { get; set; }
        public double? Value { get; set; }
    }

    public class Bias
    {
        public int ID { get; set; }
        public double? Value { get; set; }
    }

    public enum LayerType
    {
        Dense,
        Convolutional,
        LSTM,
        // ...other types
    }

    public enum ActivationType
    {
        ReLU,
        Sigmoid,
        Tanh,
        // ...other types
    }
}

