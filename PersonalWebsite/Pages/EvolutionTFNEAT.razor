@page "/EvolutionTFNEAT"
@inject IJSRuntime JSRuntime

<h2 class="pageTitle">Semi-NEAT Genetic Evolution Simulation</h2>

@* <p>My Implementation of the NEAT algorithm, adapted for TesnorFlow.JS</p>
<p>Like most of the site, this will work on mobile, but its not designed for it</p>
<p>The documentation below, and on the <a style="text-decoration: none" href="/Projects/all/all">Projects Page of the Wiki</a> will give an explanation of whats going on and how to get started</p>
 *@
<div id="canvas-container-NEAT"></div>

<div class="settings-preset-Buttons">
    @* <h4 class="presetsTitle">Presets</h4> *@
    <button class="preset-button mobile-button" title="Set mobile powered presets" @onclick="setMobilePresets">Mobile Power Settings Preset</button>
    <button class="preset-button low-button" title="Set low powered presets" @onclick="setLowPresets">Low Power Settings Preset</button>
    <button class="preset-button mid-button" title="Set medium powered presets" @onclick="setMidPresets">Medium Power Settings Preset</button>
    <button class="preset-button high-button" title="Set high powered presets" @onclick="setHighPresets">High Power Settings Preset</button>
    <button class="preset-button vHigh-button" title="Set very high powered presets" @onclick="setVHighPresets">Very High Power Settings Preset</button>
    <button class="preset-button reset-button" title="Resets settings to default everything" @onclick="resetSettings">Reset All Settings</button>
    <button class="preset-button save-button" title="Saves current settings to a JSON file" @onclick="saveSettings">Save Settings To File</button>
    <button class="preset-button upload-button" title="Uploaded saved settings JSON" @onclick="uploadSettings">Upload Settings File</button>
</div>

<div class="tabs">
    @foreach (var tab in tabs)
    {
        <button class="@(tab == activeTab ? "tab-button active" : "tab-button")" @onclick="() => SetActiveTab(tab)">
            @tab.Title
        </button>
    }
</div>

<div class="tab-content">
    @if (activeTab != null)
    {
        @if (activeTab.Title == "Home")
        {
            <div class="simDescription">
                <h4>Welcome to My Genetic Evolution Simulator!</h4>
                <p class="tagline">Read on to get started!</p>

                <h5>Quick Start Guide:</h5>
                <p>Please select a pre-configuration from the top to get a good starting point.</p>
                <p>You can then use the settings tabs to alter specific settings.  You can save your current settings locally and re-upload them for later use.  This includes which settings are favourited.  A lot of the example numbers below will be slightly off, as I am constantly updating the default values.</p>
                <p>Click Start/Reset, Simplified Start or Super Simplified Start from the top right menu to begin.</p>
                <p>You can also use one of my pre-trained genome pools to skip the first generations, but you are then restricted to my settings.</p>
                <p>The current agent pool is auto-saved to browser storage every generation, so if you have a crash, or close without saving, hit the amber button to attempt to recover.</p>
                <p>Start/Reset will respect all configurations, while Simplified Start will remove the energy system, some score bonuses, limb and layer number mutations, and a few other things</p>
                <p>Simplified Start should see much faster learning, with agents completing the maps with 100 generations or so; using full configurations will result in much more interesting behavior, but will take 100+ generations to see much progress</p>
                <p>Super Simplified Start will also give agents a small, fixed brain and pre-set body plan, and will see agents complete the maps in 50-100 generations</p>
                <p>Use 'WASD' to pan the camera around.</p>
                <p>Use the button bank in the top right to toggle rendering of the leading agents brain/neural network, their vision lines/ray casts, switch between the leading agent and training agent or fast-forward generations (only about twice as fast as normal currently)</p>
                <p>You can also save the current set of agents genomes locally so you can continue training later.  This saves the current settings alongside the agents Genomes so they continue with the same setup.</p>
                <p>The skip x generation buttons will disable the rendering and increase the physics update rate by 4x.  If you are already running at the limit of what your computer can handle, IE. your fps is below 30-40 at normal speed, this is not going to actually speed up much.  Rendering the scene only adds about 5-10% to the processing time per frame.</p>
                <p>This simulation can be temperamental, it is prone to running out of memory, and still sometimes errors relating to tensor disposal.  Please save genomes regularly so you can continue in those cases.</p>
                <p>I have not tested all settings in all configurations, and I have been very generous with settings ranges, so its very easy to break things!</p>
                <p>You can also update any settings mid-run using the update button.  This works well for things like swim strength or world properties, but will break for most agent properties.  I have not tested this extensively.</p>
                <p>If anything breaks, such as the population size, a settings update, a failed mutation etc, the first thing to try is to 'Stop' or reset, and then 'Recover Auto Save' which sorts it most of the time.  I recommend saving regularly in case this does not work.</p>

                <h5>Settings To Play With</h5>
                <p>Aside from performance settings and numbers of agents, there are many settings that effect training and starting conditions.  Some of the more interesting are:</p>
                <ol>
                    <li>Min and Max number of starting limbs.  Agents can evolve past this.</li>
                    <li>Swim Strength, Joint Speed and Liquid Viscosity.  Together effect agents movement.  Swim Bias gives a bias to forces parallel to the agents facing direction</li>
                    <li>Starting Limb Chain Length, which means agents start with either 1 set of limbs, 2 or 3, where subsequent sets are attached to the ends of the previous.  Agents can evolve beyond this.</li>
                    <li>Maximum and Minimum starting neural network layers.  Agents can evolve past this.</li>
                    <li>Different score and energy configurations.</li>
                    <li>Different training settings, like migration rate, top performers to keep and mutation rates.</li>
                </ol>
                
                <h5>Some Explanation:</h5>
                <p>This is my take on a NEAT style genetic evolution simulation.  It's not actually using the NEAT algorithm, as far as I can tell it's not possible using TensorFlow.js due to requiring dynamic models for networks.</p>
                <p>I have however, used many of the principals talked about in the original paper.  Unlike most evolution sims using neural networks, my agents brains can evolve in shape as well as weights.  Mutating the number of layers and nodes per layer was not too complex, but performing crossover on networks that dont match in shape is a non trivial task.</p>
                <p>The original paper solved this in 2 ways, 1 was specialization, where agents with similar shaped networks where selected as parents, making crossover easier, and creating different species groups that arose naturally, and also by keeping track of mutated network features using IDs, and deciding whether to keep new mutated features from one parent or the other.</p>
                <p>This is where TensorFlow.js limits come into play.  In NEAT proper, the neural networks are not static or restricted to rows  of specific numbers of neurons.  It was built on a system that allows any neurones to connect to any others, regardless of depth in the network.  They are generally still feed froward, but just not in the neat format of rows and nodes TensorFlow.js is restricted to.</p>
                <p>There are a number of ways around this.  I thought about having large numbers of redundant nodes per row, and redundant rows, and just using some connections and nodes and leaving others dead, essentially a sparsely connected network.  Those sparse connections could mimic the more random connection structure needed.  I think this is possible, but it would be complicated to crossover.  You would have to group neurons into 'features' that are crossed over and find ways to maintain already existing connections to maintain learning.  This would also have large memory overheads in redundant nodes</p>
                <p>The solution I have ended up using is a node-to-node ID system.  Each node is given a unique ID, and each connection is identified as the fromNodeID and toNodeID that they connect to.  I can then use a system of checks to see if nodes and layers exist in both parents, and chose which to keep.  Networks are still restricted to densely connected, rigid networks, but they can gain or loose nodes and layers.</p>
                <p>A feature of my simulation thats missing from most NEAT implementations is the ability for agents to evolve their body plan over time as well a their brains.  This can result in some interesting and complex bodies over time.</p>
                <p>I have implemented the ability to see agents brains on screen, but this seems to add a fair amount of CPU overhead.  It should only be toggled on for a while, it seems to cause memory issues after a while</p>
                <p>I am making use of P5.JS for my rendering, Planck.JS; a port of Box2D, for my physics and TensorFlow.JS for my neural network processing.  Thanks to Blazor WASM's service workers, this application should run fine offline, though some browsers may never load it without an initial internet connection.</p>
                <p>I started building the first version of this just for a bit of fun.  I had seen lots of YouTube videos of similar projects and wanted to try and emulated them as a way to learn.  I read the NEAT paper when it first published, and have wanted to explore this direction ever since.  The project has since evolved somewhat; I'm not really sure the end goal, but it's become a bit of a passion project over the last 12 months.  I've thought about making it a teaching tool or something similar, but I have no idea if there is any use for it.  It's really just here to teach me!  Please do email me at samw.denton@gmail.com if you have found this tool and have any use for it or any suggestions!</p>
                <p>There is some further information on the history of the project on the <a style="text-decoration: none" href="/Projects/all/all">Projects Page of the Wiki</a></p>

                <h5>So whats going on?</h5>
                <p>If you start the simulation with default settings, you will see about 10-20 agents on the screen, representing the top scorer from each group, a random agent per group, the agent that has made it furthest, and the trailing agent.  Which agents are on screen can be configured.</p>
                <p>Default settings will produce 100-300 agents in the population, split into batches of species groups, denoted by colour.  25 agents from the run group are evaluated at a time, with a random selection of species</p>
                <p>There are a number of settings that will effect performance.  The pre-sets should handle these, but you may want to adjust a few.  The main ones will be the 'Number Of Agents' which is the number of agents to run at a time.  This is multiplied by 'Groups Per Generation' to get the total number of agents in the population.  Also the 'Agents Per Batch of Joint Updates', which is how many agents are updated per frame.  Ideally, each agent should get a minimum of 2 updates per second, as more updates gives more control.  Having this number about 1/10th the number of agents is about right.</p>
                <p>On my PC, using a Ryzen 7 3700X CPU about 3.5Ghz per core, I can target about 100 agents at a time, with 10 Agents Per Batch of Joint Updates.  The Number of Inter-gen Batches will not effect performance, but will increase training time, as only 1 batch can be evaluated at a time</p>
                <p>Since i'm making use of JS, the bottleneck for most systems is going to be the speed of a single CPU core.  Some configurations may reach a browser memory limit before a CPU limit, if you have a high number of inter-gen batches.  Browsers I have tested seem ok up to about 1000 agents total</p>
                <p>The GPU is also utilized for any Neural Network functions, the most intense of which happen between rounds, so it doesn't really matter how long they take, but during the simulation, the actual decision making also utilities the GPU using WebGL.  I have not found a configuration where this is the bottleneck, but its possible</p>
                <p>Each round, the agents have 2000 ticks, about 34 seconds at 60 fps with default physics speed of 60, to move as far North East as possible.</p>
                <p>The agents are all given a randomly initialized neural network, with a random shape for a brain, the leaders brain can be rendered.  They are given a random body plan.  Both the brain and the body plan will evolve over time based on a number of crossover and mutation functions</p>
                <p>Between rounds, the agents are sorted by score, where the top 10% from each species are selected to remain unchanged, and the other 90% of the population is built using crossover and mutation.</p>
                <p>This is performed between generations, on the whole population</p>
                <p>Crossover is the function of picking 2 parent agents and combining the weights and biases in their brains, keeping some features from one, and some from the other.  There are a range of methods for this, I am currently using biased Arithmetic Crossover, where there is a weighted bias given by the relative scores of the parents.</p>
                <p>Mutation adds a small chance that each weight, bias, limb or body will be altered by a small, random amount.  Again, there are many methods, currently i am using the Box-Muller transform to get a Gaussian random number for my mutation amount.  I have a function that changes the mutation rate if agents brains get too close to the average</p>
                <p>I am currently also mutating the number of limbs and layers in the brain.  These are more complex to mutate than others, as they tend to produce 'dead' agents that need retaining from scratch, which naturaly cant compete with already trained agents.  I am playing with a number of methods to counter this.</p>
                <p>Now, when a new limb is mutated, it finds an existing limb with a similar starting angle, and copies the weights from that limb.  When a new layer is mutated, it should create a matching layer, where biases are copied from the previous layer, and weights are connected so the old node connects to its new copy with a weight of 1, and all other weights are 0 in the new layer, hopefully copying the previous layers function until new values are evolved.</p>
                <p>The parents for crossover can be selected in many ways, I am actually using 1 method for 1 parent, and another for the other.  The first is picked via tournament selection, where 10 random agents are selected from the group, and the best of those if picked.  The second is picked via a weighted random selection, where ever agent is entered into a lottery with more entries for a higher score, and a random agent is picked from the pool.</p>
                <p>I am also using 'Island Populations' or 'Island Speciation', where parents are always picked from the same distinct group.  This means, with default settings, 5-10 distinct populations should evolve with different strategies.  There is a small chance that parents are picked from a different group, allowing some sharing of strategies</p>
                <p>You should see some 'evolution' within  50 or so generations, and they can continue to improve indefinitely, however, they can get stuck in whats known as a 'local maxima' where the agents converge on 1 or a few ok strategies, and never seem to improve.  Through mutation, they might eventually, but in those situations, it can be best to restart.  A greater number of agents or distinct population groups can help with this</p>
                <p>If enabled, I am experimenting with a form of normalization which slowly decays all weights in the network over time.  It's meant to prevent any noise in the network over time, based on a 'use it or loose it' principal.  Useful connections should be maintained by re-selection and unused connections will drop away</p>
                <h5>Current Selective Pressures:</h5>
                <ol>
                    <li>Score for movement North East</li>
                    <li>Bonus for joint movement that diminishes over time</li>
                    <li>Exploration bonus</li>
                    <li>Size bonus, multiplied by movement</li>
                    <li>Larger limbs give more swimming force</li>
                </ol>
                <h6>Energy System:</h6>
                <ol>
                    <li>Starting energy based on body size, larger bodies can store more energy</li>
                    <li>More energy is used to move larger limbs</li>
                    <li>Agents limb movement speed is based on their remaining energy %, with no energy, they cant move at all</li>
                </ol>

                <h5>Future Plans</h5>
                <p>I want to use an OpenAI API integration to pick values for starting configurations to produce better populations over time.</p>
                <p>I want to add the agents internal map of covered ground as an input so they know where they have already explored.  I could also include the last few generations maps for that agent so it can see where it explored in previous generations.  This will require significantly more complex brains, longer training time and reduced agents per run group, as well as possibly larger populations.</p>
                <p>I need to re-implement the agent output selectors, and allow agents to evolve inputs and outputs list.</p>
                <p>I would like to implement modularity in the neural network structure, so sections or modules of nodes and layers are combined to create the whole network.  These modules can then be treated individually and swapped about.</p>
                <p>If I switch from storing the full population genome as a JS object to storing it in IndexedDB, I can achieve much greater total population numbers.  Currently, about 700 is the limit.  I can also make the agents object more efficient</p>
                <p>There is a lot of clean up work to do on the code, the genome and the agent objects.  I have lots of duplicated values and old structures.  I am not making use of 'const' enough, and I am duplicating functions in places</p>
                <p>I need to work on the maps.  They are too simple and not varied enough.  I want to implement some goals, like food, tied to the energy system.  A puzzle to open a door or similar could also be interesting</p>
                <p>I plan on adding further ways the agents can evolve. I want to allow more complex body plans with different types of limb and body segments, such as wings, thrusters, suckers, energy storage limbs etc</p>
                <p>I want to add a greater range of crossover, mutation and selection methods to increase diversity, and have them toggle in settings to play with different combinations</p>
                <p>I am also going to introduce a diversity metric that gives score bonus for being different from other agents, and also increases an agents mutation rate if it is too similar to the average agent.</p>
                <p>I want to add a way to save and load agents to an online repo like git hub, so top agents can be shared.</p>
                <p>I want to add the ability to see genomes on screen somehow</p>
                <p>I want to play around with a predator and prey scenario, where some agents learn to catch others</p>
                <p>There are many different ways to adjust the energy system to see more interesting evolution, such as food, recovering energy by resting, reducing update speed based on energy, adding limbs just for energy storage etc</p>
                <p>I have created a few different versions of my mutate and crossover functions, I would like to let the user pick which is used.  I need to get the old ones working first</p>
                <p>Could look at implementing another idea from NEAT, where agents are given a metric based on their properties, and have a higher chance to reproduce with similar agents.  This can create species groups even within my island populations, leading to a greater variety of solutions.  This may require larger populations to work well, 100-200 agents per group, where I currently have 25 per group.</p>
                <p>I would love to make use of parallelization to spread some load across CPU cores, but JS makes this difficult.  Initial inquiries suggest its doable, but sharing memory states across CPU cores will be a challenge.  As a first step, creating a custom Electron implementation could help increase the available memory and give more control over resource use, but would still be very tricky to parallelize across CPU cores.  I think the easiest way would be to just have multiple instances of the program running at once, and between generations, the agent pool is transfered between the 2 and split back up.</p>
                <p>Currently, my crossover methods both treat each neuron independently, it would be good to also allow groups of neurons to be transfered together so learned features are maintained.</p>
                <p>Body plan crossover has not been re-implemented since I added limb chains.  I should be able to borrow logic from by NN crossover code.</p>
            </div>
        }
        else if (activeTab.Title == "Favourites")
        {
            <p class="tabDesc">@activeTab.Description</p>
            <div class="settings-container">
                @foreach (var favSettingName in stageProperties.FavouriteSettings)
                {
                    var favSetting = tabs.SelectMany(tab => tab.Settings)
                    .FirstOrDefault(setting => setting.Name == favSettingName);

                    if (favSetting == null)
                    {
                        favSetting = tabs.SelectMany(tab => tab.AdvancedSettings)
                        .FirstOrDefault(setting => setting.Name == favSettingName);
                    }

                    if (favSetting != null)
                    {
                        <div class="@(favSetting.Type == SettingType.Slider || favSetting.Type == SettingType.Dropdown ? "setting large" : "setting")">
                            <label>@favSetting.Name</label>
                            @switch (favSetting.Type)
                            {
                                case SettingType.Slider:
                                    <input type="range" @bind="favSetting.Value" min="@favSetting.Min" max="@favSetting.Max" step="@favSetting.Step" />
                                    <input type="number" @bind="favSetting.Value" min="@favSetting.Min" max="@favSetting.Max" step="@favSetting.Step" />
                                    break;
                                case SettingType.Dropdown:
                                    <select @bind="favSetting.SelectedValue">
                                        @foreach (var option in favSetting.Options)
                                        {
                                            <option value="@option">@option</option>
                                        }
                                    </select>
                                    break;
                                case SettingType.Checkbox:
                                    <label class="switch">
                                        <input type="checkbox" @bind="favSetting.BooleanValue" />
                                        <span class="slider"></span>
                                    </label>
                                    break;
                            }
                            <button @onclick="@(() => ToggleFavourite(favSetting.Name))" class="favourite-button">
                                @if (stageProperties.FavouriteSettings.Contains(favSetting.Name))
                                {
                                    <span class="favourited">★</span> <!-- Marked as favourite -->
                                }
                                else
                                {
                                    <span>☆</span> <!-- Not favourite -->
                                }
                            </button>
                            <p class="setting-details">@favSetting.Details</p>
                        </div>
                    }
                }
            </div>
        }
        else
        {
            <p class="tabDesc">@activeTab.Description</p>
            <div class="settings-container">
                @foreach (var setting in activeTab.Settings)
                {
                    <div class="@(setting.Type == SettingType.Slider || setting.Type == SettingType.Dropdown ? "setting large" : "setting")">
                        <label>@setting.Name</label>
                        @switch (setting.Type)
                        {
                            case SettingType.Slider:
                                <input type="range" @bind="setting.Value" min="@setting.Min" max="@setting.Max" step="@setting.Step" />
                                <input type="number" @bind="setting.Value" min="@setting.Min" max="@setting.Max" step="@setting.Step" />
                                break;
                            case SettingType.Dropdown:
                                <select @bind="setting.SelectedValue">
                                    @foreach (var option in setting.Options)
                                    {
                                        <option value="@option">@option</option>
                                    }
                                </select>
                                break;
                            case SettingType.Checkbox:
                                <label class="switch">
                                    <input type="checkbox" @bind="setting.BooleanValue" />
                                    <span class="slider"></span>
                                </label>
                                break;
                        }
                        <button @onclick="@(() => ToggleFavourite(setting.Name))" class="favourite-button">
                            @if (stageProperties.FavouriteSettings.Contains(setting.Name))
                            {
                                <span class="favourited">★</span> <!-- Marked as favourite -->
                            }
                            else
                            {
                                <span>☆</span> <!-- Not favourite -->
                            }
                        </button>
                        <p class="setting-details">@setting.Details</p>
                    </div>
                }
                @if (activeTab.HasAdvanced)
                {
                    <button class="toggleAdvanced" @onclick="() => ToggleAdvanced(activeTab)">Toggle Advanced</button>
                    @if (activeTab.ShowAdvanced)
                    {
                        @foreach (var advancedSetting in activeTab.AdvancedSettings)
                        {
                            <div class="@(advancedSetting.Type == SettingType.Slider || advancedSetting.Type == SettingType.Dropdown ? "setting large" : "setting")">
                                <label>@advancedSetting.Name</label>
                                @switch (advancedSetting.Type)
                                {
                                    case SettingType.Slider:
                                        <input type="range" @bind="advancedSetting.Value" min="@advancedSetting.Min" max="@advancedSetting.Max" step="@advancedSetting.Step" />
                                        <input type="number" @bind="advancedSetting.Value" min="@advancedSetting.Min" max="@advancedSetting.Max" step="@advancedSetting.Step" />
                                        break;
                                    case SettingType.Dropdown:
                                        <select @bind="advancedSetting.SelectedValue">
                                            @foreach (var option in advancedSetting.Options)
                                            {
                                                <option value="@option">@option</option>
                                            }
                                        </select>
                                        break;
                                    case SettingType.Checkbox:
                                        <label class="switch">
                                            <input type="checkbox" @bind="advancedSetting.BooleanValue" />
                                            <span class="slider"></span>
                                        </label>
                                        break;
                                }
                                <button @onclick="@(() => ToggleFavourite(advancedSetting.Name))" class="favourite-button">
                                    @if (stageProperties.FavouriteSettings.Contains(advancedSetting.Name))
                                    {
                                        <span class="favourited">★</span> <!-- Marked as favourite -->
                                    }
                                    else
                                    {
                                        <span>☆</span> <!-- Not favourite -->
                                    }
                                </button>
                                <p class="setting-details">@advancedSetting.Details</p>
                            </div>
                        }
                    }
                }
            </div>
        }
    }
</div>

@if (showPopup)
{
    <div class="popup-overlay" @onclick="TogglePopup">
        <div class="popup-window" @onclick:stopPropagation>
            <div class="popup-header">
                <h3>Select Pre-trained Agents</h3>
                <button class="btn-close" @onclick="TogglePopup">X</button>
            </div>
            <div class="popup-content">
                @foreach (var agentSet in preTrainedAgents)
                {
                    <div class="agent-set">
                        <h4>@agentSet.Name</h4>
                        <p class="preTrainedDesc">@agentSet.Description</p>
                        <p>Generation: @agentSet.GenCount</p>
                        <p>Top Score: @agentSet.TopScore.ToString("0.00")</p>
                        <p>Number of Agents: @agentSet.NumberOfAgents</p>
                        <p>Swim Method: @agentSet.SwimMethod</p>
                        <p>Body Plan: @(agentSet.Symmetrical ? "Symmetrical" : "Asymmetrical")</p>
                        <p>Start Method: @agentSet.StartMethod</p>
                        <button class="btn btn-select" @onclick="() => SelectAgentSet(agentSet)">Start!</button>
                    </div>
                }
            </div>
        </div>
    </div>
}

@if (showGenomePopup)
{
    <div class="popup-overlay" @onclick="ToggleGenomePopup">
        <div class="popup-window" @onclick:stopPropagation>
            <div class="popup-header">
                <h3>Genome Viewer</h3>
                <button class="btn-close" @onclick="ToggleGenomePopup">X</button>
            </div>
            <div class="popup-content">
                <div id="genomeViewer" class="genome-viewer"></div>
            </div>
        </div>
    </div>
}

<div class="button-container">
    <button class="floating-button start-button rightColumn" title="Start simulation with full configured settings" @onclick="ResetSimulation">Start/Reset</button>
    <button class="floating-button simpleStart-button leftColumn" title="Start simulation with no energy or extra score bonuses.  Faster, but less interesting evolution" @onclick="ResetSimulationSimple">Simplified Start</button>
    <button class="floating-button superSimpleStart-button rightColumn" title="Start simulation with no energy, extra score bonuses and a fixed body plan.  Much faster, but less interesting evolution" @onclick="ResetSimulationSuperSimple">Super Simplified Start</button>
    <button class="floating-button update-button leftColumn" title="You can update any settings mid simulation, but some changes will break things" @onclick="UpdateSimulation">Update</button>
    <button class="floating-button toggleNN-button rightColumn" title="Toggle rendering of Neural Network.  Can cause some lag" @onclick="toggleNN">Toggle Neural Network</button>
    <button class="floating-button toggleLeader-button leftColumn" title="Toggle between following the leading vs trailing agents.  Switches rendered Neural Network as well" @onclick="toggleLeader">Toggle Leader vs Trailer</button>
    @* <button class="floating-button toggleRays-button rightColumn" title="Toggle rendering for agents vision lines" @onclick="toggleRayCasts">Toggle Ray-casts</button> *@
    <button class="floating-button logGenomes-button leftColumn" title="Post all agent genomes to console" @onclick="LogGenomes">Log Genomes</button>
    <button class="floating-button retrieveGenomes-button rightColumn" title="Save current agent genome pool to continue training later" @onclick="RetrieveGenomes">Save Genomes</button>
    <button class="floating-button uploadGenomes-button leftColumn" title="Upload agent genome pool to continue training" @onclick="UploadGenomes">Upload Genomes / Start</button>
    <button class="floating-button skip10Gen-button rightColumn" title="Skips 10 generations by disabling rendering and increasing physics speed.  This will still take a few minutes" @onclick="Skip10Gen">Skip 10 Generations</button>
    <button class="floating-button skip100Gen-button leftColumn" title="Skips 1 generation by disabling rendering and increasing physics speed. This will still take a few minutes" @onclick="Skip100Gen">Skip 1 Generations</button>
    <button class="floating-button selectPretrained-button leftColumn" title="Allows pre-trained groups of agents to be selected to begin" @onclick="TogglePopup">Select Pre-trained Agents</button>
    <button class="floating-button recoverGenome-button rightColumn" title="Attempts to recover auto-saved genome." @onclick="RecoverAutoSave">Recover Auto-Save</button>
    <button class="floating-button killSim-button leftColumn" title="Attempts to stop the simulation." @onclick="killSim">Stop</button>
    <button class="floating-button saveKill-button rightColumn" title="Attempts to save and then stop the simulation." @onclick="saveKillSim">Save and Stop</button>
    <button class="floating-button viewGenome-button rightColumn" title="View Genomes" @onclick="ToggleGenomePopup">View Leaders Genome</button>
</div>

@code {

    private bool showPopup = false;
    private bool showGenomePopup = false;
    private List<AgentSet> preTrainedAgents = new List<AgentSet>();
    private TabModel activeTab;
    private List<TabModel> tabs;
    private StageProperties stageProperties = new StageProperties();
    public bool box2dPhysics { get; set; } = true;
    private bool showAdvancedSettings = true;
    public List<Genome> population = new List<Genome>();
    public List<Genome> evolvedPopulation = new List<Genome>();

    protected override void OnInitialized()
    {
        InitializePreTrainedAgents();
        InitializeTabs();
        activeTab = tabs.FirstOrDefault(); // Set the first tab as active by default
    }

    private async Task UpdateSettingHoverEffects()
    {
        // Delay to ensure new DOM elements are rendered
        await Task.Delay(100);
        await JSRuntime.InvokeVoidAsync("initializeSettingHoverEffects");
    }

    private async void SetActiveTab(TabModel tab)
    {
        activeTab = tab;
        await JSRuntime.InvokeVoidAsync("clearAllTooltips");
        await UpdateSettingHoverEffects();
    }

    private void TogglePopup() => showPopup = !showPopup;

    private async Task ToggleGenomePopup()
    {
        showGenomePopup = !showGenomePopup;
        await Task.Delay(100);
        if (showGenomePopup)
        {
            await JSRuntime.InvokeVoidAsync("showGenomes");
        }
    }

    private async Task SelectAgentSet(AgentSet set)
    {
        TogglePopup();
        stageProperties = await JSRuntime.InvokeAsync<StageProperties>("loadPreTrainedGenome", set.Filename);
        Console.WriteLine($"Selected: {set.Name}");
    }

    public class AgentSet
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public string Filename { get; set; }
        public int GenCount { get; set; }
        public double TopScore { get; set; }
        public int NumberOfAgents { get; set; }
        public string SwimMethod { get; set; }
        public bool Symmetrical { get; set; }
        public string StartMethod { get; set; }
    }


    private async void ToggleAdvanced(TabModel tab)
    {
        tab.ShowAdvanced = !tab.ShowAdvanced;
        await UpdateSettingHoverEffects();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await UpdateSettingHoverEffects();
        }
    }

    private async  void ToggleFavourite(string settingName)
    {
        if (stageProperties.FavouriteSettings.Contains(settingName))
        {
            stageProperties.FavouriteSettings.Remove(settingName);
        }
        else
        {
            stageProperties.FavouriteSettings.Add(settingName);
        }
        StateHasChanged();
        await Task.Delay(100);
        await JSRuntime.InvokeVoidAsync("initializeSettingHoverEffects");
        await JSRuntime.InvokeVoidAsync("clearAllTooltips");
    }


    public enum SettingType
    {
        Slider,
        Checkbox,
        Dropdown,
        Info
    }

    public class TabModel
    {
        public string Title { get; set; }
        public string Description { get; set; }
        public List<Setting> Settings { get; set; } = new List<Setting>();
        public List<Setting> AdvancedSettings { get; set; } = new List<Setting>();
        public bool HasAdvanced { get; set; }
        public bool ShowAdvanced { get; set; }
    }

    public class Setting
    {
        public string Name { get; set; }
        public SettingType Type { get; set; }
        public Func<int> ValueExpression { get; set; }
        public Action<int> ValueChanged { get; set; }
        public Func<bool> BooleanValueExpression { get; set; }
        public Action<bool> BooleanValueChanged { get; set; }
        public Func<string> SelectedValueExpression { get; set; }
        public Action<string> SelectedValueChanged { get; set; }
        public int Min { get; set; }
        public int Max { get; set; }
        public int Step { get; set; }
        public string Details { get; set; }
        public List<string> Options { get; set; } = new List<string>();

        public int Value
        {
            get => ValueExpression?.Invoke() ?? 0;
            set => ValueChanged?.Invoke(value);
        }

        public bool BooleanValue
        {
            get => BooleanValueExpression.Invoke();
            set => BooleanValueChanged?.Invoke(value);
        }

        public string SelectedValue
        {
            get => SelectedValueExpression?.Invoke();
            set => SelectedValueChanged?.Invoke(value);
        }
    }

    private async Task saveSettings()
    {
        await JSRuntime.InvokeVoidAsync("saveSettings", stageProperties);
    }

    private async Task uploadSettings()
    {
        stageProperties = await JSRuntime.InvokeAsync<StageProperties>("uploadSettings");
    }

    private async Task toggleNN()
    {
        stageProperties.showNN = !stageProperties.showNN;
        await UpdateSimulation();
    }

    private async Task toggleRayCasts()
    {
        stageProperties.showRays = !stageProperties.showRays;
        await UpdateSimulation();
    }

    private void ToggleAdvancedSettings()
    {
        showAdvancedSettings = !showAdvancedSettings;
    }

    private async Task UpdateSimulation()
    {
        await JSRuntime.InvokeVoidAsync("updateSimulationNEAT", stageProperties);
    }

    private async Task toggleLeader()
    {
        if (stageProperties.agentInCentre == "leader")
        {
            stageProperties.agentInCentre = "trailer";
        }
        else
        {
            stageProperties.agentInCentre = "leader";
        }

        await UpdateSimulation();
    }

    private async Task LogGenomes()
    {
        await JSRuntime.InvokeVoidAsync("logGenomes");
    }

    public override string ToString()
    {
        return JsonSerializer.Serialize(this);
    }

    private async Task RetrieveGenomes()
    {
        await JSRuntime.InvokeAsync<string>("saveGenomes");
    }

    private async Task UploadGenomes()
    {
        stageProperties = await JSRuntime.InvokeAsync<StageProperties>("uploadGenomes");
    }

    private async Task RecoverAutoSave()
    {
        stageProperties = await JSRuntime.InvokeAsync<StageProperties>("recoverStateFromIndexedDB");
    }

    public async Task Skip10Gen()
    {
        await JSRuntime.InvokeVoidAsync("skipGen", 10);
    }

    public async Task Skip100Gen()
    {
        await JSRuntime.InvokeVoidAsync("skipGen", 1);
    }

    void Shuffle<T>(List<T> list, Random random)
    {
        int n = list.Count;
        while (n > 1)
        {
            n--;
            int k = random.Next(n + 1);
            T value = list[k];
            list[k] = list[n];
            list[n] = value;
        }
    }

    public async Task InitializePopulation(int populationSize)
    {
        population = new List<Genome>();
        Random random = new Random();
        //let agentsPerGroup = Math.ceil(totalPopulationGenomes.length / numGroups);
        // For now, set manual total population size as 10 * numAgents
        int totalPopulation = populationSize * stageProperties.totalNumAgentsMultiplier;
        // Calculate the number of groups
        int numGroups = Math.Max(1, (int)Math.Ceiling((double)totalPopulation / stageProperties.maxPopGroupSize));
        List<int> runGroups = Enumerable.Range(0, stageProperties.totalNumAgentsMultiplier)
                                            .SelectMany(x => Enumerable.Repeat(x, totalPopulation / stageProperties.totalNumAgentsMultiplier))
                                            .ToList();

        // If the total population isn't perfectly divisible by stageProperties.totalNumAgentsMultiplier,
        // add extra run groups to fill up the list
        while (runGroups.Count < totalPopulation)
        {
            runGroups.Add(new Random().Next(0, stageProperties.totalNumAgentsMultiplier));
        }

        // Count the number of inputs
        int noInputs = 0;
        if (stageProperties.inputTicker == true)
        {
            noInputs++;
        }
        if (stageProperties.inputJointAngle == true)
        {
            // Added at the point of layer creation
            // noInputs++;
        }
        if (stageProperties.inputJointSpeed == true)
        {
            // Needs to be added at the point of layer creation
            // noInputs++;
        }
        if (stageProperties.inputAgentPos == true)
        {
            noInputs += 2;
        }
        if (stageProperties.inputAgentV == true)
        {
            noInputs += 2;
        }
        if (stageProperties.inputScore == true)
        {
            noInputs++;
        }
        if (stageProperties.inputOrientation == true)
        {
            noInputs++;
        }
        if (stageProperties.inputTimeRemaining == true)
        {
            noInputs++;
        }
        if (stageProperties.inputDistanceSensors == true)
        {
            noInputs += 4;
        }

        // Shuffle the list
        runGroups = runGroups.OrderBy(x => Guid.NewGuid()).ToList();

        if (stageProperties.bodyPlanStart == "simple")
        {
            for (int i = 0; i < totalPopulation; i++)
            {
                Genome genome = new Genome();
                genome.Metadata.AgentIndex = i;

                int numLimbs = 3;

                int numLimbsModified;
                if (stageProperties.keepAgentSymmetrical == true)
                {
                    numLimbsModified = numLimbs - 1;
                }
                else
                {
                    numLimbsModified = numLimbs;
                }

                genome.InputLayerGenes.Add(InitializeInputLayer(numLimbsModified * stageProperties.startingLimbChainLength, noInputs));

                int numLayers = 3;

                genome.LayerGenes.Add(InitializeLayer(0, 18));
                genome.LayerGenes.Add(InitializeLayer(1, 10));

                genome.OutputLayerGenes.Add(InitializeOutputLayer(numLimbsModified * stageProperties.startingLimbChainLength));
                genome.MainBody = InitializeBodyPlanSimple(numLimbs);
                // initialize genome.Metadata.AgentName as random string in the format cvccvc (consonant vowel consonant consonant vowel consonant)
                var randomName = new Random();
                var consonants = "bcdfghjklmnpqrstvwxyz";
                var vowels = "aeiou";
                var agentName = $"{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}";
                genome.Metadata.AgentName = agentName;
                genome.Metadata.RunGroup = runGroups[i];
                genome.Metadata.AgentGroup = i % numGroups;
                genome.Hyperparameters.MutationRate = (double)stageProperties.offspringMutationRate / 10000;
                genome.Hyperparameters.NodeMutationRate = (double)stageProperties.offspringNodeMutationRate / 10000;
                genome.Hyperparameters.LayerMutationRate = (double)stageProperties.offspringLayerMutationRate / 10000;
                genome.Hyperparameters.LimbMutationRate = (double)stageProperties.offspringLimbMutationRate / 10000;

                // add ids to usedLayerIDs, 1 to numLayers
                genome.UsedLayerIDs = Enumerable.Range(1, numLayers).ToList();

                population.Add(genome);
            }
        }
        else
        {
            for (int i = 0; i < totalPopulation; i++)
            {
                Genome genome = new Genome();
                genome.Metadata.AgentIndex = i;

                int numLimbs = random.Next(stageProperties.minLimbs, stageProperties.maxLimbs);

                int numLimbsModified;
                if (stageProperties.keepAgentSymmetrical == true)
                {
                    numLimbsModified = numLimbs / 2;
                    // Initialize genes, examples used for now, will be randomized once the constructor is complete
                    // genome.InputLayerGenes.Add(InitializeInputLayer((numLimbs - (numLimbs % 2)) * stageProperties.startingLimbChainLength));
                }
                else
                {
                    numLimbsModified = numLimbs;
                    // Initialize genes, examples used for now, will be randomized once the constructor is complete
                    // genome.InputLayerGenes.Add(InitializeInputLayer(numLimbs * stageProperties.startingLimbChainLength));
                }

                genome.InputLayerGenes.Add(InitializeInputLayer(numLimbsModified * stageProperties.startingLimbChainLength, noInputs));

                int numLayers = random.Next(stageProperties.minNNLayers, stageProperties.maxNNLayers);

                // assuming you want to add 3 layers, and the layer numbers are between 1 and 3, and sizes between 10 and 20
                for (int j = 0; j < numLayers; j++)
                {
                    int randomSize = random.Next(3, 20); // Generates a random integer between 3 and 20
                    genome.LayerGenes.Add(InitializeLayer(j, randomSize));
                }

                genome.OutputLayerGenes.Add(InitializeOutputLayer(numLimbsModified * stageProperties.startingLimbChainLength));
                genome.MainBody = InitializeBodyPlan(numLimbsModified);
                // initialize genome.Metadata.AgentName as random string in the format cvccvc (consonant vowel consonant consonant vowel consonant)
                var randomName = new Random();
                var consonants = "bcdfghjklmnpqrstvwxyz";
                var vowels = "aeiou";
                var agentName = $"{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}";
                genome.Metadata.AgentName = agentName;
                genome.Metadata.RunGroup = runGroups[i];
                genome.Metadata.AgentGroup = i % numGroups;
                genome.Hyperparameters.MutationRate = (double)stageProperties.offspringMutationRate / 10000;
                genome.Hyperparameters.NodeMutationRate = (double)stageProperties.offspringNodeMutationRate / 10000;
                genome.Hyperparameters.LayerMutationRate = (double)stageProperties.offspringLayerMutationRate / 10000;
                genome.Hyperparameters.LimbMutationRate = (double)stageProperties.offspringLimbMutationRate / 10000;

                // add ids to usedLayerIDs, 1 to numLayers
                genome.UsedLayerIDs = Enumerable.Range(1, numLayers).ToList();

                population.Add(genome);
            }
        }
    }

    private InputLayerGene InitializeInputLayer(int numLimbs, int noInputs)
    {
        return new InputLayerGene
            {
                NumberOfNeurons = noInputs + numLimbs,
                ActivationType = stageProperties.inputActivationFunction,
                Inputs = Enumerable.Range(1, noInputs + numLimbs).ToList()
            };
    }

    private LayerGene InitializeLayer(int layerId, int numberOfNeurons)
    {
        return new LayerGene
            {
                LayerID = layerId,
                LayerType = LayerType.Dense,
                NumberOfNeurons = numberOfNeurons,
                ActivationType = stageProperties.hiddenActivationFunction
            };
    }

    private OutputLayerGene InitializeOutputLayer(int numLimbs)
    {
        return new OutputLayerGene
            {
                NumberOfNeurons = numLimbs, // 3 outputs
                ActivationType = stageProperties.outputActivationFunction,
                Outputs = Enumerable.Range(1, numLimbs).ToList() // List of outputs from 1 to 3
            };
    }

    private MainBody InitializeBodyPlan(int numLimbs)
    {
        Random random = new Random();

        MainBody mainBody = new MainBody
            {
                PartID = 0,
                NumberInChain = 0,
                Shape = "Circle",
                Size = 10 + random.NextDouble() * 30.0,
                Density = 0.1 + random.NextDouble() * 0.6,
                Arms = new List<Arm>() // Initializing the Limbs list
            };

        for (int i = 1; i <= numLimbs; i++)
        {
            double angle = random.NextDouble() * 2 * Math.PI; // Random angle in radians

            int id = i;

            Arm arm = new Arm
                {
                    PartID = id,
                    ParentPartID = 0,
                    NumberInChain = 1,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            Arm subArm = new Arm
                {
                    PartID = id + numLimbs,
                    ParentPartID = id,
                    NumberInChain = 2,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = random.NextDouble() * 2 * Math.PI,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            Arm subArm2 = new Arm
                {
                    PartID = id + numLimbs * 2,
                    ParentPartID = subArm.PartID,
                    NumberInChain = 3,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = random.NextDouble() * 2 * Math.PI,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 1000 + random.NextDouble() * 79000,
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };

            if (stageProperties.startingLimbChainLength > 1)
            {
                arm.SubArms.Add(subArm);
                if (stageProperties.startingLimbChainLength > 2)
                {
                    subArm.SubArms.Add(subArm2);
                }
            }

            mainBody.Arms.Add(arm);
        }

        return mainBody;
    }


    private MainBody InitializeBodyPlanSimple(int numLimbs)
    {
        Random random = new Random();

        MainBody mainBody = new MainBody
            {
                PartID = 0,
                NumberInChain = 0,
                Shape = "Circle",
                Size = 25,
                Density = 0.3,
                Arms = new List<Arm>() // Initializing the Limbs list
            };
        int numLimbsModified;
        if (stageProperties.keepAgentSymmetrical == true)
        {
            numLimbsModified = numLimbs - 1;
        }
        else
        {
            numLimbsModified = numLimbs;
        }
        for (int i = 1; i <= numLimbsModified; i++)
        {
            double angle = ((i - 1) * 2 * Math.PI) / numLimbs;

            // reserve ids 0 to 10 for body segments
            int id = i + 10;

            Arm arm = new Arm
                {
                    PartID = id,
                    ParentPartID = 0,
                    NumberInChain = 1,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 50.0,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            Arm subArm = new Arm
                {
                    PartID = id + numLimbs,
                    ParentPartID = id,
                    NumberInChain = 2,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 40,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            Arm subArm2 = new Arm
                {
                    PartID = id + numLimbs * 2,
                    ParentPartID = subArm.PartID,
                    NumberInChain = 3,
                    Type = "Arm",
                    Shape = "Rectangle",
                    Length = 40,
                    Width = 10,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = 0,
                        Y = 0
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = 80000,
                        MinAngle = -(Math.PI / 3),
                        MaxAngle = (Math.PI / 3)
                    }
                };

            if (stageProperties.startingLimbChainLength > 1)
            {
                arm.SubArms.Add(subArm);
                if (stageProperties.startingLimbChainLength > 2)
                {
                    subArm.SubArms.Add(subArm2);
                }
            }

            mainBody.Arms.Add(arm);
        }

        return mainBody;
    }

    public class Genome
    {
        public List<InputLayerGene> InputLayerGenes { get; set; }
        public List<LayerGene> LayerGenes { get; set; }
        public List<OutputLayerGene> OutputLayerGenes { get; set; }
        // public List<InnovationEntry> InnovationLog { get; set; }
        public MainBody MainBody { get; set; }
        public AgentHistory AgentHistory { get; set; }
        public Hyperparameters Hyperparameters { get; set; }
        public Metadata Metadata { get; set; }
        public List<int>? UsedBiasIDs { get; set; }
        public List<int>? UsedLayerIDs { get; set; }

        public Genome()
        {
            // Initialize properties with defaults or random values.
            this.InputLayerGenes = new List<InputLayerGene>();
            this.LayerGenes = new List<LayerGene>();
            this.OutputLayerGenes = new List<OutputLayerGene>();
            // this.InnovationLog = new List<InnovationEntry>();
            this.MainBody = new MainBody();
            this.AgentHistory = new AgentHistory();
            this.Hyperparameters = new Hyperparameters();
            this.Metadata = new Metadata();
        }
    }

    public class MainBody
    {
        public int PartID { get; set; }
        public int NumberInChain { get; set; }
        public string Shape { get; set; }
        public double Size { get; set; }
        public double Density { get; set; }
        public List<Arm> Arms { get; set; } = new List<Arm>();
        public List<Wing> Wings { get; set; } = new List<Wing>();
        public List<Thruster> Thrusters { get; set; } = new List<Thruster>();
        public List<BodySegment> BodySegments { get; set; } = new List<BodySegment>();
        public List<int> UsedLimbIDs { get; set; } = new List<int>();
    }

    public class BodySegment
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Size { get; set; }
        public double Density { get; set; }
        public JointConstraints? Constraints { get; set; }
        public AttachmentPoint Attachment { get; set; }
        public List<Arm> Arms { get; set; } = new List<Arm>();
        public List<Wing> Wings { get; set; } = new List<Wing>();
        public List<Thruster> Thrusters { get; set; } = new List<Thruster>();
    }

    public class Arm
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
        public List<Arm> SubArms { get; set; } = new List<Arm>(); 
        public List<Wing> SubWings { get; set; } = new List<Wing>(); 
        public List<Thruster> SubThrusters { get; set; } = new List<Thruster>(); 
    }

    public class Wing
    {
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
    }

    public class Thruster
    {
        public double ThrustForce { get; set; }
        public int PartID { get; set; }
        public int ParentPartID { get; set; }
        public int NumberInChain { get; set; }
        public string Type { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public JointConstraints Constraints { get; set; } = new JointConstraints();
        public AttachmentPoint Attachment { get; set; }
    }

    public class AttachmentPoint
    {
        public double? X { get; set; }
        public double? Y { get; set; }
    }

    public class JointConstraints
    {
        public double? MaxTorque { get; set; }
        public double? MinAngle { get; set; }
        public double? MaxAngle { get; set; }
    }

    // Encode the agents history into the genome:

    public class AgentHistory
    {
        public bool RunThisGeneration { get; set; }
        public ScoreHistory? LastScore { get; set; }
        public List<ScoreHistory>? ScoreHistory { get; set; }
        public int RoundsAsTopPerformer { get; set; }
        public int UsedAsParent { get; set; }
        public List<String>? Mutations { get; set; }
        public double RankInGroup { get; set; }
        public double RankInPop { get; set; }

        public AgentHistory()
        {
            this.LastScore = new ScoreHistory();
            this.RunThisGeneration = false;
            this.ScoreHistory = new List<ScoreHistory>();
            this.RoundsAsTopPerformer = 0;
            this.UsedAsParent = 0;
            this.Mutations = new List<String>();
        }
    }

    public class ScoreHistory
    {
        public float Score { get; set; }
        public int Map { get; set; }
        public int Generation { get; set; }
    }

    public class Hyperparameters
    {
        public double MutationRate { get; set; }
        public double NodeMutationRate { get; set; }
        public double LayerMutationRate { get; set; }
        public double LimbMutationRate { get; set; }
    }

    public class Metadata
    {
        public int RunGroup { get; set; }
        public int AgentGroup { get; set; }
        public string AgentName { get; set; }
        public int AgentIndex { get; set; }
        public string GroupName { get; set; }
        public string Species { get; set; }
        public double BestScore { get; set; }
        public int CompatabilityDistance { get; set; }

        public Metadata()
        {
            // Initialize with default values, or leave them null.  Should maybe have these as parameters in the call
            this.AgentName = "Unnamed"; // Set randomly on initialization, unique to an agent
            this.AgentIndex = 0; // Set randomly on initialization, unique to an agent
            this.GroupName = "DefaultGroup"; // set randomly on initialization, the same for all agents in a population
            this.Species = "Unspecified"; // set randomly on initialization, same for agents in the same spices.  might need to set this later after distinct spices groups form.
            this.BestScore = 0; // Set to 0 on initialization, updated after each round
            this.CompatabilityDistance = 0; // Set to 0 on initialization, updated after each round
        }
    }

    public class InputLayerGene
    {
        public int NumberOfNeurons { get; set; }
        public String ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<Bias>? Biases { get; set; }
        public List<int>? Inputs { get; set; }

        public InputLayerGene()
        {
            this.Biases = new List<Bias>();
            this.Inputs = new List<int>();
        }
    }

    public class LayerGene
    {
        public int LayerID { get; set; }
        public LayerType LayerType { get; set; }  // "Dense", "Conv", "LSTM", etc.
        public int NumberOfNeurons { get; set; }
        public String ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<List<Weight>>? Weights { get; set; }
        public List<Bias>? Biases { get; set; }

        public LayerGene()
        {
            this.Weights = new List<List<Weight>>();
            this.Biases = new List<Bias>();            
        }
    }

    public class OutputLayerGene
    {
        public int NumberOfNeurons { get; set; }
        public String ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<List<Weight>>? Weights { get; set; }
        public List<Bias>? Biases { get; set; }
        public List<int>? Outputs { get; set; }

        public OutputLayerGene()
        {
            this.Weights = new List<List<Weight>>();
            this.Biases = new List<Bias>();
            this.Outputs = new List<int>();
        }
    }

    public class Weight
    {
        //public int ID { get; set; }
        public int FromNodeID { get; set; }
        public int ToNodeID { get; set; }
        public double? Value { get; set; }
    }

    public class Bias
    {
        public int ID { get; set; }
        public double? Value { get; set; }
    }

    public enum LayerType
    {
        Dense,
        Convolutional,
        LSTM,
        // ...other types
    }

    // public enum ActivationType
    // {
    //     ReLU,
    //     Sigmoid,
    //     Tanh,
    //     Linear,
    //     Softmax,
    //     Softplus,
    //     Softsign,
    //     Relu6,
    //     Elu,
    //     Selu,
    //     LeakyReLU,
    //     PReLU,
    //     Swish
    // }

    private async Task ResetSimulation()
    {
        await resetLists();
        stageProperties.topScoreEver = 0;
        stageProperties.genCount = 0;
        await InitializePopulation(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task ResetSimulationSimple()
    {
        await resetLists();
        stageProperties.topScoreEver = 0;
        stageProperties.genCount = 0;
        stageProperties.energyUseForceSizeMult = 0;
        stageProperties.energyUseLimbSizeMult = 0;
        stageProperties.energyUseBrainSizeMult = 0;
        stageProperties.startingEnergyMassPower = 0;
        stageProperties.startingEnergyBase = 1;
        stageProperties.swimMethod = "simple";
        stageProperties.networkOutput = "simple";
        stageProperties.startingEnergyBodyMassMult = 0;
        stageProperties.startingEnergyLimbMassMult = 0;
        stageProperties.movementScoreMultiplier = 30;
        stageProperties.explorationScoreMultiplier = 100;
        stageProperties.sizeScoreMultiplier = 0;
        stageProperties.offspringLayerMutationRate = 5;
        stageProperties.offspringLimbMutationRate = 20;
        stageProperties.agentsRequireStablising = false;
        stageProperties.randomAgentStartAngle = false;
        await InitializePopulation(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task ResetSimulationSuperSimple()
    {
        await resetLists();
        stageProperties.topScoreEver = 0;
        stageProperties.genCount = 0;
        stageProperties.energyUseForceSizeMult = 0;
        stageProperties.energyUseLimbSizeMult = 0;
        stageProperties.energyUseBrainSizeMult = 0;
        stageProperties.startingEnergyMassPower = 0;
        stageProperties.startingEnergyBase = 1;
        stageProperties.swimMethod = "simple";
        stageProperties.networkOutput = "simple";
        stageProperties.keepAgentSymmetrical = true;
        stageProperties.startingEnergyBodyMassMult = 0;
        stageProperties.startingEnergyLimbMassMult = 0;
        stageProperties.movementScoreMultiplier = 30;
        stageProperties.explorationScoreMultiplier = 0;
        stageProperties.sizeScoreMultiplier = 0;
        stageProperties.offspringMutationRate = 50;
        stageProperties.offspringNodeMutationRate = 0;
        stageProperties.offspringLayerMutationRate = 0;
        stageProperties.offspringLimbMutationRate = 10;
        stageProperties.topPerformerNumber = 20;
        stageProperties.swimStrength = 110;
        stageProperties.randomMap = false;
        stageProperties.map = 1;
        stageProperties.agentsRequireStablising = false;
        stageProperties.bodyPlanStart = "simple";
        stageProperties.maxJointSpeed = 15;
        stageProperties.randomAgentStartAngle = false;
        stageProperties.chanceToIncludeTopPerformerInMutation = 1;
        stageProperties.hiddenActivationFunction = "relu";
        await InitializePopulation(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", population);
    }

    private async Task killSim()
    {
        await JSRuntime.InvokeVoidAsync("killSim");
        await resetLists();
    }

    private async Task saveKillSim()
    {
        await RetrieveGenomes();
        await killSim();
    }

    public class StageProperties
    {
        public List<string> FavouriteSettings { get; set; } = new List<string> { "Number of Agents", "Agent Multiplier", "Maximum Limbs", "Minimum Neural Network Layers", "Maximum Neural Network Layers", "Starting Limb Chain Length", "Swim Strength", "Offspring Mutation Rate", "Offspring Limb Mutation Rate", "Top Performer Number", "Migration Rate", "Maximum Population Group Size", "Liquid Viscosity", "Swim Method", "Body Plan", "Keep Agent Symmetrical", "Network Output" };
        public List<double> ScoreHistory { get; set; } = new List<double>();
        public List<double> ScoreHistoryTop { get; set; } = new List<double>();
        public List<double> ScoreHistoryAverage { get; set; } = new List<double>();

        // Performance
        public int numAgents { get; set; } = 25;
        public int totalNumAgentsMultiplier { get; set; } = 8;
        public int muscleDelay { get; set; } = 2;
        public int muscleBatch { get; set; } = 5;
        public int simSpeed { get; set; } = 60;
        public bool autoAdjustPerformance { get; set; } = true;
        // Advanced Performance
        public int totalMuscleUpdateTime { get; set; } = 2;
        public int delay { get; set; } = 20;
        public int BatchSize { get; set; } = 10;
        public int updatesPerAgentStart { get; set; } = 2;
        public int framesPerUpdateStart { get; set; } = 2;
        public int agentStartSpawnGap { get; set; } = 5000;

        // Agent
        public int minLimbs { get; set; } = 2;
        public int maxLimbs { get; set; } = 5;
        public int minNNLayers { get; set; } = 1;
        public int maxNNLayers { get; set; } = 5;
        public int startingLimbChainLength { get; set; } = 1;
        public int swimStrength { get; set; } = 100;
        public int swimBias { get; set; } = 15;
        public bool randomAgentStartAngle { get; set; } = true;
        public int maxJointSpeed { get; set; } = 20;
        public string swimMethod { get; set; } = "advanced";
        public string bodyPlanStart { get; set; } = "complex";
        public bool keepAgentSymmetrical { get; set; } = false;
        public string networkOutput { get; set; } = "complex";
        public string inputActivationFunction { get; set; } = "linear";
        public string hiddenActivationFunction { get; set; } = "selu";
        public string outputActivationFunction { get; set; } = "tanh";
        // Advanced Agent
        public int maxForceMagnitude { get; set; } = 5000;
        public int speedThreshold { get; set; } = 100;
        public int maxTorqueMultiplier { get; set; } = 300000;
        public int limbMassForceDivider { get; set; } = 50;
        public int limbLengthForceDivider { get; set; } = 30;
        public int agentStartX { get; set; } = 200;
        public int agentStartY { get; set; } = 600;
        public int swimForceOverNFrames { get; set; } = 5;
        public int speedForceNormilizer { get; set; } = 20;
        public int speedNormalizationForDrag { get; set; } = 2500;
        public int bodyAngularDragPower { get; set; } = 10;
        public int maxTorqueForDamping { get; set; } = 10000;
        public int threasholdAngleForDamping { get; set; } = 10;
        public int inputTickerRate { get; set; } = 90;
        public bool inputTicker { get; set; } = true;
        public bool inputJointAngle { get; set; } = true;
        public bool inputJointSpeed { get; set; } = false;
        public bool inputAgentPos { get; set; } = true;
        public bool inputAgentV { get; set; } = true;
        public bool inputScore { get; set; } = false;
        public bool inputOrientation { get; set; } = true;
        public bool inputTimeRemaining { get; set; } = false;
        public bool inputDistanceSensors { get; set; } = true;
        public bool outputsJointSpeed { get; set; } = true;
        public bool outputsJointTorque { get; set; } = false; // Not implemented
        public bool outputsBias { get; set; } = false; // Not implemented
        public bool brainDecayOverTime { get; set; } = false; // Not implemented

        // Score and Energy
        public int xScoreMultiplier { get; set; } = 30;
        public int yScoreMultiplier { get; set; } = 30;
        public int movementScoreMultiplier { get; set; } = 60;
        public int explorationScoreMultiplier { get; set; } = 200;
        public int sizeScoreMultiplier { get; set; } = 50;
        public bool massBonusIsDynamic { get; set; } = true;
        public int startingEnergyBase { get; set; } = 10;
        public int startingEnergyMassPower { get; set; } = 2;
        // Advanced Score and Energy
        public int startingEnergyBodyMassMult { get; set; } = 10;
        public int startingEnergyLimbMassMult { get; set; } = 10;
        public int energyUseForceSizeMult { get; set; } = 10;
        public int energyUseLimbSizeMult { get; set; } = 10;
        public int energyUseBrainSizeMult { get; set; } = 10;
        public int limbMassEnergyReductionDivider { get; set; } = 15;
        public int brainSizeEnergyReductionDivider { get; set; } = 100;
        public int forceMagnitudeEnergyReductionDivider { get; set; } = 1000000;
        public int bodyStartingMassEnergyReductionDivider { get; set; } = 400;
        public int limbStartingMassEnergyReductionDivider { get; set; } = 30;
        public int jointMovementRewardLimbMassDivider { get; set; } = 100;
        public int internalMapSize { get; set; } = 250;
        public int internalMapCellSize { get; set; } = 50;
        public int dynamicMassBonusDivider { get; set; } = 500;

        // Training and Evolution
        public int offspringMutationRate { get; set; } = 100;
        public int offspringNodeMutationRate { get; set; } = 40;
        public int offspringLayerMutationRate { get; set; } = 5;
        public int offspringLimbMutationRate { get; set; } = 40;
        public int topPerformerNumber { get; set; } = 15;
        public int migrationRate { get; set; } = 5;
        public int minPopGroupSize { get; set; } = 10;
        public int maxPopGroupSize { get; set; } = 25;
        public bool agentsRequireStablising { get; set; } = true;
        // Advanced Training and Evolution
        public int tournamentSize { get; set; } = 10;
        public int linearStabilityThresholdBody { get; set; } = 15;
        public int angularStabilityThresholdBody { get; set; } = 20;
        public int angularStabilityThresholdLimb { get; set; } = 15;
        public int stabilityFrames { get; set; } = 20;
        public int stabilityCheckOverwriteFrames { get; set; } = 500;
        public int chanceToIncludeTopPerformerInMutation { get; set; } = 2;
        public int chanceToIncludeOffspringInMutation { get; set; } = 50;
        public int neuronMutationStandardDeviation { get; set; } = 10;
        public int bodyPlanMutationStandardDeviation { get; set; } = 10;
        public int maxPosForNormalisation { get; set; } = 5000;
        public int maxVelForNormalisation { get; set; } = 50;

        // World Properties
        public int liquidViscosity { get; set; } = 5;
        public bool timeIncrease { get; set; } = true;
        public int map { get; set; } = 1;
        public bool randomMap { get; set; } = true;
        public int SimulationLength { get; set; } = 2000;
        // Advanced World Properties
        public int Width { get; set; } = 1600;
        public int Height { get; set; } = 800;
        public int GroundY { get; set; } = 700;
        public int Gravity { get; set; } = 1; // not implemented
        public double Friction { get; set; } = 0.4; // not implemented
        public int simulationLengthIncrease { get; set; } = 15;
        public int maxSimulationLength { get; set; } = 50000;
        public int velocityIteration { get; set; } = 4;
        public int positionIteration { get; set; } = 2;
        public int physicsGranularityMultipliers { get; set; } = 10;

        // Visualization and UI
        public int renderedAgents { get; set; } = 1;
        public bool showGroupLeaders { get; set; } = true;
        public bool showLeadingAgent { get; set; } = true;
        public bool showGroupTrailers { get; set; } = true;
        public bool showScoreHistory { get; set; } = true;
        public bool showAverageScoreHistory { get; set; } = true;
        public bool showTopScoreHistory { get; set; } = true;
        public int backgroundRed { get; set; } = 0;
        public int backgroundGreen { get; set; } = 0;
        public int backgroundBlue { get; set; } = 128;
        public int backgroundParticles { get; set; } = 100;
        // Advanced Visualization and UI
        public bool showNN { get; set; } = false;
        public bool showRays { get; set; } = true;
        public string agentInCentre { get; set; } = "leader";
        public int uiRefreshRate { get; set; } = 250;
        public int renderedNNLayerGap { get; set; } = 100;
        public int renderedNNNodeGap { get; set; } = 30;

        // Debugging and Diagnostics
        public bool showForceVectors { get; set; } = false;
        // Advanced Debugging and Diagnostics
        public int visualForceScale { get; set; } = 20;
        public int visualMaxForceLength { get; set; } = 300;

        // Behind the scenes
        public double topScoreEver { get; set; }
        public int genCount { get; set; }

    }

    // The below properties were previously doubles but had to be changed to ints to work with some of the data binding for UI setting selectors.
    // Ideally, I should find a way to keep their native types rather then converting them to ints here then back to doubles in the JS code.

    // public class StageProperties2
    // {
    //     public double migrationRate { get; set; } = 0.002;
    //     public double physicsGranularityMultipliers { get; set; } = 1;
    //     public double maxJointSpeed { get; set; } = 1;

    //     public double offspringMutationRate { get; set; } = 0.02;
    //     public double offspringNodeMutationRate { get; set; } = 0.005;
    //     public double offspringLayerMutationRate { get; set; } = 0.001;
    //     public double offspringLimbMutationRate { get; set; } = 0.01;

    //     public double swimBias { get; set; } = 1.5;
    //     public double xScoreMultiplier { get; set; } = 3;
    //     public double yScoreMultiplier { get; set; } = 3;
    //     public double movementScoreMultiplier { get; set; } = 3;
    //     public double explorationScoreMultiplier { get; set; } = 5;
    //     public double sizeScoreMultiplier { get; set; } = 0.2;
    //     public double startingEnergyBodyMassMult { get; set; } = 1;
    //     public double startingEnergyLimbMassMult { get; set; } = 1;
    //     public double energyUseForceSizeMult { get; set; } = 1;
    //     public double energyUseLimbSizeMult { get; set; } = 1;
    //     public double energyUseBrainSizeMult { get; set; } = 1;
    //     public double chanceToIncludeTopPerformerInMutation { get; set; } = 0.1;
    //     public double chanceToIncludeOffspringInMutation { get; set; } = 0.5;
    //     public double neuronMutationStandardDeviation { get; set; } = 0.1;
    //     public double bodyPlanMutationStandardDeviation { get; set; } = 0.1;
    //     public double liquidViscosity { get; set; } = 0.0005;
    //     public double surfaceAreaCoefficient { get; set; } = 0.0001;
    //     public double linearStabilityThresholdBody { get; set; } = 0.01;
    //     public double angularStabilityThresholdBody { get; set; } = 0.15;
    //     public double angularStabilityThresholdLimb { get; set; } = 0.1;
    //     public double threasholdAngleForDamping { get; set; } = 0.1;
    // }

    private void InitializePreTrainedAgents()
    {
        preTrainedAgents.Add(new AgentSet
            {
                Name = "Standard Start",
                Description = "This population started with almost default settings, using the Standard Start button. The score function was adjusted mid way through, and agent score tracking was fixed, so the graphs look a bit odd.  I also added new maps around generation 300 so learning was interrupted a bit.  Medium performance settings used.  This population suggests that, using the full complex learning settings, it will take 1000+ generations for significant progress.  The mutation rates, migration rates and population size will also alter this though.  Trained before implementing an internal sign switch ticker which does seem to help speed up learning.",
                Filename = "EvolvedPop_Gen646_TopScore4446.23_Agents500_advancedSwimMethod_Asymmetrical.json",
                GenCount = 646,
                TopScore = 4446.23,
                NumberOfAgents = 500,
                SwimMethod = "Advanced",
                Symmetrical = false,
                StartMethod = " Standard"
            });
        preTrainedAgents.Add(new AgentSet
            {
                Name = "Straight Line",
                Description = "This population was started with Super Simple, before I gave a small range for the front and back, non-duplicated limbs, so they only know how to move in a straight line so far.  A good starting point for playing with environment settings. Trained before implementing an internal sign switch ticker which does seem to help speed up learning.",
                Filename = "EvolvedPop_Gen319_TopScore2661.46_Agents500_simpleSwimMethod_Symmetrical.json",
                GenCount = 319,
                TopScore = 2661.46,
                NumberOfAgents = 500,
                SwimMethod = "Simple",
                Symmetrical = true,
                StartMethod = " Super Simple"
            });
        preTrainedAgents.Add(new AgentSet
            {
                Name = "1 Long Arm!",
                Description = "This population has gone through multiple settings changes that have led them to evolve 1 arm with many sub arms.  For a while, they where getting a huge score bonus for this.  High Performance settings used.  Trained before implementation so no score graphs available. Trained before implementing an internal sign switch ticker which does seem to help speed up learning.",
                Filename = "EvolvedPop_Gen169_TopScore4465.77_Agents500_advancedSwimMethod_Asymmetrical.json",
                GenCount = 169,
                TopScore = 4465.77,
                NumberOfAgents = 500,
                SwimMethod = "Advanced",
                Symmetrical = false,
                StartMethod = "Standard"
            });
        preTrainedAgents.Add(new AgentSet
            {
                Name = "Super Simple Start",
                Description = "What happens if you train a population for 3 days before realizing you set the mutation rate to 0 accidentally...",
                Filename = "sillyPop,noMutation,gen126.json",
                GenCount = 126,
                TopScore = 2000,
                NumberOfAgents = 500,
                SwimMethod = "Simple",
                Symmetrical = true,
                StartMethod = " Super Simple"
            });
        preTrainedAgents.Add(new AgentSet
            {
                Name = "Simple Start",
                Description = "This population started with almost default settings, using the Simple Start button.  Medium performance settings used.  Trained before implementation so no score graphs available or internal ticker.",
                Filename = "EvolvedPop_Gen76_TopScore1505.39_Agents500_simpleSwimMethod_Asymmetrical.json",
                GenCount = 76,
                TopScore = 1505.39,
                NumberOfAgents = 500,
                SwimMethod = "Simple",
                Symmetrical = false,
                StartMethod = "Simple"
            });
        preTrainedAgents.Add(new AgentSet
            {
                Name = "Standard Start, Small Pop",
                Description = "This population started with almost default settings, but with only 50 agents in total.  Medium performance settings used.  Trained before implementation so no score graphs available or internal ticker.",
                Filename = "EvolvedPop_Gen57_TopScore861.09_Agents50_advancedSwimMethod_Asymmetrical.json",
                GenCount = 57,
                TopScore = 861.09,
                NumberOfAgents = 50,
                SwimMethod = "Advanced",
                Symmetrical = false,
                StartMethod = "Standard"
            });
        preTrainedAgents.Add(new AgentSet
            {
                Name = "Super Simple, 50 Agents",
                Description = "A quick test population since I added score graphs.  Trained before implementing an internal sign switch ticker which does seem to help speed up learning.",
                Filename = "EvolvedPop_Gen49_TopScore212.95_Agents50_simpleSwimMethod_Symmetrical.json",
                GenCount = 49,
                TopScore = 212.95,
                NumberOfAgents = 50,
                SwimMethod = "Simple",
                Symmetrical = true,
                StartMethod = "SuperSimple"
            });
    }

    private async Task setMobilePresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 5;
        stageProperties.numAgents = 5;
        stageProperties.totalNumAgentsMultiplier = 20;
        stageProperties.muscleDelay = 5;
        stageProperties.muscleBatch = 1;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task setLowPresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 10;
        stageProperties.numAgents = 25;
        stageProperties.totalNumAgentsMultiplier = 10;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 3;
        stageProperties.totalMuscleUpdateTime = 2;
    }

    private async Task setMidPresets()
    {
        stageProperties.delay = 10;
        stageProperties.BatchSize = 20;
        stageProperties.numAgents = 50;
        stageProperties.totalNumAgentsMultiplier = 10;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 5;
        stageProperties.totalMuscleUpdateTime = 2;
    }

    private async Task setHighPresets()
    {
        stageProperties.delay = 5;
        stageProperties.BatchSize = 5;
        stageProperties.numAgents = 75;
        stageProperties.totalNumAgentsMultiplier = 6;
        stageProperties.muscleDelay = 1;
        stageProperties.muscleBatch = 5;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task setVHighPresets()
    {
        stageProperties.delay = 1;
        stageProperties.BatchSize = 10;
        stageProperties.numAgents = 150;
        stageProperties.totalNumAgentsMultiplier = 3;
        stageProperties.muscleDelay = 1;
        stageProperties.muscleBatch = 10;
        stageProperties.totalMuscleUpdateTime = 1;
    }

    private async Task resetLists()
    {
        stageProperties.ScoreHistory = new List<double>();
        stageProperties.ScoreHistoryTop = new List<double>();
        stageProperties.ScoreHistoryAverage = new List<double>();
    }

    private async Task resetSettings()
    {
        stageProperties.topScoreEver = 0;
        stageProperties.numAgents = 25;
        stageProperties.totalNumAgentsMultiplier = 8;
        stageProperties.muscleDelay = 2;
        stageProperties.muscleBatch = 5;
        stageProperties.simSpeed = 60;
        stageProperties.autoAdjustPerformance = true;
        stageProperties.totalMuscleUpdateTime = 2;
        stageProperties.delay = 20;
        stageProperties.BatchSize = 10;
        stageProperties.updatesPerAgentStart = 1;
        stageProperties.framesPerUpdateStart = 1;
        stageProperties.renderedAgents = 1;
        stageProperties.showGroupLeaders = true;
        stageProperties.showLeadingAgent = true;
        stageProperties.showGroupTrailers = true;
        stageProperties.showScoreHistory = true;
        stageProperties.showAverageScoreHistory = true;
        stageProperties.showTopScoreHistory = true;
        stageProperties.agentStartSpawnGap = 5000;
        stageProperties.minLimbs = 2;
        stageProperties.maxLimbs = 5;
        stageProperties.minNNLayers = 1;
        stageProperties.maxNNLayers = 5;
        stageProperties.startingLimbChainLength = 1;
        stageProperties.swimStrength = 100;
        stageProperties.swimBias = 15;
        stageProperties.randomAgentStartAngle = true;
        stageProperties.swimMethod = "advanced";
        stageProperties.bodyPlanStart = "complex";
        stageProperties.networkOutput = "complex";
        stageProperties.inputActivationFunction = "linear";
        stageProperties.hiddenActivationFunction = "tanh";
        stageProperties.outputActivationFunction = "tanh";
        stageProperties.keepAgentSymmetrical = false;
        stageProperties.maxJointSpeed = 10;
        stageProperties.maxForceMagnitude = 1000;
        stageProperties.maxTorqueMultiplier = 300000;
        stageProperties.limbMassForceDivider = 50;
        stageProperties.limbLengthForceDivider = 30;
        stageProperties.agentStartX = 200;
        stageProperties.agentStartY = 600;
        stageProperties.swimForceOverNFrames = 5;
        stageProperties.speedForceNormilizer = 20;
        stageProperties.speedNormalizationForDrag = 2500;
        stageProperties.bodyAngularDragPower = 10;
        stageProperties.maxTorqueForDamping = 10000;
        stageProperties.threasholdAngleForDamping = 10;
        stageProperties.inputTickerRate = 90;
        stageProperties.inputTicker = true;
        stageProperties.inputJointAngle = true;
        stageProperties.inputJointSpeed = false;
        stageProperties.inputAgentPos = true;
        stageProperties.inputAgentV = true;
        stageProperties.inputScore = false;
        stageProperties.inputOrientation = true;
        stageProperties.inputTimeRemaining = false;
        stageProperties.inputDistanceSensors = true;
        stageProperties.outputsJointSpeed = true;
        stageProperties.outputsJointTorque = false;
        stageProperties.outputsBias = false;
        stageProperties.brainDecayOverTime = false;
        stageProperties.xScoreMultiplier = 30;
        stageProperties.yScoreMultiplier = 30;
        stageProperties.movementScoreMultiplier = 30;
        stageProperties.explorationScoreMultiplier = 200;
        stageProperties.sizeScoreMultiplier = 20;
        stageProperties.massBonusIsDynamic = true;
        stageProperties.startingEnergyBase = 10;
        stageProperties.startingEnergyMassPower = 2;
        stageProperties.startingEnergyBodyMassMult = 10;
        stageProperties.startingEnergyLimbMassMult = 10;
        stageProperties.energyUseForceSizeMult = 10;
        stageProperties.energyUseLimbSizeMult = 10;
        stageProperties.energyUseBrainSizeMult = 10;
        stageProperties.limbMassEnergyReductionDivider = 15;
        stageProperties.brainSizeEnergyReductionDivider = 100;
        stageProperties.forceMagnitudeEnergyReductionDivider = 1000000;
        stageProperties.bodyStartingMassEnergyReductionDivider = 400;
        stageProperties.limbStartingMassEnergyReductionDivider = 30;
        stageProperties.jointMovementRewardLimbMassDivider = 100;
        stageProperties.internalMapSize = 500;
        stageProperties.internalMapCellSize = 50;
        stageProperties.dynamicMassBonusDivider = 500;
        stageProperties.offspringMutationRate = 100;
        stageProperties.offspringNodeMutationRate = 40;
        stageProperties.offspringLayerMutationRate = 5;
        stageProperties.offspringLimbMutationRate = 40;
        stageProperties.topPerformerNumber = 15;
        stageProperties.migrationRate = 5;
        stageProperties.minPopGroupSize = 10;
        stageProperties.maxPopGroupSize = 25;
        stageProperties.agentsRequireStablising = true;
        stageProperties.tournamentSize = 10;
        stageProperties.linearStabilityThresholdBody = 15;
        stageProperties.angularStabilityThresholdBody = 20;
        stageProperties.angularStabilityThresholdLimb = 15;
        stageProperties.stabilityFrames = 20;
        stageProperties.stabilityCheckOverwriteFrames = 500;
        stageProperties.chanceToIncludeTopPerformerInMutation = 10;
        stageProperties.chanceToIncludeOffspringInMutation = 50;
        stageProperties.neuronMutationStandardDeviation = 10;
        stageProperties.bodyPlanMutationStandardDeviation = 10;
        stageProperties.maxPosForNormalisation = 5000;
        stageProperties.maxVelForNormalisation = 50;
        stageProperties.liquidViscosity = 5;
        stageProperties.timeIncrease = true;
        stageProperties.map = 1;
        stageProperties.randomMap = true;
        stageProperties.SimulationLength = 2000;
        stageProperties.Width = 1600;
        stageProperties.Height = 800;
        stageProperties.GroundY = 700;
        stageProperties.Gravity = 1;
        stageProperties.Friction = 0.4;
        stageProperties.simulationLengthIncrease = 15;
        stageProperties.maxSimulationLength = 50000;
        stageProperties.velocityIteration = 4;
        stageProperties.positionIteration = 2;
        stageProperties.physicsGranularityMultipliers = 10;
        stageProperties.backgroundRed = 0;
        stageProperties.backgroundGreen = 0;
        stageProperties.backgroundBlue = 128;
        stageProperties.backgroundParticles = 100;
        stageProperties.showNN = false;
        stageProperties.showRays = true;
        stageProperties.agentInCentre = "leader";
        stageProperties.uiRefreshRate = 250;
        stageProperties.renderedNNLayerGap = 100;
        stageProperties.renderedNNNodeGap = 30;
        stageProperties.showForceVectors = false;
        stageProperties.visualForceScale = 20;
        stageProperties.visualMaxForceLength = 300;
    }

    private void InitializeTabs()
    {
        tabs = new List<TabModel>
        {
            new TabModel
            {
                Title = "Home",
                HasAdvanced = false
            },
            new TabModel
            {
                Title = "Favourites",
                Description = "Settings that have greater effect, are more interesting or more likely to be adjusted more often.  The favourites list is saved alongside other settings.",
                Settings = new List<Setting>(), // This will be populated dynamically
                HasAdvanced = false
            },
            new TabModel
            {
                Title = "Performance",
                Description = "Configure the performance-related aspects of the simulation.  This is mostly how many agents are running at a time, and how frequently they are able to update.  An update means a new set of inputs and outputs in the neural networks / brains, so gives finer, more fluid control.  Try to target at least 200 agents in total, and at least 2 updates per agent per second.  The simulation will get harder to run as agents evolve so make sure you have some overhead when starting out.  For the first 10 or so generations, your frame rate should be steady, or you will struggle later on.  You can update the number of updates per agent per second but it will effect behavior.  There is a function that automatically adjusts the simulation speed to try and keep the frame rate between 30 and 45 which can be disabled.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Number of Agents",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.numAgents,
                        ValueChanged = val => stageProperties.numAgents = val,
                        Min = 1,
                        Max = 1000,
                        Step = 1,
                        Details = "Determines the number of agents to run at a time.  This is multiplied by the Groups Per Generation to get the total number of agents in the population"
                    },
                    new Setting
                    {
                        Name = "Groups Per Generation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.totalNumAgentsMultiplier,
                        ValueChanged = val => stageProperties.totalNumAgentsMultiplier = val,
                        Min = 1,
                        Max = 50,
                        Step = 1,
                        Details = "Multiplier to increase the total number of agents in the population.  More groups means a bigger population, but will take longer to train as only 1 group is run at a time."
                    },
                    new Setting
                    {
                        Name = "Muscle Batch Delay",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.muscleDelay,
                        ValueChanged = val => stageProperties.muscleDelay = val,
                        Min = 0,
                        Max = 10,
                        Step = 1,
                        Details = "Delay between muscle batch updates, affecting agent movement fluidity.  Try to target at least 2 updates per agent per second (look at console for agent updates)"
                    },
                    new Setting
                    {
                        Name = "Muscle Batch Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.muscleBatch,
                        ValueChanged = val => stageProperties.muscleBatch = val,
                        Min = 1,
                        Max = 50,
                        Step = 1,
                        Details = "Number of muscle updates processed together in a batch.  This should generally be about 1/10th the number of agents in the run group."
                    },
                    new Setting
                    {
                        Name = "Simulation Speed",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.simSpeed,
                        ValueChanged = val => stageProperties.simSpeed = val,
                        Min = 15,
                        Max = 480,
                        Step = 15,
                        Details = "Adjusts the physics speed of the simulation, approx this number of frames per second, if the simulation is running at 60 FPS.  If you are struggling to run the simulation with a reasonable number of agents, try slowing down the physics speed.  You can have this set higher for the first 20+ generations and lower this as the sim starts to struggle with more complex agents."
                    },
                    new Setting
                    {
                        Name = "Auto Adjust Performance",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.autoAdjustPerformance,
                        BooleanValueChanged = val => stageProperties.autoAdjustPerformance = val,
                        Details = "Toggles whether the simulation will automatically adjust the simulation speed to try and maintain a steady frame rate, between 30 and 50."
                    },
                    new Setting
                    {
                        Name = "Brain Decay",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.brainDecayOverTime,
                        BooleanValueChanged = val => stageProperties.brainDecayOverTime = val,
                        Details = "Toggles whether the agents' brains decay over time.  This is still being implemented."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Total Muscle Update Time",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.totalMuscleUpdateTime,
                        ValueChanged = val => stageProperties.totalMuscleUpdateTime = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Defines the number of frames between complete agent updates.  Has very little effect."
                    },
                    new Setting
                    {
                        Name = "Delay",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.delay,
                        ValueChanged = val => stageProperties.delay = val,
                        Min = 0,
                        Max = 50,
                        Step = 1,
                        Details = "Sets the delay parameter for spawn processing between agents."
                    },
                    new Setting
                    {
                        Name = "Batch Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.BatchSize,
                        ValueChanged = val => stageProperties.BatchSize = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Determines the size of each batch in spawn processing."
                    },
                    new Setting
                    {
                        Name = "Updates Per Agent Start",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.updatesPerAgentStart,
                        ValueChanged = val => stageProperties.updatesPerAgentStart = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Specifies the number of updates per agent at the start before begining the simulation proper. Helps the physics engine get over the initial difficult calculations before everything settles.  If agents require settling (set in agent properties) they will be fixed in place for these frames."
                    },
                    new Setting
                    {
                        Name = "Frames Per Update Start",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.framesPerUpdateStart,
                        ValueChanged = val => stageProperties.framesPerUpdateStart = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the number of frames per agent update for the first few updates.  Helps the physics engine get over the initial difficult calculations before everything settles."
                    },
                    new Setting
                    {
                        Name = "Agent Start Spawn Gap",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.agentStartSpawnGap,
                        ValueChanged = val => stageProperties.agentStartSpawnGap = val,
                        Min = 1000,
                        Max = 10000,
                        Step = 500,
                        Details = "Defines the gap between agent spawns at the start.  Physics engine has a problem with too many agents stacked in 1 location, even with collisions disabled.  Agents are rendered in the same location regardless of start, and the map is duplicated but invisible for agents spread beyond the shown map."
                    },
                    new Setting
                    {
                        Name = "Velocity Calculations",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.velocityIteration,
                        ValueChanged = val => stageProperties.velocityIteration = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the number of velocity calculations per simulation tick. Shouldn't be adjusted too far, but you can increase how frequently position calculations are made, making the sim more accurate."
                    },
                    new Setting
                    {
                        Name = "Position Calculations",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.positionIteration,
                        ValueChanged = val => stageProperties.positionIteration = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the number of position calculations per simulation tick.  Shouldn't be adjusted too far, but you can increase how frequently position calculations are made, making the sim more accurate."
                    },
                    new Setting
                    {
                        Name = "Physics Granularity Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.physicsGranularityMultipliers,
                        ValueChanged = val => stageProperties.physicsGranularityMultipliers = val,
                        Min = 5,
                        Max = 20,
                        Step = 1,
                        Details = "Adjusts the granularity of physics calculations.  This setting can do some strange things if adjusted too far, but if you have CPU overhead, try increasing the granularity slightly."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
            Title = "Agent",
            Description = "Configure the properties of the agents.",
            Settings = new List<Setting>
            {
                new Setting
                {
                    Name = "Minimum Limbs",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.minLimbs,
                    ValueChanged = val => stageProperties.minLimbs = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Sets the minimum number of starting limbs for an agent. Agents can evolve beyond this."
                },
                new Setting
                {
                    Name = "Maximum Limbs",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.maxLimbs,
                    ValueChanged = val => stageProperties.maxLimbs = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Sets the maximum number of starting limbs for an agent. Agents can evolve beyond this."
                },
                new Setting
                {
                    Name = "Minimum Neural Network Layers",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.minNNLayers,
                    ValueChanged = val => stageProperties.minNNLayers = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Determines the minimum number of starting neural network layers in an agent. Agents can evolve beyond this."
                },
                new Setting
                {
                    Name = "Maximum Neural Network Layers",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.maxNNLayers,
                    ValueChanged = val => stageProperties.maxNNLayers = val,
                    Min = 1,
                    Max = 10,
                    Step = 1,
                    Details = "Determines the maximum number of starting neural network layers in an agent. Agents can evolve beyond this."
                },
                new Setting
                {
                    Name = "Starting Limb Chain Length",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.startingLimbChainLength,
                    ValueChanged = val => stageProperties.startingLimbChainLength = val,
                    Min = 1,
                    Max = 3,
                    Step = 1,
                    Details = "Sets how many sets of limbs agents start with.  1 set of limbs are attached directly to the body, and subsequent sets attach to previous limbs.  Agents can evolve beyond this"
                },
                new Setting
                {
                    Name = "Swim Strength",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.swimStrength,
                    ValueChanged = val => stageProperties.swimStrength = val,
                    Min = 0,
                    Max = 1000,
                    Step = 10,
                    Details = "Adjusts the swim strength of agents.  This is the agents main way of moving."
                },
                new Setting
                {
                    Name = "Swim Bias",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.swimBias,
                    ValueChanged = val => stageProperties.swimBias = val,
                    Min = 10,
                    Max = 20,
                    Step = 1,
                    Details = "Modifies the bias applied to swimming actions of agents.  Gives a slight advantage to forces in the same direction the agent is facing."
                },
                new Setting
                {
                    Name = "Random Agent Start Angle",
                    Type = SettingType.Checkbox,
                    BooleanValueExpression = () => stageProperties.randomAgentStartAngle,
                    BooleanValueChanged = val => stageProperties.randomAgentStartAngle = val,
                    Details = "Toggles whether agents start at a random angle between 0 and 90 (PI/2) deg or all facing the same direction, 45 (PI/4) deg."
                },
                new Setting
                {
                    Name = "Maximum Joint Speed",
                    Type = SettingType.Slider,
                    ValueExpression = () => stageProperties.maxJointSpeed,
                    ValueChanged = val => stageProperties.maxJointSpeed = val,
                    Min = 5,
                    Max = 20,
                    Step = 1,
                    Details = "Controls the maximum speed of joint movements for agents."
                },
                new Setting
                {
                    Name = "Swim Method",
                    Type = SettingType.Dropdown,
                    SelectedValueExpression = () => stageProperties.swimMethod,
                    SelectedValueChanged = val => stageProperties.swimMethod = val,
                    Options = new List<string> { "advanced", "simple" },
                    Details = "Selects the method used to calculate swim forces.  Advanced is more accurate, but simple is easier to learn.  Super simple sets the neural network output to a sign function, mapped to 1 or -1, limiting the choices the agent can make"
                },
                new Setting
                {
                    Name = "Body Plan",
                    Type = SettingType.Dropdown,
                    SelectedValueExpression = () => stageProperties.bodyPlanStart,
                    SelectedValueChanged = val => stageProperties.bodyPlanStart = val,
                    Options = new List<string> { "simple", "complex" },
                    Details = "Selects the starting body plan for agents.  Simple starts with 3 limbs arranged evenly and complex starts with random limbs"
                },
                new Setting
                {
                    Name = "Network Output",
                    Type = SettingType.Dropdown,
                    SelectedValueExpression = () => stageProperties.networkOutput,
                    SelectedValueChanged = val => stageProperties.networkOutput = val,
                    Options = new List<string> { "simple", "complex" },
                    Details = "Selects the activation function simplicity for the agents brains output layer.  Simple uses a sign function, mapping output to exactly -1 or 1, while complex is a tanh function (or otherwise selected in advanced settings), allowing any value between -1 and 1."
                },
                new Setting
                {
                    Name = "Keep Agent Symmetrical",
                    Type = SettingType.Checkbox,
                    BooleanValueExpression = () => stageProperties.keepAgentSymmetrical,
                    BooleanValueChanged = val => stageProperties.keepAgentSymmetrical = val,
                    Details = "Toggles whether agents are forced to be symmetrical throughout evolution.  Also forces limbs to move with their opposite."
                },
                new Setting
                {
                    Name = "Activation Function for Input Layer",
                    Type = SettingType.Dropdown,
                    SelectedValueExpression = () => stageProperties.inputActivationFunction,
                    SelectedValueChanged = val => stageProperties.inputActivationFunction = val,
                    Options = new List<string> { "relu", "sigmoid", "tanh", "linear", "softmax", "softplus", "softsign", "relu6", "elu", "selu", "leakyReLU", "prelu", "swish" },
                    Details = "Selects the activation function for the agents brain input layer. Linear: Preserves the original scale and distribution of the input data. ReLU/Sigmoid/Tanh: These are generally not recommended for the input layer, as they can distort the raw input data. For instance, ReLU would turn all negative inputs to zero."
                },
                new Setting
                {
                    Name = "Activation Function for Hidden Layers",
                    Type = SettingType.Dropdown,
                    SelectedValueExpression = () => stageProperties.hiddenActivationFunction,
                    SelectedValueChanged = val => stageProperties.hiddenActivationFunction = val,
                    Options = new List<string> { "relu", "sigmoid", "tanh", "linear", "softmax", "softplus", "softsign", "relu6", "elu", "selu", "leakyReLU", "prelu", "swish" },
                    Details = "Selects the activation function for the agents brains hidden layers. ReLU: The most common choice for hidden layers in deep networks due to its simplicity and efficiency. LeakyReLU, PReLU: Variants of ReLU that allow small gradients when the unit is not active, potentially avoiding dead neurons.  Tanh/Sigmoid: These can be used but are less common in deep networks due to the vanishing gradient problem. Swish, Selu, Elu: More sophisticated functions that can sometimes outperform ReLU in specific tasks."
                },
                new Setting
                {
                    Name = "Activation Function for Output Layer",
                    Type = SettingType.Dropdown,
                    SelectedValueExpression = () => stageProperties.outputActivationFunction,
                    SelectedValueChanged = val => stageProperties.outputActivationFunction = val,
                    Options = new List<string> { "relu", "sigmoid", "tanh", "linear", "softmax", "softplus", "softsign", "relu6", "elu", "selu", "leakyReLU", "prelu", "swish" },
                    Details = "Selects the activation function for the agents brain input layer  Most of these will not produce valid output in a useful range. Linear: Suitable for regression tasks where you need a wide range of output values. Sigmoid: Ideal for binary classification, as it maps the output to a probability between 0 and 1. Softmax: Used for multiclass classification problems. It outputs a probability distribution across multiple classes. ReLU: Not typically used in output layers, as they are not suited for probability prediction. Tanh: Could be used in a scenario where the output needs to be bounded between -1 and 1."
                },

            },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
{
                        Name = "Maximum Swim Force",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxForceMagnitude,
                        ValueChanged = val => stageProperties.maxForceMagnitude = val,
                        Min = 100,
                        Max = 10000,
                        Step = 50,
                        Details = "Sets the maximum force that can be applied to a limb"
                    },
                    new Setting
                    {
                        Name = "Max Torque Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxTorqueMultiplier,
                        ValueChanged = val => stageProperties.maxTorqueMultiplier = val,
                        Min = 100000,
                        Max = 500000,
                        Step = 10000,
                        Details = "Adjusts the maximum torque multiplier for agents."
                    },
                    new Setting
                    {
                        Name = "Limb Mass Force Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbMassForceDivider,
                        ValueChanged = val => stageProperties.limbMassForceDivider = val,
                        Min = 10,
                        Max = 100,
                        Step = 5,
                        Details = "Determines the force divider for limb mass."
                    },
                    new Setting
                    {
                        Name = "Limb Length Force Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbLengthForceDivider,
                        ValueChanged = val => stageProperties.limbLengthForceDivider = val,
                        Min = 10,
                        Max = 100,
                        Step = 5,
                        Details = "Sets the force divider based on the limb length."
                    },
                    new Setting
                    {
                        Name = "Agent Start X Position",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.agentStartX,
                        ValueChanged = val => stageProperties.agentStartX = val,
                        Min = 100,
                        Max = 1000,
                        Step = 50,
                        Details = "Initial X-axis position of the agent in the environment.  I have not tested what happens if this is changed."
                    },
                    new Setting
                    {
                        Name = "Agent Start Y Position",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.agentStartY,
                        ValueChanged = val => stageProperties.agentStartY = val,
                        Min = 100,
                        Max = 1000,
                        Step = 50,
                        Details = "Initial Y-axis position of the agent in the environment.  I have not tested what happens if this is changed."
                    },
                    new Setting
                    {
                        Name = "Swim Force Over N Frames",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.swimForceOverNFrames,
                        ValueChanged = val => stageProperties.swimForceOverNFrames = val,
                        Min = 1,
                        Max = 10,
                        Step = 1,
                        Details = "Number of frames over which swim force is applied calculated.  Higher values means forces are applied less often.  Too low of a value can result in too twitchy forces."
                    },
                    new Setting
                    {
                        Name = "Speed Force Normalizer",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.speedForceNormilizer,
                        ValueChanged = val => stageProperties.speedForceNormilizer = val,
                        Min = 1,
                        Max = 100,
                        Step = 1,
                        Details = "Adjusts the speed force normalizer for agents.  Higher values mean less force is applied for based on the limb speed vs it's area."
                    },
                    new Setting
                    {
                        Name = "Speed Normalization for Drag",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.speedNormalizationForDrag,
                        ValueChanged = val => stageProperties.speedNormalizationForDrag = val,
                        Min = 1000,
                        Max = 5000,
                        Step = 100,
                        Details = "Adjusts speed normalization factor for drag calculations.  Faster moving limbs experience more drag.  Smaller numbers here exaggerate  this effect."
                    },
                    new Setting
                    {
                        Name = "Body Angular Drag Power",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.bodyAngularDragPower,
                        ValueChanged = val => stageProperties.bodyAngularDragPower = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Controls the exponent for angular drag vs linear, since angular momentum seems to need more drag applied."
                    },
                    new Setting
                    {
                        Name = "Max Torque for Damping",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxTorqueForDamping,
                        ValueChanged = val => stageProperties.maxTorqueForDamping = val,
                        Min = 5000,
                        Max = 20000,
                        Step = 500,
                        Details = "Sets the maximum torque value for applying damping forces to agents limbs.  Should only apply when close to the limit of a joints movement.."
                    },
                    new Setting
                    {
                        Name = "Threshold Angle for Damping",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.threasholdAngleForDamping,
                        ValueChanged = val => stageProperties.threasholdAngleForDamping = val,
                        Min = 5,
                        Max = 20,
                        Step = 1,
                        Details = "Determines the threshold angle for applying damping forces to agents limbs.  Should only apply when close to the limit of a joints movement."
                    },
                    new Setting
                    {
                        Name = "Input Ticker Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.inputTickerRate,
                        ValueChanged = val => stageProperties.inputTickerRate = val,
                        Min = 1,
                        Max = 240,
                        Step = 15,
                        Details = "Determines the tick rate of the internal sign swap input.  This input makes oscillating outputs much easier to learn."
                    },
                    new Setting
                    {
                        Name = "Input Ticker",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputTicker,
                        BooleanValueChanged = val => stageProperties.inputTicker = val,
                        Details = "Enables or disables the internal ticker that switches between 1 and -1 every 60 frames."
                    },
                    new Setting
                    {
                        Name = "Input Joint Angle",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputJointAngle,
                        BooleanValueChanged = val => stageProperties.inputJointAngle = val,
                        Details = "Enables or disables the input of joint angles to the agent's brain."
                    },
                    new Setting
                    {
                        Name = "Input Joint Speed",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputJointSpeed,
                        BooleanValueChanged = val => stageProperties.inputJointSpeed = val,
                        Details = "Determines if joint speed information is fed into the agent's brain."
                    },
                    new Setting
                    {
                        Name = "Input Agent Position",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputAgentPos,
                        BooleanValueChanged = val => stageProperties.inputAgentPos = val,
                        Details = "Controls whether the agent's position is used as input to its brain."
                    },
                    new Setting
                    {
                        Name = "Input Agent Velocity",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputAgentV,
                        BooleanValueChanged = val => stageProperties.inputAgentV = val,
                        Details = "Enables or disables the use of agent velocity as a brain input."
                    },
                    new Setting
                    {
                        Name = "Input Current Score",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputScore,
                        BooleanValueChanged = val => stageProperties.inputScore = val,
                        Details = "Determines if the agent's current score is input to the brain."
                    },
                    new Setting
                    {
                        Name = "Input Orientation",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputOrientation,
                        BooleanValueChanged = val => stageProperties.inputOrientation = val,
                        Details = "Toggles whether the agent's orientation is an input for its brain."
                    },
                    new Setting
                    {
                        Name = "Input Time Remaining",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputTimeRemaining,
                        BooleanValueChanged = val => stageProperties.inputTimeRemaining = val,
                        Details = "Allows the remaining time to be an input parameter to the agent's brain."
                    },
                    new Setting
                    {
                        Name = "Input Distance Sensors",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.inputDistanceSensors,
                        BooleanValueChanged = val => stageProperties.inputDistanceSensors = val,
                        Details = "Enables distance sensors as inputs to the agent's decision-making process."
                    },
                    new Setting
                    {
                        Name = "Output Joint Speed",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.outputsJointSpeed,
                        BooleanValueChanged = val => stageProperties.outputsJointSpeed = val,
                        Details = "Controls if the agent's brain can output joint speed commands."
                    },
                    new Setting
                    {
                        Name = "Output Joint Torque",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.outputsJointTorque,
                        BooleanValueChanged = val => stageProperties.outputsJointTorque = val,
                        Details = "Determines whether the brain can output joint torque instructions."
                    },
                    new Setting
                    {
                        Name = "Output Bias",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.outputsBias,
                        BooleanValueChanged = val => stageProperties.outputsBias = val,
                        Details = "Enables or disables the output of bias values for swim forces from the agent's brain."
                    }
                    // public bool brainDecayOverTime { get; set; } = false; // Not implemented
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "Score and Energy",
                Description = "Configure the scoring and energy systems.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "X-Axis Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.xScoreMultiplier,
                        ValueChanged = val => stageProperties.xScoreMultiplier = val,
                        Min = 0,
                        Max = 1000,
                        Step = 1,
                        Details = "Multiplier for the score gained when moving along the X-axis."
                    },
                    new Setting
                    {
                        Name = "Y-Axis Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.yScoreMultiplier,
                        ValueChanged = val => stageProperties.yScoreMultiplier = val,
                        Min = 0,
                        Max = 1000,
                        Step = 1,
                        Details = "Multiplier for the score gained when moving along the Y-axis."
                    },
                    new Setting
                    {
                        Name = "Joint Movement Score",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.movementScoreMultiplier,
                        ValueChanged = val => stageProperties.movementScoreMultiplier = val,
                        Min = 0,
                        Max = 1000,
                        Step = 1,
                        Details = "Multiplier for the score bonus given based on agent's joint movements.  Helps to encourage more active agents to evolve early on.  This bonus diminishes for each movement made."
                    },
                    new Setting
                    {
                        Name = "Exploration Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.explorationScoreMultiplier,
                        ValueChanged = val => stageProperties.explorationScoreMultiplier = val,
                        Min = 0,
                        Max = 1000,
                        Step = 1,
                        Details = "Multiplier for the score based on the number of cells explored in the agents internal map.  This encourages agents to explore less obvious paths."
                    },
                    new Setting
                    {
                        Name = "Size Score Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.sizeScoreMultiplier,
                        ValueChanged = val => stageProperties.sizeScoreMultiplier = val,
                        Min = 0,
                        Max = 1000,
                        Step = 1,
                        Details = "Multiplier for the score bonus based on agent's size."
                    },
                    new Setting
                    {
                        Name = "Dynamic Mass Bonus",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.massBonusIsDynamic,
                        BooleanValueChanged = val => stageProperties.massBonusIsDynamic = val,
                        Details = "Toggles between a fixed score bonus for being larger vs a score bonus for moving a larger body further."
                    },
                    new Setting
                    {
                        Name = "Starting Energy Base",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.startingEnergyBase,
                        ValueChanged = val => stageProperties.startingEnergyBase = val,
                        Min = 0,
                        Max = 1000,
                        Step = 1,
                        Details = "Base energy level for agents at the start."
                    },
                    new Setting
                    {
                        Name = "Starting Energy Mass Power",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.startingEnergyMassPower,
                        ValueChanged = val => stageProperties.startingEnergyMassPower = val,
                        Min = 0,
                        Max = 10,
                        Step = 1,
                        Details = "Determines the exponent used for calculating agent starting energy based on mass"
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Starting Energy Body Mass Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.startingEnergyBodyMassMult,
                        ValueChanged = val => stageProperties.startingEnergyBodyMassMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for starting energy based on body mass."
                    },
                    new Setting
                    {
                        Name = "Starting Energy Limb Mass Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.startingEnergyLimbMassMult,
                        ValueChanged = val => stageProperties.startingEnergyLimbMassMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for starting energy based on limb mass."
                    },
                    new Setting
                    {
                        Name = "Energy Use Force Size Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.energyUseForceSizeMult,
                        ValueChanged = val => stageProperties.energyUseForceSizeMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for energy use based on force size."
                    },
                    new Setting
                    {
                        Name = "Energy Use Force Size Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.energyUseLimbSizeMult,
                        ValueChanged = val => stageProperties.energyUseLimbSizeMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for energy use based on force size."
                    },
                    new Setting
                    {
                        Name = "Energy Use Force Size Multiplier",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.energyUseBrainSizeMult,
                        ValueChanged = val => stageProperties.energyUseBrainSizeMult = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Multiplier for energy use based on force size."
                    },
                    new Setting
                    {
                        Name = "Limb Mass Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbMassEnergyReductionDivider,
                        ValueChanged = val => stageProperties.limbMassEnergyReductionDivider = val,
                        Min = 10,
                        Max = 50,
                        Step = 5,
                        Details = "Normalization divider for energy reduction based on limb mass."
                    },
                    new Setting
                    {
                        Name = "Limb Mass Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbMassEnergyReductionDivider,
                        ValueChanged = val => stageProperties.limbMassEnergyReductionDivider = val,
                        Min = 10,
                        Max = 50,
                        Step = 5,
                        Details = "Normalization divider for energy reduction based on limb mass."
                    },
                    new Setting
                    {
                        Name = "Brain Size Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.brainSizeEnergyReductionDivider,
                        ValueChanged = val => stageProperties.brainSizeEnergyReductionDivider = val,
                        Min = 50,
                        Max = 150,
                        Step = 10,
                        Details = "Normalization divider for energy reduction based on brain size."
                    },
                    new Setting
                    {
                        Name = "Force Magnitude Energy Reduction Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.forceMagnitudeEnergyReductionDivider,
                        ValueChanged = val => stageProperties.forceMagnitudeEnergyReductionDivider = val,
                        Min = 500000,
                        Max = 1500000,
                        Step = 100000,
                        Details = "Normalization divider for energy reduction based on force magnitude."
                    },
                    new Setting
                    {
                        Name = "Body Starting Mass Energy Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.bodyStartingMassEnergyReductionDivider,
                        ValueChanged = val => stageProperties.bodyStartingMassEnergyReductionDivider = val,
                        Min = 0,
                        Max = 1000,
                        Step = 50,
                        Details = "Normalization divider for energy based on body starting mass."
                    },
                    new Setting
                    {
                        Name = "Limb Starting Mass Energy Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.limbStartingMassEnergyReductionDivider,
                        ValueChanged = val => stageProperties.limbStartingMassEnergyReductionDivider = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "Normalization divider for energy based on limb starting mass."
                    },
                    new Setting
                    {
                        Name = "Joint Movement Reward Limb Mass Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.jointMovementRewardLimbMassDivider,
                        ValueChanged = val => stageProperties.jointMovementRewardLimbMassDivider = val,
                        Min = 50,
                        Max = 150,
                        Step = 10,
                        Details = "Normalization divider for calculating joint movement reward based on limb mass."
                    },
                    new Setting
                    {
                        Name = "Internal Map Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.internalMapSize,
                        ValueChanged = val => stageProperties.internalMapSize = val,
                        Min = 100,
                        Max = 1000,
                        Step = 100,
                        Details = "Size of the internal map used in agents brains."
                    },
                    new Setting
                    {
                        Name = "Internal Map Cell Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.internalMapCellSize,
                        ValueChanged = val => stageProperties.internalMapCellSize = val,
                        Min = 10,
                        Max = 100,
                        Step = 10,
                        Details = "Size of each cell in the internal map."
                    },
                    new Setting
                    {
                        Name = "Dynamic Mass Bonus Divider",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.dynamicMassBonusDivider,
                        ValueChanged = val => stageProperties.dynamicMassBonusDivider = val,
                        Min = 100,
                        Max = 1000,
                        Step = 100,
                        Details = "Normalization divider for dynamic mass bonus calculation."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "Training",
                Description = "Configure the training and evolution systems.  These settings will have a large impact on how quickly agents can learn, and how diverse the groups are.  Small changes are recommended.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Offspring Mutation Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.offspringMutationRate,
                        ValueChanged = val => stageProperties.offspringMutationRate = val,
                        Min = 0,
                        Max = 10000,
                        Step = 1,
                        Details = "Adjusts the mutation rate for agents brains. This number is divided by 10000.  How likely each value is to mutate, weights and biases."
                    },
                    new Setting
                    {
                        Name = "Node Mutation Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.offspringNodeMutationRate,
                        ValueChanged = val => stageProperties.offspringNodeMutationRate = val,
                        Min = 0,
                        Max = 10000,
                        Step = 1,
                        Details = "Adjusts the neural network node mutation rate. This number is divided by 10000.  This is how frequently agents brains can gain or loose nodes."
                    },
                    new Setting
                    {
                        Name = "Layer Mutation Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.offspringLayerMutationRate,
                        ValueChanged = val => stageProperties.offspringLayerMutationRate = val,
                        Min = 0,
                        Max = 10000,
                        Step = 1,
                        Details = "Adjusts the neural network layer mutation rate. This number is divided by 10000.  This is how frequently agents brains can gain or loose a layer.  This process can interrupt learning, but produces a greater range of agents."
                    },
                    new Setting
                    {
                        Name = "Limb Mutation Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.offspringLimbMutationRate,
                        ValueChanged = val => stageProperties.offspringLimbMutationRate = val,
                        Min = 0,
                        Max = 10000,
                        Step = 1,
                        Details = "Adjusts the limb mutation rate.  This number is divided by 10000.  Higher numbers will see more diverse agents with different body plans, but it will take longer to learn how to use limbs if they change conatsntly."
                    },
                    new Setting
                    {
                        Name = "Top Performer Number",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.topPerformerNumber,
                        ValueChanged = val => stageProperties.topPerformerNumber = val,
                        Min = 0,
                        Max = 100,
                        Step = 1,
                        Details = "Sets the percentage of top performers to keep per group.  Top performers have a small chance to mutate but otherwise are kept unchanged.  A higher value will see faster learning, but less diverse as agents quickly converge."
                    },
                    new Setting
                    {
                        Name = "Migration Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.migrationRate,
                        ValueChanged = val => stageProperties.migrationRate = val,
                        Min = 0,
                        Max = 1000,
                        Step = 1,
                        Details = "Determines the rate of migration between species or population groups.  A lower number will mean more diverse agents between groups, but it's less common for useful traits to be shared between groups."
                    },
                    new Setting
                    {
                        Name = "Minimum Population Group Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.minPopGroupSize,
                        ValueChanged = val => stageProperties.minPopGroupSize = val,
                        Min = 5,
                        Max = 20,
                        Step = 1,
                        Details = "If the total number of agents does not divide property by the Max group size, this is the smallest a group can be before creating a new group."
                    },
                    new Setting
                    {
                        Name = "Maximum Population Group Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxPopGroupSize,
                        ValueChanged = val => stageProperties.maxPopGroupSize = val,
                        Min = 20,
                        Max = 50,
                        Step = 1,
                        Details = "Sets the maximum size of a population group.  The total number of agents is divided by this to get the number of species / population groups"
                    },
                    new Setting
                    {
                        Name = "Agents Require Stabilizing",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.agentsRequireStablising,
                        BooleanValueChanged = val => stageProperties.agentsRequireStablising = val,
                        Details = "Determines if agents require stabilization before the round begins.  Using this can help performance in the first few frames, and can also encourage more robust learning in agents, as they cant just push off and glide for the first move.  It will also slow training initially as their first action is wasted."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Tournament Size",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.tournamentSize,
                        ValueChanged = val => stageProperties.tournamentSize = val,
                        Min = 1,
                        Max = 50,
                        Step = 1,
                        Details = "Sets the number of agents randomly picked for tournament selection within tournament parent selector."
                    },
                    new Setting
                    {
                        Name = "Linear Stability Threshold for Body",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.linearStabilityThresholdBody,
                        ValueChanged = val => stageProperties.linearStabilityThresholdBody = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Determines the linear stability threshold for the agent's body."
                    },
                    new Setting
                    {
                        Name = "Angular Stability Threshold for Body",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.angularStabilityThresholdBody,
                        ValueChanged = val => stageProperties.angularStabilityThresholdBody = val,
                        Min = 1,
                        Max = 20,
                        Step = 1,
                        Details = "Determines the angular stability threshold for the agent's body."
                    },
                    new Setting
                    {
                        Name = "Angular Stability Threshold for Limb",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.angularStabilityThresholdLimb,
                        ValueChanged = val => stageProperties.angularStabilityThresholdLimb = val,
                        Min = 0,
                        Max = 20,
                        Step = 1,
                        Details = "Determines the angular stability threshold for the agent's limbs."
                    },
                    new Setting
                    {
                        Name = "Stability Frames",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.stabilityFrames,
                        ValueChanged = val => stageProperties.stabilityFrames = val,
                        Min = 0,
                        Max = 60,
                        Step = 1,
                        Details = "Sets the number of frames agents must be stable for before starting round."
                    },
                    new Setting
                    {
                        Name = "Stability Check Overwrite",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.stabilityCheckOverwriteFrames,
                        ValueChanged = val => stageProperties.stabilityCheckOverwriteFrames = val,
                        Min = 100,
                        Max = 1000,
                        Step = 50,
                        Details = "Sets the number of frames to wait before overwriting the stability check.  Prevents sim never starting if agents never settle"
                    },
                    new Setting
                    {
                        Name = "Include Top Performer in Mutation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.chanceToIncludeTopPerformerInMutation,
                        ValueChanged = val => stageProperties.chanceToIncludeTopPerformerInMutation = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "The probability of including top performers in mutation processes."
                    },
                    new Setting
                    {
                        Name = "Include Offspring in Mutation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.chanceToIncludeOffspringInMutation,
                        ValueChanged = val => stageProperties.chanceToIncludeOffspringInMutation = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "The probability of including offspring in mutation processes."
                    },
                    new Setting
                    {
                        Name = "Neuron Mutation Standard Deviation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.neuronMutationStandardDeviation,
                        ValueChanged = val => stageProperties.neuronMutationStandardDeviation = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "The standard deviation use for neuron mutation.  A larger value means larger mutations. This value is divided by 100."
                    },
                    new Setting
                    {
                        Name = "Body Plan Mutation Standard Deviation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.bodyPlanMutationStandardDeviation,
                        ValueChanged = val => stageProperties.bodyPlanMutationStandardDeviation = val,
                        Min = 0,
                        Max = 100,
                        Step = 5,
                        Details = "The standard deviation used for body plan mutation.  A larger value means larger mutations. This value is divided by 100."
                    },

                    // Checked up to here so far, from the bottom

                    new Setting
                    {
                        Name = "Max Position for Normalisation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxPosForNormalisation,
                        ValueChanged = val => stageProperties.maxPosForNormalisation = val,
                        Min = 1000,
                        Max = 10000,
                        Step = 500,
                        Details = "Maximum position value for normalisation for agents neural network / brain input."
                    },
                    new Setting
                    {
                        Name = "Max Velocity for Normalisation",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxVelForNormalisation,
                        ValueChanged = val => stageProperties.maxVelForNormalisation = val,
                        Min = 10,
                        Max = 100,
                        Step = 5,
                        Details = "Maximum velocity value for normalisation for agents neural network / brain input."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "World",
                Description = "Configure properties like the round length, the viscosity of the environment and the map.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "timeIncrease",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.timeIncrease,
                        BooleanValueChanged = val => stageProperties.timeIncrease = val,
                        Details = "Toggles whether to increase the time agents are given per round, increasing per generation.  If disabled, I recommended setting a longer round length."
                    },
                    new Setting
                    {
                        Name = "Starting Round Length",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.SimulationLength,
                        ValueChanged = val => stageProperties.SimulationLength = val,
                        Min = 100,
                        Max = 500000,
                        Step = 50,
                        Details = "Adjusts the length of the round in ticks.  2000 ticks is about 40 seconds depending on frame rate."
                    },
                    new Setting
                    {
                        Name = "agentInCentre",
                        Type = SettingType.Dropdown,
                        SelectedValueExpression = () => stageProperties.agentInCentre,
                        SelectedValueChanged = val => stageProperties.agentInCentre = val,
                        Options = new List<string> { "leader", "trailer", "average" },
                        Details = "Selects the agent to focus the camera on.  Best toggled with the top right button bank."
                    },
                    new Setting
                    {
                        Name = "Liquid Viscosity",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.liquidViscosity,
                        ValueChanged = val => stageProperties.liquidViscosity = val,
                        Min = 0,
                        Max = 100,
                        Step = 1,
                        Details = "Adjusts the viscosity of the liquid in the world.  This number is divided by 10000 then adjusted for speed, and taken from 1 to create a drag multiple, which all agent velocities are multiplied by every frame.  This property does not give the agents pushing forces on limbs, thats handled elsewhere."
                    },
                    new Setting
                    {
                        Name = "Starting Map",
                        Type = SettingType.Dropdown,
                        SelectedValueExpression = () => stageProperties.map.ToString(),
                        SelectedValueChanged = val => stageProperties.map = int.Parse(val),
                        Options = new List<string> { "1", "2", "3", "4", "5" },
                        Details = "Select the map to start the simulation on. If 'Random Map' is toggled off, this selects the map for the duration of training."
                    },
                    new Setting
                    {
                        Name = "Random Map",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.randomMap,
                        BooleanValueChanged = val => stageProperties.randomMap = val,
                        Details = "Toggles the use of a random map in the simulation.  Using the same map makes it easier to learn as some maps have a different start, but makes learning less general."
                    },
                },
                AdvancedSettings = new List<Setting>
                {
                    // public float Gravity { get; set; } = 1; // not implemented
                    // public double Friction { get; set; } = 0.4; // not implemented
                    new Setting
                    {
                        Name = "Canvas Width",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.Width,
                        ValueChanged = val => stageProperties.Width = val,
                        Min = 800,
                        Max = 2400,
                        Step = 50,
                        Details = "Sets the width of the canvas used to host the simulation.  I've not tested this so it will have strange effects."
                    },
                    new Setting
                    {
                        Name = "Canvas Height",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.Height,
                        ValueChanged = val => stageProperties.Height = val,
                        Min = 400,
                        Max = 1200,
                        Step = 50,
                        Details = "Sets the height of the canvas used to host the simulation.  I've not tested this so it will have strange effects."
                    },
                    new Setting
                    {
                        Name = "Ground Level",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.GroundY,
                        ValueChanged = val => stageProperties.GroundY = val,
                        Min = 500,
                        Max = 900,
                        Step = 10,
                        Details = "Adjusts the Y-coordinate of the ground level.  I've not tested this at all, but it might do something?"
                    },
                    new Setting
                    {
                        Name = "Round Length Increase",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.simulationLengthIncrease,
                        ValueChanged = val => stageProperties.simulationLengthIncrease = val,
                        Min = 5,
                        Max = 1000,
                        Step = 5,
                        Details = "Increases the simulation length incrementally by this amount per generation."
                    },
                    new Setting
                    {
                        Name = "Max Round Length",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.maxSimulationLength,
                        ValueChanged = val => stageProperties.maxSimulationLength = val,
                        Min = 10000,
                        Max = 100000,
                        Step = 1000,
                        Details = "Sets the maximum limit for the simulation length.  By default its about 15 minutes"
                    },
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "Visualizations",
                Description = "Configure the visualization and UI, including which agents are rendered.  Most of these are background settings that don't need to be touched but if you have a hard time seeing some colours, or cant fit elements on the screen, you can adjust that here.  If you toggle off all graphs, the axis should disappear.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Rendered Agents",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.renderedAgents,
                        ValueChanged = val => stageProperties.renderedAgents = val,
                        Min = 0,
                        Max = 50,
                        Step = 1,
                        Details = "Controls the number of random agents rendered from each group, independent of the leaders and trailer.  This only updates between rounds."
                    },
                    new Setting
                    {
                        Name = "Show Leading Agent",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showLeadingAgent,
                        BooleanValueChanged = val => stageProperties.showGroupTrailers = val,
                        Details = "Toggle to show or hide the leading agent.  If group leaders are also shown, this has no effect."
                    },
                    new Setting
                    {
                        Name = "Show Group Leaders",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showGroupLeaders,
                        BooleanValueChanged = val => stageProperties.showGroupLeaders = val,
                        Details = "Toggle to show or hide group leaders in the simulation."
                    },
                    new Setting
                    {
                        Name = "Show Trailing Agent",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showGroupTrailers,
                        BooleanValueChanged = val => stageProperties.showGroupTrailers = val,
                        Details = "Toggle to show or hide the trailing agent."
                    },
                    new Setting
                    {
                        Name = "Show Graph of the Score History",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showScoreHistory,
                        BooleanValueChanged = val => stageProperties.showScoreHistory = val,
                        Details = "Toggle to show or hide a graph of the top score that round over time."
                    },
                    new Setting
                    {
                        Name = "Show Graph of the Average Score History",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showAverageScoreHistory,
                        BooleanValueChanged = val => stageProperties.showAverageScoreHistory = val,
                        Details = "Toggle to show or hide a graph of the average score over time."
                    },
                    new Setting
                    {
                        Name = "Show Graph of the Top Score History",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showTopScoreHistory,
                        BooleanValueChanged = val => stageProperties.showTopScoreHistory = val,
                        Details = "Toggle to show or hide a graph of the top score ever over time."
                    },
                    new Setting
                    {
                        Name = "Agent in Centre",
                        Type = SettingType.Dropdown,
                        SelectedValueExpression = () => stageProperties.agentInCentre,
                        SelectedValueChanged = val => stageProperties.agentInCentre = val,
                        Options = new List<string> { "leader", "trailer", "average" },
                        Details = "Selects the agent to focus the camera on.  Best toggled using the button bank in the top right."
                    },
                    new Setting
                    {
                        Name = "Background Red",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.backgroundRed,
                        ValueChanged = val => stageProperties.backgroundRed = val,
                        Min = 0,
                        Max = 255,
                        Step = 1,
                        Details = "Adjusts the red component of the background color."
                    },
                    new Setting
                    {
                        Name = "Background Green",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.backgroundGreen,
                        ValueChanged = val => stageProperties.backgroundGreen = val,
                        Min = 0,
                        Max = 255,
                        Step = 1,
                        Details = "Adjusts the green component of the background color."
                    },
                    new Setting
                    {
                        Name = "Background Blue",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.backgroundBlue,
                        ValueChanged = val => stageProperties.backgroundBlue = val,
                        Min = 0,
                        Max = 255,
                        Step = 1,
                        Details = "Adjusts the blue component of the background color."
                    },
                    new Setting
                    {
                        Name = "Background Particles",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.backgroundParticles,
                        ValueChanged = val => stageProperties.backgroundParticles = val,
                        Min = 0,
                        Max = 500,
                        Step = 10,
                        Details = "Controls the number of particles in the background."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Show Neural Network",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showNN,
                        BooleanValueChanged = val => stageProperties.showNN = val,
                        Details = "Toggles the visibility of the neural network representation.  Off by default as it can use a fair amount of memory.  I recommend only toggling it temporally using the top right button bank."
                    },
                    new Setting
                    {
                        Name = "Show Agents Vision",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showRays,
                        BooleanValueChanged = val => stageProperties.showRays = val,
                        Details = "Controls whether rays used for sensing the environment are displayed for the focused agent."
                    },
                    new Setting
                    {
                        Name = "UI Refresh Rate",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.uiRefreshRate,
                        ValueChanged = val => stageProperties.uiRefreshRate = val,
                        Min = 100,
                        Max = 1000,
                        Step = 50,
                        Details = "Adjusts the refresh rate of the on screen information and the neural network.  Also how often the sim speed is adjusted if enabled."
                    },
                    new Setting
                    {
                        Name = "NN Layer Gap",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.renderedNNLayerGap,
                        ValueChanged = val => stageProperties.renderedNNLayerGap = val,
                        Min = 50,
                        Max = 200,
                        Step = 10,
                        Details = "Sets the gap between layers in the rendered neural network."
                    },
                    new Setting
                    {
                        Name = "NN Node Gap",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.renderedNNNodeGap,
                        ValueChanged = val => stageProperties.renderedNNNodeGap = val,
                        Min = 20,
                        Max = 100,
                        Step = 5,
                        Details = "Defines the spacing between nodes in each neural network layer."
                    }
                },
                HasAdvanced = true
            },
            new TabModel
            {
                Title = "Debugging",
                Description = "Configure settings for debugging and diagnostics.  Mostly settings for visualizing swimming forces.",
                Settings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Show Force Vectors",
                        Type = SettingType.Checkbox,
                        BooleanValueExpression = () => stageProperties.showForceVectors,
                        BooleanValueChanged = val => stageProperties.showForceVectors = val,
                        Details = "Enables or disables the display of force vectors on agents."
                    }
                },
                AdvancedSettings = new List<Setting>
                {
                    new Setting
                    {
                        Name = "Visual Force Scale",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.visualForceScale,
                        ValueChanged = val => stageProperties.visualForceScale = val,
                        Min = 10,
                        Max = 100,
                        Step = 1,
                        Details = "Adjusts the scale of visual representation of forces."
                    },
                    new Setting
                    {
                        Name = "Max Force Arrow",
                        Type = SettingType.Slider,
                        ValueExpression = () => stageProperties.visualMaxForceLength,
                        ValueChanged = val => stageProperties.visualMaxForceLength = val,
                        Min = 100,
                        Max = 500,
                        Step = 10,
                        Details = "Sets the maximum length for force vector visualization arrow."
                    }
                },
                HasAdvanced = true
            },
        };
    }
}

