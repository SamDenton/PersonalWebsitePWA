@page "/EvolutionTFNEAT"
@inject IJSRuntime JSRuntime

<h2>Semi-NEAT Genetic Evolution Simulation</h2>
<p>You will get the best results with more agents, and higher muscle update frequencies, it will take some fiddling with performance settings to get a stable frame rate, with the highest values possible</p>
<p>Beta product, please be patient. This works on mobile, but I recommend very low settings</p>
<div id="canvas-container-NEAT"></div>

<div class="settings-container">
    <div class="settings-section">
        <h2>Performance Settings</h2>

        <!-- Number of Agents -->
        <div class="setting">
            <label for="numAgents" title="Total number of agents in the simulation.">Number of Agents</label>
            <div class="slider-container">
                <input type="range" id="numAgents" @bind="stageProperties.numAgents" min="10" max="1000" step="1">
                <input type="number" @bind="stageProperties.numAgents" min="2" max="1000" step="1">
            </div>
        </div>

        <!-- Agents updated per batch -->
        <div class="setting">
            <label for="muscleBatch" title="Update this many agents muscles, wait, then move to next batch.  Setting this equal to the population size will update every agent, every update cycle">Agents Per Batch of Joint Updates</label>
            <div class="slider-container">
                <input type="range" id="muscleBatch" @bind="stageProperties.muscleBatch" min="1" max="500" step="1">
                <input type="number" @bind="stageProperties.muscleBatch" min="1" max="500" step="1">
            </div>
        </div>

        <!-- Frames per batch -->
        <div class="setting">
            <label for="muscleDelay" title="1 means no delay between batches">Delay Between Batch of Joint Updates (frames)</label>
            <div class="slider-container">
                <input type="range" id="muscleDelay" @bind="stageProperties.muscleDelay" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.muscleDelay" min="1" max="50" step="1">
            </div>
        </div>

        <!-- Frames between muscle update rounds -->
        <div class="setting">
            <label for="totalMuscleUpdateTime" title="Frames between muscle update rounds. Combines with muscle batching.">Delay Between Muscle Update Rounds (frames)</label>
            <div class="slider-container">
                <input type="range" id="totalMuscleUpdateTime" @bind="stageProperties.totalMuscleUpdateTime" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.totalMuscleUpdateTime" min="1" max="50" step="1">
            </div>
        </div>

        <!-- Physics Speed -->
        <div class="setting">
            <label for="simSpeed" title="Physics Speed, the number of physics ticks per 60 rendered frames, approx 1 second (try slower speeds on slow computers).">Physics Updates Per Second (at 60 fps)</label>
            <div class="slider-container">
                <input type="range" id="simSpeed" @bind="stageProperties.simSpeed" min="6" max="480" step="6">
                <input type="number" @bind="stageProperties.simSpeed" min="6" max="480" step="6">
            </div>
        </div>

        <!-- Spawn Batch Size -->
        <div class="setting">
            <label for="BatchSize" title="Spawn agents in batches of this many.  Helps to distribute calculations over a few seconds">Spawn Batch Size</label>
            <div class="slider-container">
                <input type="range" id="BatchSize" @bind="stageProperties.BatchSize" min="1" max="200" step="1">
                <input type="number" @bind="stageProperties.BatchSize" min="1" max="200" step="1">
            </div>
        </div>

        <!-- Spawn Delay Between batches -->
        <div class="setting">
            <label for="delay" title="Spawn Delay Between batches (ms), more delay smooths out resource spikes when loading agents.">Spawn Delay Between Batches (ms)</label>
            <div class="slider-container">
                <input type="range" id="delay" @bind="stageProperties.delay" min="0" max="200" step="1">
                <input type="number" @bind="stageProperties.delay" min="0" max="200" step="1">
            </div>
        </div>

    </div>

    <div class="settings-section">
        <h2>Agent Properties</h2>

        <!-- Number of limbs per agent -->
        <div class="setting">
            <label for="numLimbs" title="Number of limbs per agent.">Number of Limbs per Agent</label>
            <div class="slider-container">
                <input type="range" id="numLimbs" @bind="agentProperties.numLimbs" min="1" max="20" step="1">
                <input type="number" @bind="agentProperties.numLimbs" min="1" max="20" step="1">
            </div>
        </div>

        <!-- Max Joint Speed -->
        <div class="setting">
            <label for="maxJointSpeed" title="Maximum joint speed.">Max Joint Speed</label>
            <div class="slider-container">
                <input type="range" id="maxJointSpeed" @bind="agentProperties.maxJointSpeed" min="0.5" max="5" step="0.5">
                <input type="number" @bind="agentProperties.maxJointSpeed" min="0.5" max="5" step="0.5">
            </div>
        </div>

        <!-- Number of limbs per agent -->
        <div class="setting">
            <label for="musculeTorque" title="Number of limbs per agent.">Max Torque Per Joint</label>
            <div class="slider-container">
                <input type="range" id="musculeTorque" @bind="agentProperties.musculeTorque" min="50000.0" max="5000000.0" step="5000.0">
                <input type="number" @bind="agentProperties.musculeTorque" min="50000.0" max="5000000.0" step="5000.0">
            </div>
        </div>

        <!-- Mutation rate, to by replaced -->
        <div class="setting">
            <label for="offspringMutationRate" title="Number of limbs per agent.">Mutation rate, also updates over time</label>
            <div class="slider-container">
                <input type="range" id="offspringMutationRate" @bind="agentProperties.offspringMutationRate" min="0.01" max="50" step="0.01">
                <input type="number" @bind="agentProperties.offspringMutationRate" min="0.01" max="50" step="0.01">
            </div>
        </div>

        <!-- Max limb movement -->
        <div class="setting">
            <label for="maxJointMoveDivider" title="Number of limbs per agent.">Joint Movement Restriction (0 means no restriction, 2 means half their possible movement)</label>
            <div class="slider-container">
                <input type="range" id="maxJointMoveDivider" @bind="agentProperties.maxJointMoveDivider" min="0" max="8" step="0.1">
                <input type="number" @bind="agentProperties.maxJointMoveDivider" min="0" max="8" step="0.1">
            </div>
        </div>

        <!-- liquid Viscosity -->
        <div class="setting">
            <label for="liquidViscosity" title="Movement decay factor for agents">Liquid Enviroment Viscocity</label>
            <div class="slider-container">
                <input type="range" id="liquidViscosity" @bind="stageProperties.liquidViscosity" min="0.9" max="1" step="0.001">
                <input type="number" @bind="stageProperties.liquidViscosity" min="0.9" max="1" step="0.001">
            </div>
        </div>

        <!-- swim Strength -->
        <div class="setting">
            <label for="swimStrength" title="Multiplier on the force applied to each limb for agent swimming">Swim Strength</label>
            <div class="slider-container">
                <input type="range" id="swimStrength" @bind="agentProperties.swimStrength" min="100000" max="50000000" step="10000">
                <input type="number" @bind="agentProperties.swimStrength" min="100000" max="50000000" step="10000">
            </div>
        </div>

        <!-- Max limb movement -->
        <div class="setting">
            <label for="swimBias" title="Adds a slight bias in the force applied, so 'limb strokes' apply more force than retuning to starting position, based on left right split of limbs on body">Swim Bias</label>
            <div class="slider-container">
                <input type="range" id="swimBias" @bind="agentProperties.swimBias" min="1" max="2" step="0.01">
                <input type="number" @bind="agentProperties.swimBias" min="1" max="2" step="0.01">
            </div>
        </div>

        <!-- Input List -->
        <div class="setting">

            <p title="Select the inputs available to the agents">Agent Input Selection</p>

            <label for="inputJointAngle" title="The current angle of each joint relative to the main body">Joint Angle</label>
            <input type="checkbox" id="inputJointAngle" @bind="agentProperties.inputJointAngle" />

            <label for="inputJointSpeed" title="The current speed of the joint/limb">Joint/Limb Speed</label>
            <input type="checkbox" id="inputJointSpeed" @bind="agentProperties.inputJointSpeed" />

            <label for="inputAgentPos" title="The agents position in the world">Agents Position</label>
            <input type="checkbox" id="inputAgentPos" @bind="agentProperties.inputAgentPos" />

            <label for="inputAgentV" title="The current velocity of the agent">Agent Velocity</label>
            <input type="checkbox" id="inputAgentV" @bind="agentProperties.inputAgentV" />

            <label for="inputScore" title="The agents current score">Current score</label>
            <input type="checkbox" id="inputScore" @bind="agentProperties.inputScore" />

            <label for="inputOrientation" title="Agents current orientation in the world">Agents MainBody Orientation</label>
            <input type="checkbox" id="inputOrientation" @bind="agentProperties.inputOrientation" />

            <label for="inputTimeRemaining" title="The time left in this round">Time Remaining</label>
            <input type="checkbox" id="inputTimeRemaining" @bind="agentProperties.inputTimeRemaining" />

            <label for="inputDistanceSensors" title="Sensors for distance from agent to closest object in 8 directions">Distance to object Sensors</label>
            <input type="checkbox" id="inputDistanceSensors" @bind="agentProperties.inputDistanceSensors" />

        </div>

        <!-- Output List -->
        <div class="setting">
            <p title="Select the outputs available to the agents">Agent Output Selection</p>

            <label for="outputsJointSpeed" title="The speed the angle is moving at">Joint Speed</label>
            <input type="checkbox" id="outputsJointSpeed" @bind="agentProperties.outputsJointSpeed" />

            <label for="outputsJointTorque" title="Torque of the joint">Joint Torque</label>
            <input type="checkbox" id="outputsJointTorque" @bind="agentProperties.outputsJointTorque" />

            <label for="outputsBias" title="The amount of bias towards direction agent is facing">Limb Directional Bias</label>
            <input type="checkbox" id="outputsBias" @bind="agentProperties.outputsBias" />
        </div>

    </div>

    <div class="settings-section">
        <h2>Training Settings</h2>

        <!-- Physics ticks per round -->
        <div class="setting">
            <label for="SimulationLength" title="Physics ticks per round/generation, set alongside physics speed.">Physics Ticks Per Round</label>
            <div class="slider-container">
                <input type="range" id="SimulationLength" @bind="stageProperties.SimulationLength" min="100" max="100000" step="100">
                <input type="number" @bind="stageProperties.SimulationLength" min="100" max="10000" step="100">
            </div>
        </div>

        <!-- Time increase per generation -->
        <div class="setting">
            <label for="timeIncrease" title="Increase the round length by * 1.005 each round">Increase Round Time Per Generation</label>
            <input type="checkbox" id="timeIncrease" @bind="stageProperties.timeIncrease" />
        </div>

        <!-- Group Tournament Size -->
        <div class="setting">
            <label for="tournamentSize" title="Group Tournament Size, the number of random agents picked to compete to be parents, mostly from within the same group.">Group Tournament Size</label>
            <div class="slider-container">
                <input type="range" id="tournamentSize" @bind="stageProperties.tournamentSize" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.tournamentSize" min="1" max="50" step="1">
            </div>
        </div>

        <!-- Migration rate between groups -->
        <div class="setting">
            <label for="migrationRate" title="Migration rate between groups, the chance a parent is selected from random group instead of the same.">Migration Rate Between Groups</label>
            <div class="slider-container">
                <input type="range" id="migrationRate" @bind="stageProperties.migrationRate" min="0.001" max="0.1" step="0.001">
                <input type="number" @bind="stageProperties.migrationRate" min="0.001" max="0.1" step="0.001">
            </div>
        </div>

        <!-- Minimum agents per population group -->
        <div class="setting">
            <label for="minPopGroupSize" title="Minimum agents per population group. If the total number is less than this, all agents will be in the same group.">Minimum Agents Per Population Group</label>
            <div class="slider-container">
                <input type="range" id="minPopGroupSize" @bind="stageProperties.minPopGroupSize" min="5" max="50" step="1">
                <input type="number" @bind="stageProperties.minPopGroupSize" min="5" max="50" step="1">
            </div>
        </div>

        <!-- Maximum agents per population group -->
        <div class="setting">
            <label for="maxPopGroupSize" title="Maximum agents per population group. Sets the number of groups as total population / Max agents per group, when total is more than max.">Maximum Agents Per Population Group</label>
            <div class="slider-container">
                <input type="range" id="maxPopGroupSize" @bind="stageProperties.maxPopGroupSize" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.maxPopGroupSize" min="1" max="50" step="1">
            </div>
        </div>

        <!-- Percentage of top agents kept between generations -->
        <div class="setting">
            <label for="topPerformerNumber" title="Percentage of top agents kept between generations.">Percentage of Top Agents Kept</label>
            <div class="slider-container">
                <input type="range" id="topPerformerNumber" @bind="stageProperties.topPerformerNumber" min="5" max="50" step="1">
                <input type="number" @bind="stageProperties.topPerformerNumber" min="5" max="50" step="1">
            </div>
        </div>

        <!-- Brain Decay -->
        <div class="setting">
            <label for="brainDecayOverTime" title="Decay all weights in agents brain by a small amount each round">Brain Decay Over Time</label>
            <input type="checkbox" id="brainDecayOverTime" @bind="agentProperties.brainDecayOverTime" />
        </div>

    </div>

    <div class="settings-section">
        <h2>World Properties</h2>

        <!-- Agent to fix camera on -->
        <div class="setting">
            <label for="agentInCentre" title="Agent to fix camera on (average can cause lag).">Agent to Fix Camera On</label>
            <select id="agentInCentre" @bind="stageProperties.agentInCentre">
                <option value="leader">leader</option>
                <option value="trailer">trailer</option>
                <option value="average">average</option>
            </select>
        </div>

        <!-- Map -->
        <div class="setting">
            <label for="map" title="Pick between maps">Map Selector</label>
            <select id="map" @bind="stageProperties.map">
                <option value="1">1</option>
                <option value="2">2</option>
            </select>
        </div>

        <!-- Gravity Strength Multiplyer -->
        <div class="setting">
            <label for="Gravity" title="Gravity Strength Multiplier.">Gravity Strength Multiplier</label>
            <div class="slider-container">
                <input type="range" id="Gravity" @bind="stageProperties.Gravity" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.Gravity" min="0" max="5" step="0.1">
            </div>
        </div>

        <!-- Friction Strength Multiplyer -->
        <div class="setting">
            <label for="Friction" title="Friction Strength Multiplier.">Friction Strength Multiplier (Not implemented yet)</label>
            <div class="slider-container">
                <input type="range" id="Friction" @bind="stageProperties.Friction" min="0" max="5" step="0.1">
                <input type="number" @bind="stageProperties.Friction" min="0" max="5" step="0.1">
            </div>
        </div>

    </div>

    <button class="toggle-advanced" @onclick="ToggleAdvancedSettings">Show Advanced Settings</button>

    <div class="settings-section full-width advanced-settings" hidden="@showAdvancedSettings">
        <h2>Advanced Settings</h2>

        <!-- Number of random agents per group -->
        <div class="setting">
            <label for="renderedAgents" title="Number of random agents per group, plus the group leader, to render.">Number of Random Agents Per Group</label>
            <div class="slider-container">
                <input type="range" id="renderedAgents" @bind="stageProperties.renderedAgents" min="1" max="50" step="1">
                <input type="number" @bind="stageProperties.renderedAgents" min="1" max="50" step="1">
            </div>
        </div>

        <!-- UI (Neural Network and Text) Update Rate -->
        <div class="setting">
            <label for="uiRefreshRate" title="UI (Neural Network and Text) Update Rate in milliseconds.">UI Update Rate (ms)</label>
            <div class="slider-container">
                <input type="range" id="uiRefreshRate" @bind="stageProperties.uiRefreshRate" min="100" max="1000" step="100">
                <input type="number" @bind="stageProperties.uiRefreshRate" min="100" max="1000" step="100">
            </div>
        </div>

        <!-- velocityIteration for plank -->
        <div class="setting">
            <label for="velocityIteration" title="velocityIteration value for planck">Velocity Iterations</label>
            <div class="slider-container">
                <input type="range" id="velocityIteration" @bind="stageProperties.velocityIteration" min="1" max="10" step="1">
                <input type="number" @bind="stageProperties.velocityIteration" min="1" max="10" step="1">
            </div>
        </div>

        <!-- positionIteration for plank -->
        <div class="setting">
            <label for="positionIteration" title="UI (Neural Network and Text) Update Rate in milliseconds.">Position Iterations</label>
            <div class="slider-container">
                <input type="range" id="positionIteration" @bind="stageProperties.positionIteration" min="1" max="10" step="1">
                <input type="number" @bind="stageProperties.positionIteration" min="1" max="10" step="1">
            </div>
        </div>

        <!-- physicsGranularity for plank -->
        <div class="setting">
            <label for="physicsGranularityMultipliers" title="Physics Granularity">Physics Granularity</label>
            <div class="slider-container">
                <input type="range" id="physicsGranularityMultipliers" @bind="stageProperties.physicsGranularityMultipliers" min="0.1" max="3" step="0.1">
                <input type="number" @bind="stageProperties.physicsGranularityMultipliers" min="0.1" max="3" step="0.1">
            </div>
        </div>
    </div>

    <div class="simDescription">
        <h3>Some Explenation</h3>
        <p>This is my take on a NEAT genetic evolution simulation.  For the best results, target a high value for 'Agents Per Batch of Joint Updates' a low value for 'Delay Between Batch of Joint Updates' and a high value for 'Number of Agents'</p>
        <p>I would describe this as 'Semi-NEAT' since I have restriction on what network shapes can evolve.  This is due to TensorFlow.JS's restriction to static models, where a full NEAT implementation requires dynamic models, and more control over connections</p>
        <p>Resetting/updating is a little buggy, its currently best to refresh the page if you want to try new settings</p>
        <p>Showing the Neural Network on screen adds a fair amount of lag so its hidden by default</p>
        <p>I am making use of P5.JS for my rendering, Planck.JS, which is a port of Box2D for my physics, and TensorFlow.JS for my neural network processing</p>
        <h4>So whats going on?</h4>
        <p>If you start the simulation with default settings, you will see 6-7 agents on the screen, representing the top scorer from each group, a random agent per group, the agent that has made it furthest right, and the furthest left agent</p>
        <p>Each round, the agents have 2000 ticks, about 34 seconds at 60 fps with default physics speed of 60, to move as far North East as possible.</p>
        <p>The agents are all given a randomly initialised neural network, with a random shape for a brain, the leaders brain is rendered.  They are given a random body plan.  Both the brain and the body plan will evolve over time based on a number of crossover and mutation functions</p>
        <p>Between rounds, the agents are sorted by score, where the top 10% from each group are selected to remain unchanged, and the other 90% of the population is built using crossover and mutation.</p>
        <p>Crossover is the function of picking 2 parent agents and combining the weights and biases in their brains, keeping some features from one, and some from the other.  There are a range of methods for this, I am currently using biased Arithmetic Crossover, where there is a weighted bias given by the relative scores of the parents.</p>
        <p>Mutation adds a small chance that each weight, bias, limb or body will be altered by a small, random amount.  Again, there are many methods, currently i am using the Box-Muller transform to get a Gaussian random number for my mutation amount.  I have a function that changes the mutation rate if agents brains get too close to the average</p>
        <p>The parents for crossover can be selected in many ways, I am actually using 1 method for 1 parent, and another for the other.  The first is picked via tournament selection, where 10 random agents are selected from the group, and the best of those if picked.  The second is picked via a weighted random selection, where ever agent is entered into a lottery with more enteries for a higher score, and a random agent is picked from the pool.</p>
        <p>I am also using 'Island Populations' or 'Island Spisiation', where parents are always picked from the same distinct group.  This means, with default settings, 3 distinct populations should evolve with different strategies.  There is a small chance that parents are picked from a different group, allowing some sharing of strategies</p>
        <p>You should see some 'evolution' within  50 or so generations, and they can continue to improve indefinatly, however, they can get stuck in whats known as a 'local maxima' where the agents converge on 1 or a few ok strategies, and never seem to improve.  Through mutation, they might eventually, but in those situations, its best to restart.  A greater number of agents or distinct population groups can help with this</p>
        <p>If enabled, I am experementing with a form of normalisation which slowly decays all weights in the network over time.  It's meant to prevent any noise in the network over time, based on a 'use it or loose it' principal.  Useful connections should be maintained by re-selection and un-needed connections will drop away</p>
        <h4>Current Selective Preasures (to be made configurable)</h4>
        <ol>
            <li>Score for movement NE</li>
            <li>Bonus for joint movement that diminishes over time</li>
            <li>Exploration bonus</li>
            <li>Size bonus</li>
            <li>Larger limbs give more swimming force</li>
            <li><h5>Energy Sytem:</h5></li>
                <li>Starting energy based on body size, larger boddies can store more energy</li>
                <li>More energy is used to move larger limbs</li>
                <li>Agents limb movement speed is based on their remaining energy %, with no engergy, they cant move at all</li>
        </ol>
        <h4>Future Plans</h4>
        <p>I want to make all variables customisable, which is a huge number.  I need to find a nice way to arrange them</p>
        <p>I plan on adding further ways the agents can evolve, both the brain and the body.  Currently, they cant gain or loose layers in the network through mutation, only crossover.  I want to allow more complex bocy plans with diffent types of limb and body segment</p>
        <p>I want to add a greater range of crossover, mutation and selection methods to increase diversity, and have them togglable in settings to play with differnet combinations</p>
        <p>I want to add a way to save and load agents, and a way to download and upload agents to a database</p>
        <p>I want to add a system where agents from a run are added to a pool, which is maintained for a set number of runs, and crossover and mutation is performed on that pool, effectivly multiplying the number of agents per generation, but decreasing simulation time per agent and increasing training time</p>
@*        <p>The next update I would like to implement is my own version of the NEAT algorithm, or Neural Evolution of Augmented Topologies.  This involves starting with a simple brain and evolving its 'shape' over time.  The default shape is currently [11, 15, 10, 5], equating to the inputs, 5 limb angles, the agents x,y the agents x and y velocity, their orientation in space, and the time remaining.  The 2 'hidden layers' and 5 outputs for the 5 joint speeds.</p>
        <p>Using NEAT, the shape would start more like [11,5,5], and each generation, as part of the numtaion function, there is a change the brain will gain a node within a layer, or a whole new layer</p>
        <p>I intend to take this a little further, by also evolving the agents body, and the inputs and outputs.  This would mean starting with a simple agent, like they are now but with 2-3 limbs.  They would be able to mutate additional limbs and body segments over time.  The inputs and outputs would also be selected from a pool</p>
        <p>This will involve encoding the agents brain shape, inputs and outputs, body plan, history, brain weights and biases, into a single object, that can be stored and reused later, which has the side benefit of not having to keep retraining from scratch</p>
        <p>I intend to host a database of agents that do well and be able to download and upload agents from anywhere.</p>*@
    </div>

</div>


<button class="floating-button start-button" @onclick="ResetSimulation">Start/Reset</button>
<button class="floating-button update-button" title="You can update the round length, number of rendered agents, physics speed, spawn delay and batch size, parent tournament size, migration rate, max and min population group size and the agent to fix the camera on" @onclick="UpdateSimulation">Update</button>
<button class="floating-button toggleNN-button" @onclick="toggleNN">Toggle Neural Network</button>
<button class="floating-button toggleLeader-button" @onclick="toggleLeader">Toggle Leader vs Trailer</button>
<button class="floating-button toggleRays-button" @onclick="toggleRayCasts">Toggle Raycasts Rendering</button>
<button class="floating-button logGenomes-button" @onclick="LogGenomes">Log Genomes</button>

@code {
    private StageProperties stageProperties = new StageProperties();
    private AgentProperties agentProperties = new AgentProperties();
    public bool box2dPhysics { get; set; } = true;
    private bool showAdvancedSettings = true;
    public List<Genome> population = new List<Genome>();

    public class StageProperties
    {
        public float Width { get; set; } = 1600;  // Canvas width
        public float Height { get; set; } = 800;  // Canvas height
        public float GroundY { get; set; } = 700;  // Y position of the ground in the canvas
        public float Gravity { get; set; } = 1;
        public double Friction { get; set; } = 0.4;
        public int SimulationLength { get; set; } = 2000;
        public int renderedAgents { get; set; } = 1;
        public int simSpeed { get; set; } = 60;
        public double topPerformerNumber { get; set; } = 10;
        public int delay { get; set; } = 20;
        public int BatchSize { get; set; } = 10;
        public bool showNN { get; set; } = false;
        public bool showRays { get; set; } = false;
        public string agentInCentre { get; set; } = "leader";
        public int numAgents { get; set; } = 50;
        public int tournamentSize { get; set; } = 10;
        public double migrationRate { get; set; } = 0.002;
        public int minPopGroupSize { get; set; } = 10;
        public int maxPopGroupSize { get; set; } = 20;
        public int uiRefreshRate { get; set; } = 500;
        public int muscleDelay { get; set; } = 1;
        public int muscleBatch { get; set; } = 5;
        public int totalMuscleUpdateTime { get; set; } = 2;
        public int velocityIteration { get; set; } = 4;
        public int positionIteration { get; set; } = 2;
        public double physicsGranularityMultipliers { get; set; } = 1;
        public double liquidViscosity { get; set; } = 0.99;
        public bool timeIncrease { get; set; } = true;
        public int map { get; set; } = 1;
    }

    public class AgentProperties
    {
        public int numLimbs { get; set; } = 3;
        public double musculeTorque { get; set; } = 1000000.0;
        public double maxJointSpeed { get; set; } = 2.5;
        public double offspringMutationRate { get; set; } = 0.1;
        public double maxJointMoveDivider { get; set; } = 3;
        public bool brainDecayOverTime { get; set; } = false;
        public bool inputJointAngle { get; set; } = true;
        public bool inputJointSpeed { get; set; } = false;
        public bool inputAgentPos { get; set; } = true;
        public bool inputAgentV { get; set; } = true;
        public bool inputScore { get; set; } = false;
        public bool inputOrientation { get; set; } = true;
        public bool inputTimeRemaining { get; set; } = true;
        public bool inputDistanceSensors { get; set; } = true;
        public bool outputsJointSpeed { get; set; } = true;
        public bool outputsJointTorque { get; set; } = false;
        public bool outputsBias { get; set; } = false;
        public int swimStrength { get; set; } = 500000;
        public double swimBias { get; set; } = 1.5; 
        // public int hiddenLayersNN { get; set; } = 3;
        // public int nodesPerHiddenLayer { get; set; } = 10; // half for fanal hidden layer
    }

    private async Task ResetSimulation()
    {
        await InitializePopulation(stageProperties.numAgents);
        await JSRuntime.InvokeVoidAsync("initializeSketchBox2DNEAT", stageProperties);
        await JSRuntime.InvokeVoidAsync("initializeAgentsBox2DNEAT", agentProperties, population);
    }

    private async Task toggleNN()
    {
        stageProperties.showNN = !stageProperties.showNN;
        await JSRuntime.InvokeVoidAsync("toggleNNRender", stageProperties.showNN);
    }

    private async Task toggleRayCasts()
    {
        stageProperties.showRays = !stageProperties.showRays;
        await JSRuntime.InvokeVoidAsync("toggleRayCastRender", stageProperties.showRays);
    }

    private void ToggleAdvancedSettings()
    {
        showAdvancedSettings = !showAdvancedSettings;
    }

    private async Task UpdateSimulation()
    {
        await JSRuntime.InvokeVoidAsync("updateSimulationNEAT", stageProperties);
    }

    private async Task toggleLeader()
    {
        if (stageProperties.agentInCentre == "leader")
        {
            stageProperties.agentInCentre = "trailer";
        }
        else
        {
            stageProperties.agentInCentre = "leader";
        }

        await UpdateSimulation();
    }

    private async Task LogGenomes()
    {
        await JSRuntime.InvokeVoidAsync("logGenomes");
    }

    public async Task InitializePopulation(int populationSize)
    {
        population = new List<Genome>();
        for (int i = 0; i < populationSize; i++)
        {
            Random random = new Random();
            Genome genome = new Genome();
            genome.Metadata.AgentIndex = i;

            int numLimbs = random.Next(2, 5);

            // Initialize genes, examples used for now, will be randomised once the constructor is complete
            genome.InputLayerGenes.Add(InitializeInputLayer(numLimbs));

            int numLayers = random.Next(1, 5);

            // assuming you want to add 3 layers, and the layer numbers are between 1 and 3, and sizes between 10 and 20
            for (int j = 0; j < numLayers; j++)
            {
                int randomSize = random.Next(3, 20); // Generates a random integer between 3 and 20
                genome.LayerGenes.Add(InitializeLayer(j, randomSize));
            }

            //genome.LayerGenes.Add(InitializeLayer(1, 20));
            //genome.LayerGenes.Add(InitializeLayer(2, 15));
            //genome.LayerGenes.Add(InitializeLayer(3, 10));

            genome.OutputLayerGenes.Add(InitializeOutputLayer(numLimbs));
            genome.BodyPlan = InitializeBodyPlan(numLimbs);
            // initialize genome.Metadata.AgentName as random string in the format cvccvc (consonant vowel consonant consonant vowel consonant)
            var randomName = new Random();
            var consonants = "bcdfghjklmnpqrstvwxyz";
            var vowels = "aeiou";
            var agentName = $"{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}{consonants[randomName.Next(consonants.Length)]}{vowels[randomName.Next(vowels.Length)]}{consonants[randomName.Next(consonants.Length)]}";
            genome.Metadata.AgentName = agentName;

            // Further initialization

            population.Add(genome);
        }
    }

    public async Task UploadExistingPopulation()
    {
        //foreach (Genome in UploadedGenomes)
        //{
        //    Genome genome = new Genome();
        //    genome.Metadata.AgentIndex = i;

        //    // Initialize genes, examples used for now, will be randomised once the constructor is complete
        //    genome.InputLayerGenes.Add();
        //    genome.LayerGenes.Add(); // First hidden layer with 10 neurons
        //    genome.LayerGenes.Add();  // Second hidden layer with 5 neurons
        //    genome.OutputLayerGenes.Add();
        //    genome.BodyPlan = ;

        //    // Further initialization

        //    population.Add(genome);
        //}
    }

    private InputLayerGene InitializeInputLayer(int numLimbs)
    {
        return new InputLayerGene
            {
                NumberOfNeurons = 10 + numLimbs, 
                ActivationType = ActivationType.ReLU,
                Inputs = Enumerable.Range(1, 10 + numLimbs).ToList()
            };
    }

    private LayerGene InitializeLayer(int layerId, int numberOfNeurons)
    {
        return new LayerGene
            {
                LayerID = layerId,
                LayerType = LayerType.Dense,
                NumberOfNeurons = numberOfNeurons,
                ActivationType = ActivationType.ReLU
            };
    }

    private OutputLayerGene InitializeOutputLayer(int numLimbs)
    {
        return new OutputLayerGene
            {
                NumberOfNeurons = numLimbs, // 3 outputs
                ActivationType = ActivationType.Tanh,
                Outputs = Enumerable.Range(1, numLimbs).ToList() // List of outputs from 1 to 3
            };
    }

    private BodyPlan InitializeBodyPlan(int numLimbs)
    {
        Random random = new Random();

        BodyPlan bodyPlan = new BodyPlan
            {
                MainBody = new MainBody
                {
                    Shape = "Circle",
                    Size = 10 + random.NextDouble() * 30.0 // Example range from 0 to 40
                }
            };

        for (int i = 0; i < numLimbs; i++)
        {
            double angle = random.NextDouble() * 2 * Math.PI; // Random angle in radians
            Limb limb = new Limb
                {
                    LimbID = i,
                    Shape = "Rectangle",
                    Length = 10 + random.NextDouble() * 50.0,
                    Width = 2 + random.NextDouble() * 20.0,
                    StartingAngle = angle,
                    Attachment = new AttachmentPoint
                    {
                        X = bodyPlan.MainBody.Size * Math.Cos(angle),
                        Y = bodyPlan.MainBody.Size * Math.Sin(angle)
                    },
                    Constraints = new JointConstraints
                    {
                        MaxTorque = random.NextDouble() * 100000, 
                        MinAngle = -(Math.PI / random.Next(2, 5)),
                        MaxAngle = (Math.PI / random.Next(2, 5))
                    }
                };
            bodyPlan.Limbs.Add(limb);
        }

        return bodyPlan;
    }
    // Starting to think about implementing NEAT and encoding agent properties within a Genome:

    public class Genome
    {
        public List<InputLayerGene> InputLayerGenes { get; set; }
        public List<LayerGene> LayerGenes { get; set; }
        public List<OutputLayerGene> OutputLayerGenes { get; set; }
        // public List<InnovationEntry> InnovationLog { get; set; }
        public BodyPlan BodyPlan { get; set; }
        public Dictionary<string, string> Stats { get; set; }
        public AgentHistory AgentHistory { get; set; }
        public Hyperparameters Hyperparameters { get; set; }
        public Metadata Metadata { get; set; }
        public List<int> UsedBiasIDs { get; set; }
        public List<int> UsedLayerIDs { get; set; }

        public Genome()
        {
            // Initialize properties with defaults or random values.
            this.InputLayerGenes = new List<InputLayerGene>();
            this.LayerGenes = new List<LayerGene>();
            this.OutputLayerGenes = new List<OutputLayerGene>();
            // this.InnovationLog = new List<InnovationEntry>();
            this.BodyPlan = new BodyPlan();
            this.AgentHistory = new AgentHistory();
            this.Hyperparameters = new Hyperparameters();
            this.Metadata = new Metadata();
            this.UsedBiasIDs = new List<int>();
            this.UsedLayerIDs = new List<int>();
        }
    }

    // An initial attempt at encoding the agents body plan into the genome:

    public class MainBody
    {
        public string Shape { get; set; }
        public double Size { get; set; }
    }

    public class AttachmentPoint
    {
        public double X { get; set; }
        public double Y { get; set; }
    }

    public class JointConstraints
    {
        public double MaxTorque { get; set; }
        public double MinAngle { get; set; }
        public double MaxAngle { get; set; }
    }

    public class BodySegment
    {
        public string Shape { get; set; }
        public double Size { get; set; }
        public AttachmentPoint AttachmentOnMainBody { get; set; }
        public AttachmentPoint AttachmentOnSegment { get; set; }
        public JointConstraints Constraints { get; set; }
    }

    public class Limb
    {
        public int LimbID { get; set; }
        public string Shape { get; set; }
        public double Length { get; set; }
        public double Width { get; set; }
        public double StartingAngle { get; set; }
        public double SwimBias { get; set; }
        public AttachmentPoint Attachment { get; set; }
        public JointConstraints Constraints { get; set; }

        public Limb()
        {
            this.Attachment = new AttachmentPoint();
            this.Constraints = new JointConstraints();
        }
    }

    public class BodyPlan
    {
        public MainBody MainBody { get; set; }
        public List<BodySegment> BodySegments { get; set; }
        public List<Limb> Limbs { get; set; }

        public BodyPlan()
        {
            // Initialize with default or random values
            this.BodySegments = new List<BodySegment>();
            this.Limbs = new List<Limb>();
        }
    }

    // Encode the agents history into the genome:

    public class AgentHistory
    {
        public List<ScoreHistory> ScoreHistory { get; set; }
        public int RoundsAsTopPerformer { get; set; }
        public int UsedAsParent { get; set; }
        public List<String> Mutations { get; set; }
        public double RankInGroup { get; set; }
        public double RankInPop { get; set; }

        public AgentHistory()
        {
            // Initialize properties with defaults.
            this.ScoreHistory = new List<ScoreHistory>();
            this.RoundsAsTopPerformer = 0;
            this.UsedAsParent = 0;
            this.Mutations = new List<String>();
        }
    }

    public class ScoreHistory
    {
        public double Score { get; set; }
        public int Map { get; set; }
        public int Generation { get; set; }
    }

    public class Hyperparameters
    {
        public double MutationRate { get; set; }

        public Hyperparameters()
        {
            // Initialize properties with defaults or random values.
            this.MutationRate = 0.1;
        }
    }

    // Encode the agents Inovation History into the genome:

    // public class InnovationEntry
    // {
    //     // This needs some thinking about
    //     public int InnovationNumber { get; set; }
    //     public MutationType MutationType { get; set; } // "AddNode", "AddLayer", etc.
    //     public int? FromNodeID { get; set; } // Source node ID for new connections
    //     public int? ToNodeID { get; set; }   // Destination node ID for new connections
    //     public int? NewNodeID { get; set; }  // Node ID for newly added nodes

    //     public InnovationEntry(int number, MutationType type, int? fromNode = null, int? toNode = null, int? newNode = null)
    //     {
    //         this.InnovationNumber = number;
    //         this.MutationType = type;
    //         this.FromNodeID = fromNode;
    //         this.ToNodeID = toNode;
    //         this.NewNodeID = newNode;
    //     }

    // }

    // public enum MutationType
    // {
    //     AddNode,
    //     AddConnection,
    //     RemoveNode,
    //     RemoveConnection,
    //     // ...other types
    // }


    // Encode agents name and species into metadata:

    public class Metadata
    {
        public string AgentName { get; set; }
        public int AgentIndex { get; set; }
        public string GroupName { get; set; }
        public string Species { get; set; }
        public double BestScore { get; set; }
        public int CompatabilityDistance { get; set; }
        // ... 

        public Metadata()
        {
            // Initialize with default values, or leave them null.  Should maybe have these as parameters in the call
            this.AgentName = "Unnamed"; // Set randomly on initialisation, unique to an agent
            this.AgentIndex = 0; // Set randomly on initialisation, unique to an agent
            this.GroupName = "DefaultGroup"; // set randomly on initialisation, the same for all agents in a populaton
            this.Species = "Unspecified"; // set randomly on initialisation, same for agents in the same spicies.  might need to set this later after distinct spicies groups form.
            this.BestScore = 0; // Set to 0 on initialisation, updated after each round
            this.CompatabilityDistance = 0; // Set to 0 on initialisation, updated after each round
        }
    }

    public class InputLayerGene
    {
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<Bias> Biases { get; set; }
        public List<int> Inputs { get; set; }

        public InputLayerGene()
        {
            // List inputs
            this.Inputs = new List<int>();
        }
    }

    public class LayerGene
    {
        public int LayerID { get; set; }
        public LayerType LayerType { get; set; }  // "Dense", "Conv", "LSTM", etc.
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<List<Weight>> Weights { get; set; }
        public List<Bias> Biases { get; set; }

        // ...other layer-related properties
    }

    public class OutputLayerGene
    {
        public int NumberOfNeurons { get; set; }
        public ActivationType ActivationType { get; set; } // "ReLU", "Sigmoid", "Tanh", etc.
        public List<List<Weight>> Weights { get; set; }
        public List<Bias> Biases { get; set; }
        public List<int> Outputs { get; set; }

        public OutputLayerGene()
        {
            // List inputs
            this.Outputs = new List<int>();
        }
    }

    public class Weight
    {
        //public int ID { get; set; }
        public int FromNodeID { get; set; }
        public int ToNodeID { get; set; }
        public double Value { get; set; }

        public Weight(int fromNodeID, int toNodeID, double value)
        {
            //ID = id;
            FromNodeID = fromNodeID;
            ToNodeID = toNodeID;
            Value = value;
        }
    }

    public class Bias
    {
        public int ID { get; set; }
        public double Value { get; set; }

        public Bias(int id, double value)
        {
            ID = id;
            Value = value;
        }
    }

    public enum LayerType
    {
        Dense,
        Convolutional,
        LSTM,
        // ...other types
    }

    public enum ActivationType
    {
        ReLU,
        Sigmoid,
        Tanh,
        // ...other types
    }
}

