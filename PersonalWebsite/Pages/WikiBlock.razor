@inject MyStateContainer myStateContainer
@inject IState<ContentState> contentState
@inject IDispatcher Dispatcher
@using Newtonsoft.Json;
@using PersonalWebsite.Shared.Model;
@using PersonalWebsite.Store.Actions;
@using PersonalWebsite.Store.State;
@using Fluxor;

@if (type == "all" && lastPage != contentState.Value.Contents[indexParsed].page)
{
	<h1 class="kudosTextInline">@contentState.Value.Contents[indexParsed].page</h1>
	lastPage = contentState.Value.Contents[indexParsed].page;
}
@if (type == "add")
{
	if (inline == true)
	{
		<tr>
			<td>
				<h3 class="kudosTextInline">New Section: </h3>
				<div class="dotted-lines" @onfocusout="(() => Save(true))">
					<Editor Id="@count.ToString()"
						Inline=true
						CloudChannel="5"
						Disable=false
						Conf="@editorConfInline"
						ApiKey="@TinyAPIKey"
						ClassName="counterEditor"
						Value="@contentState.Value.Contents.Last().content"
							ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
				</div>
			</td>
		</tr>
	}
	else
	{
		<tr>
			<td class="kudosText">New Section: </td>
			@* Render the de-serialized JSON string as HTML, including styling.  I need some sanitisation here but AntiXss from Microsoft is broken ATM... *@
			<td hidden="@contentState.Value.IsEditing[indexParsed]">@(new MarkupString(contentState.Value.Contents.Last().content!))</td>
			<td hidden="@(!contentState.Value.IsEditing[indexParsed])">
				<div class="dotted-lines tinymce-editor">
					<Editor Id="@count.ToString()"
							Inline=false
							CloudChannel="5"
							Disable=false
							Conf="@editorConf"
							ApiKey="@TinyAPIKey"
							ClassName="counterEditor"
							Value="@contentState.Value.Contents.Last().content"
							ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
				</div>
			</td>
		</tr>
		<tr>
			<td>
				@*Spacing*@
			</td>
			@* Button bank to be generated per section.  Using lambda expression to parse value to function *@
			@{var clearText = "";}
			<td>
				<button class="btn btn-outline-warning" @onclick="()=> contentState.Value.Contents.Last().content = clearText">Clear</button>
				<button class="btn btn-outline-primary" @onclick="(() => Save(true))" hidden="@(!contentState.Value.IsEditing[indexParsed])">Save</button>
				<button class="btn btn-outline-primary" @onclick="(() => Cancel())" hidden="@(!contentState.Value.IsEditing[indexParsed])">Cancel</button>
			</td>
	</tr>
	}
}
else
{
	@if (inline == true)
	{
		<tr>
			@* Currently showing all details about the section, but once I split into multiple pages, this will likley be hidden *@
			<td>
				@if (type == "all" || type == "Search" || (!matchTypeSections && matchType))
				{
					<h3 class="kudosTextInline" @onfocusin="(() => Edit(localCount, indexParsed))" @onfocusout="(() => Save(false))">
						<Editor Id="@($"{count}-1")"
						Inline=true
						CloudChannel="5"
						Disable=false
						Conf="@editorConfHeaders"
						ApiKey="@TinyAPIKey"
						ClassName="counterEditor"
						Value="@contentState.Value.Contents[indexParsed].section"
								ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
						<small>
							<div class="text-muted">
								<Editor Id="@($"{count}-2")"
								Inline=true
								CloudChannel="5"
								Disable=false
								Conf="@editorConfHeaders"
								ApiKey="@TinyAPIKey"
								ClassName="counterEditor"
								Value="@contentState.Value.Contents[indexParsed].subSection"
										ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
							</div>
						</small>
					</h3>
				}
				else if (!matchTypeSectionsSubSections && matchTypeSections)
				{
					<h3 class="kudosTextInline" @onfocusin="(() => Edit(localCount, indexParsed))" @onfocusout="(() => Save(false))">
						<small>
							<div class="text-muted">
								<Editor Id="@($"{count}-2")"
									Inline=true
									CloudChannel="5"
									Disable=false
									Conf="@editorConfHeaders"
									ApiKey="@TinyAPIKey"
									ClassName="counterEditor"
									Value="@contentState.Value.Contents[indexParsed].subSection"
										ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
							</div>
						</small>
					</h3>
				}
				else
				{
					<h3 class="kudosTextInline">
						<small class="text-muted">

						</small>
					</h3>
				}
				<div class="dotted-lines" @onfocusin="(() => Edit(localCount, indexParsed))" @onfocusout="(() => Save(false))">
					<Editor Id="@count.ToString()"
						Inline=true
						CloudChannel="5"
						Disable=false
						Conf="@editorConfInline"
						ApiKey="@TinyAPIKey"
						ClassName="counterEditor"
						Value="@contentState.Value.Contents[indexParsed].content"
							ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
					<button class="btn btn-outline-primary inlineBTN" @onclick="(() => RemoveSection.InvokeAsync((indexParsed, username!)))">Delete</button>
				</div>
			</td>
		</tr>
	}
	else
	{
		<tr>
			@* Currently showing all details about the section, but once I split into multiple pages, this will likley be hidden *@
			@if (type == "all" || type == "Search" || (!matchTypeSections && matchType))
			{
				<td class="kudosText col-1">
					<h4 @onfocusin="(() => Edit(localCount, indexParsed))" @onfocusout="(() => Save(false))">
					<Editor Id="@($"{count}-1")"
						Inline=true
						CloudChannel="5"
						Disable=false
						Conf="@editorConfHeaders"
						ApiKey="@TinyAPIKey"
						ClassName="counterEditor"
						Value="@contentState.Value.Contents[indexParsed].section"
								ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
						<br><small>
							<div class="text-muted">
								<Editor Id="@($"{count}-2")"
								Inline=true
								CloudChannel="5"
								Disable=false
								Conf="@editorConfHeaders"
								ApiKey="@TinyAPIKey"
								ClassName="counterEditor"
								Value="@contentState.Value.Contents[indexParsed].subSection"
										ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
							</div>
						</small>
					</h4>
				</td>
			}
			else if (!matchTypeSectionsSubSections && matchTypeSections)
			{
				<td class="kudosText col-1">
					<h4>
					@if (contentState.Value.Contents[indexParsed].subSection != null)
						{
							<h3 class="kudosTextInline" @onfocusin="(() => Edit(localCount, indexParsed))" @onfocusout="(() => Save(false))">
								<Editor Id="@($"{count}-2")"
								Inline=true
								CloudChannel="5"
								Disable=false
								Conf="@editorConfHeaders"
								ApiKey="@TinyAPIKey"
								ClassName="counterEditor"
								Value="@contentState.Value.Contents[indexParsed].subSection"
										ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
							</h3>
						}
					</h4>
				</td>
			}
			else if (matchTypeSectionsSubSections)
			{
				
			}
			
			@* Render the de-serialized JSON string as HTML, including styling.  I need some sanitisation here but AntiXss from Microsoft is broken ATM... *@
			<td hidden="@contentState.Value.IsEditing[indexParsed]">@(new MarkupString(@contentState.Value.Contents[indexParsed].content!))</td>
			@* When IsEditing is true, render the WYSIWYG editor, i'm using TinyMCE *@
			<td hidden="@(!contentState.Value.IsEditing[indexParsed])">
				<div class="dotted-lines tinymce-editor">
					<Editor Id="@count.ToString()"
						Inline=false
						CloudChannel="5"
						Disable=false
						Conf="@editorConf"
						ApiKey="@TinyAPIKey"
						ClassName="counterEditor"
						Value="@contentState.Value.Contents[indexParsed].content"
							ValueChanged="@(async (newValue) => Dispatcher.Dispatch(new UpdateTempContentAction(indexParsed, newValue.ToString(), true)))" />
				</div>
			</td>
		</tr>
		<tr>
			@if (!matchTypeSectionsSubSections)
			{
				<td>
					@*Spacing*@
				</td>
			}
			<td>
				<button class="btn btn-outline-warning" @onclick="(() => ClearContent.InvokeAsync((localCount, indexParsed)))">Clear</button>
				<button class="btn btn-outline-danger" @onclick="(() => RemoveSection.InvokeAsync((indexParsed, username!)))">Delete</button>
				<button class="btn btn-outline-primary" @onclick="(() => Edit(localCount, indexParsed))" hidden="@contentState.Value.IsEditing[indexParsed]">Edit</button>
				<button class="btn btn-outline-primary" @onclick="(() => Save(false))" hidden="@(!contentState.Value.IsEditing[indexParsed])">Save</button>
				<button class="btn btn-outline-primary" @onclick="(() => Cancel())" hidden="@(!contentState.Value.IsEditing[indexParsed])">Cancel</button>
			</td>
		</tr>
	}
}



@code {
	[Parameter] public bool? inline { get; set; }
	[Parameter] public bool matchTypeSectionsSubSections { get; set; }
	[Parameter] public bool matchTypeSections { get; set; }
	[Parameter] public bool matchType { get; set; }
	[Parameter] public string type { get; set; }
	[Parameter] public string sections { get; set; }
	[Parameter] public string subSections { get; set; }
	[Parameter] public string TinyAPIKey { get; set; }
	[Parameter] public int count { get; set; }
	//[Parameter] public bool[] IsEditing { get; set; }
	[Parameter] public int localCount { get; set; }
	[Parameter] public int indexParsed { get; set; }
	[Parameter] public string username { get; set; }
	//[Parameter] public EventCallback<(string, int)> inlineEdit { get; set; }
	//[Parameter] public EventCallback<(int, int)> Edit { get; set; }
	//[Parameter] public EventCallback<(int, string, int, bool)> Save { get; set; }
	[Parameter] public EventCallback<(int, string)> RemoveSection { get; set; }
	[Parameter] public EventCallback<(int, int)> ClearContent { get; set; }
	//[Parameter] public EventCallback<(int, int)> Cancel { get; set; }
	//[Parameter] public EventCallback<int> CancelNew { get; set; }
	[Parameter] public EventCallback<contentHolder[]> OnDataChanged { get; set; }

	private string? lastPage;
	private contentHolder? tempContent;

	protected override async Task OnInitializedAsync()
	{
		contentState.StateChanged += HandleStateChanged;
	}
	private void HandleStateChanged(object sender, EventArgs e)
	{
		if (contentState.Value.FileCount == contentState.Value.LoadedFilesCount)
		{
			InvokeAsync(StateHasChanged);
		}
	}
	private void Edit(int localSectionNo, int globalSectionNo)
	{
		Console.WriteLine($"IsEditing size: {contentState.Value.IsEditing.Count}, updating index: {globalSectionNo}");
		// When you click edit, save the current state so 'Cancel' button can revert changes
		tempContent = CloneContentHolder(contentState.Value.Contents![globalSectionNo]);
		// Open the editor for the selected section
		Dispatcher.Dispatch(new UpdateIsEditingAction(globalSectionNo, true));
	}


	// Creates a deep copy of a content holder
	private contentHolder CloneContentHolder(contentHolder original)
	{
		return JsonConvert.DeserializeObject<contentHolder>(JsonConvert.SerializeObject(original));
	}

	private void Save(bool newSec)
	{
		Dispatcher.Dispatch(new ResetIsEditingAction());

		Dispatcher.Dispatch(new SaveContentAction(username, indexParsed, newSec));


		Console.WriteLine("Test save, updated content: " + tempContent.content.ToString());

		tempContent = null;
	}

	private void Cancel()
	{
		Dispatcher.Dispatch(new ResetIsEditingAction());
		tempContent = null;
	}

	    @* Define properties for TinyMCE WYSIWYG editor *@
    private Dictionary<string, object> editorConf = new Dictionary<string, object>  {
        {"menubar", "edit insert format table tools help"},
    @* Would like to condence toolbar in to a few dropdowns, but converting JS syntax to C# is a pain *@
        {"toolbar", "undo redo | bold italic underline strikethrough | fontfamily fontsize blocks | alignleft aligncenter alignright alignjustify | outdent indent |  numlist bullist | forecolor backcolor removeformat | pagebreak | charmap emoticons | fullscreen  preview save print | insertfile image media template link anchor codesample | ltr rtl"},
        {"plugins", "autolink media link image table lists advlist code emoticons wordcount importcss autoresize quickbars codesample help"}, //imagetools spellchecker - Removed as imagetools now premium and spellchecker depricated
        {"contextmenu", "copy paste | link image imagetools table lists undo redo | inserttable | cell row column deletetable | help"},
        {"table_toolbar", "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol"},
        {"quickbars_selection_toolbar", "bold italic underline | fontfamily fontsize blocks | bullist numlist | blockquote quicklink"},
        {"quickbars_insert_toolbar", "quicktable image media codesample" },
        {"toolbar_mode", "floating"},
        {"toolbar_location", "top"},
        {"width", "100%"},
        {"min_width", "100%"},
        {"height", "100%"}, @* Using autosize plugin, height property should be ignored. Min_height still respected *@
        {"min_height", 100},
        {"autoresize_bottom_margin", 30},
        {"skin", "oxide-dark"},
        {"content_css", "dark"},
        {"autosave_ask_before_unload", "true"},
        {"paste_data_images", "false"},
        {"paste_as_text", "true"},
		{"browser_spellcheck", "true"},
        {"resize", "true"}
    @* Allows user to resize using bottom right corner.  Should still respect min height and width *@
    };
    private Dictionary<string, object> editorConfInline = new Dictionary<string, object>  {
    @* Would like to condence toolbar in to a few dropdowns, but converting JS syntax to C# is a pain *@
        {"plugins", "autolink media link image table lists advlist code emoticons wordcount importcss autoresize quickbars codesample help"}, //imagetools spellchecker - Removed as imagetools now premium and spellchecker depricated
        {"contextmenu", "copy paste | link image imagetools table lists undo redo | inserttable | cell row column deletetable | help"},
        {"table_toolbar", "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol"},
        {"quickbars_selection_toolbar", "undo redo | bold italic underline strikethrough | fontfamily fontsize | blocks | bullist numlist | alignleft aligncenter alignright alignjustify | outdent indent | forecolor backcolor | blockquote quicklink | charmap emoticons | print | insertfile image media template link anchor codesample | removeformat"},
        {"toolbar", "false"},
        {"menubar", "false"},
        {"block_formats", "Paragraph=p; Heading 1=h1; Heading 2=h2; Heading 3=h3; Heading 4=h4; Heading 5=h5; Heading 6=h6;"},
        {"quickbars_insert_toolbar", "quicktable image media codesample" },
        {"width", "100%"},
        {"min_width", "100%"},
        {"height", "100%"}, @* Using autosize plugin, height property should be ignored. Min_height still respected *@
        {"min_height", 100},
        {"autoresize_bottom_margin", 30},
        {"skin", "oxide-dark"},
        {"content_css", "dark"},
        {"autosave_ask_before_unload", "true"},
        {"paste_data_images", "false"},
        {"paste_as_text", "true"},
		{"browser_spellcheck", "true"},
        {"resize", "true"}
    @* Allows user to resize using bottom right corner.  Should still respect min height and width *@
    };
    private Dictionary<string, object> editorConfHeaders = new Dictionary<string, object>  {
    @* Would like to condence toolbar in to a few dropdowns, but converting JS syntax to C# is a pain *@
        {"plugins", "autolink media link image table lists advlist code emoticons wordcount importcss autoresize quickbars codesample help"}, //imagetools spellchecker - Removed as imagetools now premium and spellchecker depricated
        {"contextmenu", "copy paste | link image imagetools table lists undo redo | inserttable | cell row column deletetable | help"},
        {"table_toolbar", "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol"},
        {"quickbars_selection_toolbar", "undo redo | bold italic underline strikethrough | fontfamily fontsize | blocks | bullist numlist | alignleft aligncenter alignright alignjustify | outdent indent | forecolor backcolor | blockquote quicklink | charmap emoticons | print | insertfile image media template link anchor codesample | removeformat"},
        {"toolbar", "false"},
        {"menubar", "false"},
        {"block_formats", "Paragraph=p; Heading 1=h1; Heading 2=h2; Heading 3=h3; Heading 4=h4; Heading 5=h5; Heading 6=h6;"},
        {"quickbars_insert_toolbar", "quicktable image media codesample" },
        {"width", "100%"},
        {"min_width", "100%"},
        {"height", "100%"}, @* Using autosize plugin, height property should be ignored. Min_height still respected *@
        {"min_height", 100},
        {"autoresize_bottom_margin", 30},
        {"skin", "oxide-dark"},
        {"content_css", "dark"},
        {"autosave_ask_before_unload", "true"},
        {"paste_data_images", "false"},
        {"paste_as_text", "true"},
        {"resize", "true"},
		{"browser_spellcheck", "true"},
        {"forced_root_block", ""}
    @* Allows user to resize using bottom right corner.  Should still respect min height and width *@
    };

}
