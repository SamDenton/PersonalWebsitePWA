@page "/{type?}/{sections?}/{subSections?}"
@using System.Net;
@using System.Net.Http;
@using System.Net.Http.Headers;
@using Newtonsoft.Json;
@using System.Timers;
@using System.Text.RegularExpressions;
@using PersonalWebsite.Shared.Model;
@using PersonalWebsite.Store.Actions;
@using PersonalWebsite.Store.State;
@using Fluxor;
@inject IState<ContentState> contentState
@inject IDispatcher Dispatcher
@inject HttpClient Http;
@inject NavigationManager Navigation;
@inject IJSRuntime JSRuntime;
@* Using Authorize View to only load content when user is authenticated. The editor is disabled when not authenticated *@

<PageTitle>Wiki</PageTitle>
@* Using bootstrap container for layout on main content.  Using some grid layout elements *@
<div class="container-fluid mx-0 ps-0 mainContentContainer">
    @* Moved the searchBar marup and logic to a component so it's on all pages *@
    <SearchBar 
        type="@type"
        SearchTermChanged="SearchTermChanged"
        IsSearchDisabled="false"  />
    <div class="row mx-0 ps-0 gx-3">
        <div class="col">
            @* Toggle between the 2 editor types.  This can be moved to one of the other conditionals doing the same. *@
            @if (type != null)
            {
                <div class="ms-1 form-group form-check form-switch kudosTextToggle">
                    <label class="form-check-label" for="sliderToggle">Light Editor</label>
                    <input type="checkbox" class="form-check-input inputCheck" id="sliderToggle" @bind="inline" @onclick="(() => ClearIsEditingArray())" />
                </div>
            }
            @* Wtf is this block... really need to tidy this up.  Most of if can move to the main foreach loop conditionals *@
            @if (type != "all" && type != null && sections != "all" && subSections != "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@sections <small class="text-muted">@subSections </small></h1>
            }
            else if (type != "all" && sections != "all" && subSections == "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@type <small class="text-muted">@sections </small></h1>
            }
            else if (type != "all" && sections == "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@type <small class="text-muted"></small></h1>
            }
            else if (type == "all")
            {
                <h1 class="kudosTextTop"></h1>
            }
            else if (type == "add")
            {
                <h1 class="kudosTextTop">Add New Section <small class="text-muted"></small></h1>
            }
            else if (type == "Search")
            {
                <h1 class="kudosTextTop">Search Results <small class="text-muted"></small></h1>
            }
            @* Show a loading message before API call is complete *@
            @* Should also add failure case if the API call returns 404 *@
            @*add back 'isContentLoaded == false || ' to conditional*@
            @if (contentState.Value.Contents == null || type == null)
            {
                <div class="container-fluid bg-dark home-container">
                    <div class="row">
                        <div class="col-12 text-center home-image-container">
                            <img src="@Logo" alt="Company Logo" height="149" width="245" class="mx-auto d-block img-fluid homeImg" />
                            <h1 class="mt-3 site-title">
                                <span class="title-span-1">Ex</span>p<span class="title-span-2">lore</span>
                                <span class="title-span-3">M</span><span class="title-span-4">y</span> 
                                <span class="title-span-5">Interactive</span>
                                <span class="title-span-6">Portfolio</span>
                            </h1>

                        </div>
                    </div>
                    <div class="row">
                        <div class="carousel-container">
                            <div class="cards-wrapper" style="@myStyle">
                                @foreach (var card in DisplayCards)
                                {
                                    <div class="col-12 col-sm-12 col-md-12 col-lg-6 col-xl-4 col-xxl-3 card-column">
                                        <div class="card-container">
                                            <div class="card" @onclick="() => { Navigation.NavigateTo(card.Link); }">
                                                <div class="card-body">
                                                    <h5 class="card-title">@card.Title</h5>
                                                    <p class="card-text">@card.Text</p>
                                                    <a href="@card.Link" class="card-link btn btn-outline-light">@card.ButtonText</a>
                                                </div>
                                            </div>
                                            <div class="card-outline"></div>
                                        </div>
                                    </div>
                                }
                                
                            </div>
                        </div>
                    </div>
                </div>
            }
            else
            {
                <AuthorizeView>
                    <Authorized>
                    @{var count = 0;
                    var username = @context.User.Identity!.Name;}
                    <div class="mainTable">
                        <table class="table rounded table-dark @(inline == true ? "border-bottom" : "table-borderless table-striped")">
                            @* @(inline == true ? "" : "") *@
                            <tbody>
                                @if (type == "Search")
                                {
                                    foreach (var item in searchResults
                                    .OrderByDescending(x => x.Score)
                                    .Select((searchResult, index) => new { searchResult, index }))
                                    {
                                        var localCount = count;
                                        int indexParsed = item.searchResult.Content.id;
                                        <WikiBlock 
                                            inline="@inline"
                                            matchTypeSectionsSubSections="false"
                                            matchTypeSections="false"
                                            matchType="false"
                                            type="@type"
                                            sections="@sections"
                                            subSections="@subSections"
                                            TinyAPIKey="@TinyAPIKey"
                                            count="@count"
                                            indexParsed="@indexParsed"
                                            username="@username" />
                                            @* localCount=localCount *@
                                        <p>Search Score: @item.searchResult.Score</p>
                                        @* Increment global count *@
                                        count++;
                                    }
                                }
                                else if (type == "add" && contentState.Value.IsEditing[0] == true && contentState.Value.Contents != null)
                                {
                                    <WikiBlock
                                        inline="@inline"
                                        matchTypeSectionsSubSections="false"
                                        matchTypeSections="false"
                                        matchType="false"
                                        type="@type"
                                        sections="@sections"
                                        subSections="@subSections"
                                        TinyAPIKey="@TinyAPIKey"
                                        count="0"
                                        indexParsed=0
                                        username="@username" />
                                }
                                else
                                {
                                    @* Pragmatically populate the table using my custom object array *@
                                    @foreach (var item in contentState.Value.Contents
                                    .OrderBy(x => x.page)
                                    .ThenBy(x => x.section)
                                    .ThenBy(x => x.subSection)
                                    .Select((contentHolder, index) => new { contentHolder, index }))
                                    {
                                        bool contentNotNull = contentState.Value.Contents[item.index].page != null 
                                        && contentState.Value.Contents[item.index].section != null 
                                        && contentState.Value.Contents[item.index].subSection != null 
                                        && contentState.Value.Contents[item.index].content != null;

                                        bool matchTypeSectionsSubSections = type == contentState.Value.Contents[item.index].page 
                                        && sections == contentState.Value.Contents[item.index].section 
                                        && subSections == contentState.Value.Contents[item.index].subSection;

                                        bool matchTypeSections = type == contentState.Value.Contents[item.index].page 
                                        && sections == contentState.Value.Contents[item.index].section
                                        && subSections == "all";

                                        bool matchType = type == contentState.Value.Contents[item.index].page
                                        && sections == "all";

                                        int indexParsed = contentState.Value.Contents[item.index].id;

                                        @if (item.contentHolder != null)
                                        {

                                            @if (matchTypeSectionsSubSections && contentNotNull)
                                            {
                                                var localCount = count;

                                                <WikiBlock
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    TinyAPIKey="@TinyAPIKey"
                                                    count="@count"
                                                    indexParsed="@indexParsed"
                                                    username="@username"
                                                />

                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (matchTypeSections && contentNotNull)
                                            {
                                                var localCount = count;

                                                <WikiBlock
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    TinyAPIKey="@TinyAPIKey"
                                                    count="@count"
                                                    indexParsed="@indexParsed"
                                                    username="@username" />

                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (matchType || type == null && contentNotNull)
                                            {
                                                var localCount = count;

                                                <WikiBlock
                                            inline="@inline"
                                            matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                            matchTypeSections="@matchTypeSections"
                                            matchType="@matchType"
                                            type="@type"
                                            sections="@sections"
                                            subSections="@subSections"
                                            TinyAPIKey="@TinyAPIKey"
                                            count="@count"
                                            indexParsed="@indexParsed"
                                            username="@username" />

                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (type == "all" && contentNotNull)
                                            {
                                                var localCount = count;

                                                <WikiBlock
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    TinyAPIKey="@TinyAPIKey"
                                                    count="@count"
                                                    indexParsed="@indexParsed"
                                                    username="@username" />

                                                @* Increment global count *@
                                                count++;
                                            }
                                            else
                                            {
                                                if (contentState.Value.Contents[item.index].page == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing title for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                                else if (contentState.Value.Contents[item.index].section == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing section name for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                                else if (contentState.Value.Contents[item.index].subSection == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing subSection name for something in section: " + contentState.Value.Contents[item.index].section)
                                                }
                                                else if (contentState.Value.Contents[item.index].content == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing content for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                            }
                                        }
                                        else
                                        {
                                            Console.WriteLine("Suppressing error?");
                                        }
                                    }
                                }
                                @if (type == "add")
                                {
                                    @if (contentState.Value.Contents == null)
                                    {
                                        <p><em> </em></p>
                                    }
                                    else
                                    {
                                        contentState.Value.IsEditing[0] = false;
                                        <div class="bg-dark text-primary container-fluid">
                                            <div class="row">
                                                <div class="col-6">
                                                    @* Dropdown for section type *@
                                                    <div class="form-group">
                                                        <label class="form-label bg-dark text-light" for="typeDropdown">Select Type:</label>
                                                        <select class="form-control form-control-dark bg-dark text-primary border-primary" id="typeDropdown" @bind="typeDropdown">
                                                            <option value="Default" disabled selected>Select a type</option>
                                                            @foreach (var group in contentState.Value.Contents!.GroupBy(ch => ch.page))
                                                            {
                                                                <option value="@group.First().page">@group.Key</option>
                                                            }
                                                            <option value="Add">Add New</option>
                                                        </select>
                                                        @if (typeDropdown == "Add")
                                                        {
                                                            <input type="text" class="form-control form-control-dark bg-dark text-primary border-primary mt-2" placeholder="Enter new type name" @bind="newTypeDropdown" />
                                                        }
                                                    </div>
                                                    @* Text field for section name *@
                                                    <div class="form-group">
                                                        <label class="form-label bg-dark text-light" for="sectionDropdown">Select Section:</label>
                                                        <select class="form-control form-control-dark bg-dark text-primary border-primary" id="sectionDropdown" @bind="sectionName">
                                                            <option value="Default" disabled selected>Select a type, then section</option>
                                                            @foreach (var group in contentState.Value.Contents!.Where(ch => ch.page == typeDropdown).GroupBy(ch => ch.section))
                                                            {
                                                                <option value="@group.First().section">@group.Key</option>
                                                            }
                                                            <option value="Add">Add New</option>
                                                        </select>
                                                        @if (sectionName == "Add")
                                                        {
                                                            <input type="text" class="form-control form-control-dark bg-dark text-primary border-primary mt-2" placeholder="Enter new section name" @bind="newSectionName" />
                                                        }
                                                    </div>
                                                    @* Text field for subSection name *@
                                                    <div class="form-group bg-dark text-primary">
                                                        <label class="form-label bg-dark text-light mt-1" for="sectionContent">Select subSection:</label>
                                                        <input type="text" class="form-control form-control-dark bg-dark text-primary border-primary" id="sectionContent" placeholder="Name of the new subSection" @bind="subSectionName">
                                                    </div>
                                                    @* Add section button *@
                                                    <button class="btn btn-outline-primary mt-2" @onclick="(() => AddNewSection(username!))">Add New subSection</button>
                                                </div>
                                                <div class="col-6">
                                                    @* Spacing *@
                                                </div>
                                            </div>
                                        </div>
                                    }
                                }
                            </tbody>
                        </table>
                    </div>
                </Authorized>
                <NotAuthorized>
                    @{var count = 0;}
                    <div class="mainTable">
                        <table class="table rounded table-dark @(inline == true ? "border-bottom" : "table-borderless table-striped")">
                            @* @(inline == true ? "" : "") *@
                            <tbody>
                                @* Pragmatically populate the table using my custom object array *@
                                @if (type == "Search")
                                {
                                    foreach (var item in searchResults
                                    .OrderByDescending(x => x.Score)
                                    .Select((searchResult, index) => new { searchResult, index }))
                                    {
                                        var localCount = count;
                                        int indexParsed = item.searchResult.Content.id;
                                        <WikiBlockNoAuth 
                                            inline="@inline"
                                            matchTypeSectionsSubSections="false"
                                            matchTypeSections="false"
                                            matchType="false"
                                            type="@type"
                                            sections="@sections"
                                            subSections="@subSections"
                                            count="@count"
                                            indexParsed="@indexParsed" />
                                            @* localCount=localCount *@
                                        <p>Search Score: @item.searchResult.Score</p>
                                        @* Increment global count *@
                                        count++;
                                    }
                                }
                                else
                                {
                                    @foreach (var item in contentState.Value.Contents
                                    .OrderBy(x => x.page)
                                    .ThenBy(x => x.section)
                                    .ThenBy(x => x.subSection)
                                    .Select((contentHolder, index) => new { contentHolder, index }))
                                    {
                                        bool contentNotNull = contentState.Value.Contents[item.index].page != null 
                                        && contentState.Value.Contents[item.index].section != null 
                                        && contentState.Value.Contents[item.index].subSection != null 
                                        && contentState.Value.Contents[item.index].content != null;

                                        bool matchTypeSectionsSubSections = type == contentState.Value.Contents[item.index].page 
                                        && sections == contentState.Value.Contents[item.index].section 
                                        && subSections == contentState.Value.Contents[item.index].subSection;

                                        bool matchTypeSections = type == contentState.Value.Contents[item.index].page 
                                        && sections == contentState.Value.Contents[item.index].section
                                        && subSections == "all";

                                        bool matchType = type == contentState.Value.Contents[item.index].page
                                        && sections == "all";

                                        int indexParsed = contentState.Value.Contents[item.index].id;

                                        @if (item.contentHolder != null)
                                        {

                                            @if (matchTypeSectionsSubSections && contentNotNull)
                                            {
                                                var localCount = count;
                                                <WikiBlockNoAuth 
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="indexParsed"  />
                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (matchTypeSections && contentNotNull)
                                            {
                                                var localCount = count;
                                                <WikiBlockNoAuth 
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="indexParsed"  />
                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if ((matchType || type == null) && contentNotNull)
                                            {
                                                var localCount = count;
                                                <WikiBlockNoAuth
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="indexParsed" />
                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (type == "all" && contentNotNull)
                                            {
                                                var localCount = count;
                                                <WikiBlockNoAuth 
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="indexParsed"  />
                                                @* Increment global count *@
                                                count++;
                                            }
                                            else
                                            {
                                                if (contentState.Value.Contents[item.index].page == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing title for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                                else if (contentState.Value.Contents[item.index].section == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing section name for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                                else if (contentState.Value.Contents[item.index].subSection == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing subSection name for something in section: " + contentState.Value.Contents[item.index].section)
                                                }
                                                else if (contentState.Value.Contents[item.index].content == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing content for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                            }
                                        }
                                        else
                                        {
                                            Console.WriteLine("Suppressing error?");
                                        }
                                    }
                                }
                            </tbody>
                        </table>
                    </div>
                    </NotAuthorized>
                </AuthorizeView>
            }
        </div>
    </div>
</div>

@code {
    @* Declare custom object array will change this for a dictionary *@
    //public contentHolder[]? contentState.Value.Contents;
    //public contentHolder[]? tempContentHolderList;
    //public contentHolder? tempContent;
    //public string? tempContentSection;
    public List<SearchResult> searchResults = new List<SearchResult>(); 
    public string? searchTerm { get; set; }
    private string Logo = "Logo.png";
    public string loadingMSG = "Loading...";
    @* Declare var for current user selection *@
    [Parameter]
    public string? type { get; set; }
    [Parameter]
    public string? sections { get; set; }
    [Parameter]
    public string? subSections { get; set; }
    @* Declare Global Vars *@
    private bool? inline { get; set; } = true;
    //private List<contentHolder> initialContent;
    //private bool[]? IsEditing;
    private string? typeDropdown;
    private string? newTypeDropdown;
    private string? sectionName;
    private string? subSectionName;
    private string? newSectionName;
    private int sectionBeingEdited;
    private string TinyAPIKey = "7so5re0foy5ocvnv7m3m3rznoi0hiar7wrg9w0hk2bkgfshl";
    @* Declare/Initialize variables for API communication *@
    private string? commitText = "Test From Wiki";
    //public Dictionary<string, string> shaDictionary = new Dictionary<string, string>();
    //private int? updateCount = 0;
    //private bool isContentLoaded { get; set; } = false;
    //private bool initiating = true;

    private ElementReference cardsWrapper; // This holds reference to our cards container
    private int currentIndex = 0; // Keeps track of current slide
    private int totalCards => cards.Count;
    private string myStyle = ""; // Style string that we'll bind to
    private double cardWidth = 0;
    private int visibleCards = 0;
    private string transitionStyle = "transition: transform 0.3s ease;";
    private CancellationTokenSource cts = new CancellationTokenSource();
    private List<Card> DisplayCards => cards.Concat(cards.Take(visibleCards)).ToList();
    private List<Card> cards = new List<Card>
    {
        new Card
        {
            Title = "AI Assistant!",
            Text = "Search the site faster with AI",
            Link = "/navBot",
            ButtonText = "Try It Out!"
        },
        new Card
        {
            Title = "My Novel Genetic Algorithm",
            Text = "A Genetic Algorithm I developed myself.",
            Link = "/EvolutionTFNEAT",
            ButtonText = "Try It Out!"
        },
        new Card
        {
            Title = "ChatBot!",
            Text = "Try out GPT-4 for free!",
            Link = "/chat",
            ButtonText = "Try It Out!"
        },
        new Card
        {
            Title = "Wiki!",
            Text = "View or edit articles about me!",
            Link = "/all",
            ButtonText = "Try It Out!"
        },
        new Card
        {
            Title = "My Dissertation",
            Text = "Read my dissertation on AI Interpretability!",
            Link = "/Dissertation/Dissertation",
            ButtonText = "Read Here!"
        },
        new Card
        {
            Title = "C.V.",
            Text = "Read my CV to see my qualifications!",
            Link = "/Dissertation/CV",
            ButtonText = "Read Here!"
        },
        new Card
        {
            Title = "Old Evolution Sim",
            Text = "My first attempt at implementing a basic Genetic Algorithm",
            Link = "/EvolutionTF",
            ButtonText = "Try It Out!"
        },
    };


    [Inject] public AuthenticationStateProvider? AuthenticationStateProvider { get; set; }

    @* Initialize page.  Using Async initialization as I want to load content from API before rendering *@
    protected override async Task OnInitializedAsync()
    {
        //Console.WriteLine("mainContent.razor initialised");
        //try
        //{
            @* Call method to make GET request *@
            //await Task.WhenAll(GetAllContentFromGitHubRepo<contentHolder>(false));
            contentState.StateChanged += ContentStateChanged;
            @* Initialize control variables after populating contentState.Value.Contents *@

        @* Add event handler to nagigation change event to reset IsEditing array *@
        Navigation.LocationChanged += LocationChanged!;
        base.OnInitialized();
        //}
        //catch (Exception ex)
        //{
        //    Console.WriteLine("Error: " + ex.Message);
        //    loadingMSG += "Error Loading Content: " + ex.Message;
        //    StateHasChanged();
        //}

        while (true)
        {
            try
            {
                await Task.Delay(5000, cts.Token);  // Use the token here
            }
            catch (TaskCanceledException)
            {
                // Reset the CancellationTokenSource for future delays
                await Task.Delay(150);
                cts = new CancellationTokenSource();
            }
            SlideCards();
            StateHasChanged();
        }
    }

    private void SlideCards()
    {
        currentIndex++;

        // Check if the next slide would be the start (after the duplicate cards are fully in view)
        if (currentIndex + visibleCards == totalCards + visibleCards)
        {
            cts.Cancel();  // Reset the delay
        }

        // Now handle the jump back to the start
        if (currentIndex + visibleCards > totalCards + visibleCards)
        {
            currentIndex = 0;
            myStyle = $"transform: translateX(0px);";
            StateHasChanged();
            return;
        }

        //Console.WriteLine("Moving by" + currentIndex * cardWidth);
        myStyle = $"transform: translateX({currentIndex * -cardWidth}px); {transitionStyle}";
    }


    private async void ContentStateChanged(object? sender, EventArgs e)
    {
        if (contentState.Value.FileCount == contentState.Value.LoadedFilesCount)
        {
            // This will run every time the state changes
            //var orderedContentHolderList = contentState.Value.Contents.OrderBy(x => x.page).ThenBy(x => x.section).ThenBy(x => x.subSection);
            //Add this back
            //contentState.Value.Contents = orderedContentHolderList.ToArray();
            //InitializeContentHolderList();
            //Array.Resize(ref tempContentHolderList, contentState.Value.Contents.Count);
            //timer();
            //Add this back
            //Array.Resize(ref initialContent, contentState.Value.Contents!.Count);
            //IsEditing = new bool[contentState.Value.Contents.Count];
            InvokeAsync(StateHasChanged); // Update the UI
            await Task.Delay(500);
            cardWidth = await JSRuntime.InvokeAsync<double>("carouselHelper.getCardWidth");
            visibleCards = await JSRuntime.InvokeAsync<int>("carouselHelper.getVisibleCards");
            await JSRuntime.InvokeVoidAsync("carouselHelper.addResizeListener", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("registerComponentInstance", DotNetObjectReference.Create(this));

        }
    }

    [JSInvokable("RecalculateSizes")]
    public async Task RecalculateSizes()
    {
        //Console.WriteLine(cardWidth + ": before");
        currentIndex = 0;
        myStyle = $"transform: translateX(0px);";
        StateHasChanged();
        await Task.Delay(500);
        cardWidth = await JSRuntime.InvokeAsync<double>("carouselHelper.getCardWidth");
        visibleCards = await JSRuntime.InvokeAsync<int>("carouselHelper.getVisibleCards");
        //Console.WriteLine(cardWidth + ": after");
    }

    public void Dispose()
    {
        JSRuntime.InvokeVoidAsync("carouselHelper.unregisterComponentInstance");
        contentState.StateChanged -= ContentStateChanged;
    }


    public class Card
    {
        public string Title { get; set; }
        public string Text { get; set; }
        public string Link { get; set; }
        public string ButtonText { get; set; }
    }

    protected override async void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            //Code to execute once
            await GetAuthenticationState();
        }
        base.OnAfterRender(firstRender);
    }

    //public void InitializeContentHolderList()
    //{
    //    for (int i = 0; i < contentState.Value.Contents?.Count; i++)
    //    {
    //        contentState.Value.Contents[i].id = i;
    //    }
    //}

    //public void timer()
    //{
    //    Timer timer = new Timer(60000); // 60000 milliseconds = 1 minute
    //    timer.Elapsed += Timer_Elapsed;
    //    timer.Start();
    //}

    //private async void Timer_Elapsed(object? sender, ElapsedEventArgs? e)
    //{
    //    @* Updated section *@
    //    Dictionary<string, string> tempShaDictionary = new Dictionary<string, string>();
    //    tempShaDictionary = new Dictionary<string, string>(shaDictionary); // Use a copy of the dictionary to prevent reference issues
    //    await GetAllContentFromGitHubRepo<contentHolder>(true);

    //    @* Updated code to compare dictionaries *@
    //    List<string> mismatchedKeys = new List<string>();

    //    foreach (var entry in tempShaDictionary)
    //    {
    //        if (shaDictionary.ContainsKey(entry.Key) && shaDictionary[entry.Key] != entry.Value)
    //        {
    //            mismatchedKeys.Add(entry.Key);
    //        }
    //    }

    //    if (mismatchedKeys.Count > 0)
    //    {
    //        Console.WriteLine("Found out of date section, updating...");
    //        if (IsEditing!.All(x => x == false))
    //        {
    //            //Add this back
    //            //Array.Copy(tempContentHolderList, contentState.Value.Contents, contentState.Value.Contents.Count);
    //        }
    //        else
    //        {
    //            await JSRuntime.InvokeVoidAsync("alert", "Content is out of date with database, refreshing");
    //            for (int i = 0; i < IsEditing!.Length; i++)
    //            {
    //                if (IsEditing[i] == true)
    //                {
    //                    tempContentSection = contentState.Value.Contents?[i].content;
    //                    //add this back
    //                    //Array.Copy(tempContentHolderList, contentState.Value.Contents, contentState.Value.Contents.Count);
    //                    contentState.Value.Contents[i].content = tempContentSection;
    //                }
    //            }
    //        }
    //        InitializeContentHolderList();
    //    }
    //}
    @* Checks current authenticaiton state *@
    private async Task GetAuthenticationState()
    {
        var authenticationState = await AuthenticationStateProvider!.GetAuthenticationStateAsync();
        var user = authenticationState.User;
        //if (user.Identity!.IsAuthenticated)
        //{
        //    var username = user.Identity.Name;
        //}
        //else
        //{
        //    Navigation.NavigateTo($"/authentication/login");
        //}
    }
    
    private void LocationChanged(object sender, LocationChangedEventArgs e)
    {
        ClearIsEditingArray();
    }
    @* Method called in a few places, but should close all open editors, and save any content thats being edited currently *@
    private void ClearIsEditingArray()
    {
        Dispatcher.Dispatch(new ResetIsEditingAction());
        //if (!IsEditing!.All(x => x == false))
        //{
        //    Save((0, "Internal save by navigating away", sectionBeingEdited, true));
        //}
        
    }
@*
    private void UpdateContentHolderList(contentHolder[] newContentHolder)
    {
        //add this back
        //contentState.Value.Contents = newContentHolder;
        InitializeContentHolderList();
    }*@
    @* Detects when text changes in the search component, and triggers search methods *@
    private void SearchTermChanged(string searchPhrase)
    {
        searchTerm = searchPhrase;
        if (searchTerm!.Length > 1)
        {
            @* Not a good solution, I need to add entries to contentState.Value.Contents that can be searched through, but dont get rendered. *@
            if (string.Equals(searchTerm, "CV", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/CV");
            }
            else if (string.Equals(searchTerm, "Dissertation", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/Dissertation");
            }
            else if (string.Equals(searchTerm, "Artifact", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/Artifact");
            }
            else if (string.Equals(searchTerm, "ChatBot", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/chat");
            }
            else if (searchTerm.Contains("Assistant", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/navBot");
            }
            else
            {
                //add this back
                searchResults = PerformSearch(searchTerm, contentState.Value.Contents);
            }
        }
        if (type != "Search")
        {
            if (searchTerm!.Length > 1)
            {
                Navigation.NavigateTo($"/Search");
            }
        }
        else
        {
            if (String.IsNullOrWhiteSpace(searchTerm))
            {
                Navigation.NavigateTo($"/all");
            }
        }

    }
    @* Build a list of search results including scores *@
    private List<SearchResult> PerformSearch(string searchTerm, List<contentHolder> contentList)
    {
        var results = new List<SearchResult>();

        for (int i = 0; i < contentList.Count; i++)
        {
            var content = contentList[i];
            int score = CalculateMatchScore(searchTerm, content);
            if (score > 0)
            {
                results.Add(new SearchResult{ Score = score, Content = content });
            }
        }
        return results.OrderByDescending(r => r.Score).ToList();
    }

    @* Calculate score for each item in contentState.Value.Contents.  Might need to play with the given scores for each match type *@
    public int CalculateMatchScore(string searchTerm, contentHolder content)
    {
        int score = 0;
        // Normalize search term
        searchTerm = Regex.Replace(searchTerm.Trim(), @"\p{P}", "").ToLower();

        // Split the search term into words
        var searchWords = searchTerm.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Strip HTML tags from content and normalize
        var strippedContent = Regex.Replace(content.content, "<.*?>", String.Empty);
        strippedContent = Regex.Replace(strippedContent, @"\p{P}", "").ToLower();

        // Split the content into words
        var contentWords = strippedContent.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Normalize title words
        var title = $"{content.page} {content.section} {content.subSection}";
        title = Regex.Replace(title, "<.*?>", String.Empty);
        title = Regex.Replace(title, @"\p{P}", "").ToLower();

        var titleWords = title.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Check if the entire search term appears in the content or title
        if (strippedContent.Contains(searchTerm) || title.Contains(searchTerm))
        {
            score += 4;
        }

        // Check each word in the content
        foreach (var word in contentWords)
        {
            // Check full word matches
            if (searchWords.Any(searchWord =>
                string.Equals(word, searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 2;
            }// Check partial matches
            else if (searchWords.Any(searchWord =>
                word.Contains(searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 1;
            }
        }

        // Check each word in the title
        foreach (var word in titleWords)
        {
            // Check full word matches
            if (searchWords.Any(searchWord =>
                string.Equals(word, searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 3;
            }// Check partial matches
            else if (searchWords.Any(searchWord =>
                word.Contains(searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 2;
            }
        }

        return score;
    }

@*    private void RefreshMe()
    {
        StateHasChanged();
    }*@

    @* Set sections IsEditing to false, and set the content to the stored previous state *@
@*    private async void Cancel((int localSectionNo, int globalSectionNo) parameters)
    {
        int localSectionNo = parameters.localSectionNo;
        int globalSectionNo = parameters.globalSectionNo;
        if (initialContent![globalSectionNo] != null)
        {
            contentState.Value.Contents![globalSectionNo].content = initialContent[globalSectionNo].content!;
        }
        else
        {
            await RemoveSection((contentState.Value.Contents!.Count - 1, "... (New Section)"));
        }
        IsEditing![localSectionNo] = false;
        InitializeContentHolderList();
    }*@
@*    private void CancelNew(int localSectionNo)
    {
        IsEditing![localSectionNo] = false;
    }*@

    @* Add a new object to my array from user input *@
    private async Task AddNewSection(string username)
    {
        @* Using data binding to tie user selection to these vars *@
        string? subName = subSectionName;
        string? newType = newTypeDropdown;
        string? newName = newSectionName;
        string finalType;
        string finalName;
        if (typeDropdown == "Add")
        {
            finalType = newTypeDropdown!;
        }
        else
        {
            finalType = typeDropdown!;
        }
        if (sectionName == "Add")
        {
            finalName = newSectionName!;
        }
        else
        {
            finalName = sectionName!;
        }
       @* if (!String.IsNullOrWhiteSpace(finalType) && !String.IsNullOrWhiteSpace(finalName) && !String.IsNullOrWhiteSpace(subName))
        {
            if (!ContentState.Value.Contents.Any(item => item.subSection.Contains(subName)))
            {
                @* Best way to add to an array is to resize then initialize the new index 
                //add this back
                //Array.Resize(ref contentState.Value.Contents, contentState.Value.Contents!.Count + 1);
                Array.Resize(ref tempContentHolderList, contentState.Value.Contents!.Count);
                Array.Resize(ref IsEditing, IsEditing!.Length + 1);
                contentState.Value.Contents[contentState.Value.Contents.Count - 1] = new contentHolder
                    {
                        page = finalType,
                        section = finalName,
                        subSection = subName,
                        content = "<p>Enter some details about " + subName + " here.</p>"
                    }; 
                ReInitialize();
                @* Initialize new index on control variables 
                IsEditing[0] = true;
                sectionBeingEdited = contentState.Value.Contents.Count;
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("alert", "subName must be unique. Currently includes partial matches, so any existing subSection name containing " + subName + " will trigger a match");
                searchTerm = subName;
                SearchTermChanged(searchTerm);
            }
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("alert", "Each box must have an entry");
        }*@
    }

    @* Method to remove selected section *@
@*    private async Task RemoveSection((int sectionNo, string username) parameters)
    {
        int sectionNo = parameters.sectionNo;
        string username = parameters.username;
        bool responce = await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete the subSection: " + contentState.Value.Contents[sectionNo].subSection);
        if (responce == true)
        {
            if (contentState.Value.Contents!.Count > 1)
            {
                string? localSection = contentState.Value.Contents[sectionNo].page + contentState.Value.Contents[sectionNo].section;
                string? types = contentState.Value.Contents[sectionNo].page;
                string? sections = contentState.Value.Contents[sectionNo].section;

                contentHolder[] newArray = new contentHolder[contentState.Value.Contents.Count - 1];
                int newArrayIndex = 0;
                for (int i = 0; i < contentState.Value.Contents.Count; i++)
                {
                    if (i != sectionNo)
                    {
                        newArray[newArrayIndex++] = contentState.Value.Contents[i];
                    }
                }
                //add this back
                //contentState.Value.Contents = newArray;
                ReInitialize();
                myStateContainer.SetValue();
                myStateContainer.OnStateChange += RefreshMe;


                contentHolder[] localContentHolderList = contentState.Value.Contents.Where(holder => holder.page == types && holder.section == sections).ToArray();
                var jsonString = JsonConvert.SerializeObject(localContentHolderList);
                if (jsonString == "[]")
                {
                    commitText = "Section removed by: " + username + "";
                    Console.WriteLine("Section Empty, Should remove JSON from db");
                    await DeleteFile(commitText, localSection!);
                }
                else
                {
                    commitText = "subSection removed by : " + username + "";
                    await UpdateJSONOnGitHub(jsonString, commitText!, localSection!);
                }
            }
        }
        InitializeContentHolderList();
    }*@
    @* Method for uploading content to GitHub API via PUT *@
@*    private async Task UpdateJSONOnGitHub(string jsonString, string commitMessage, string section)
    {
        try
        {
            using (var client = new HttpClient())
            {
                var sha = shaDictionary[section];

                Console.WriteLine("Saving2");
                Console.WriteLine("sha before: " + sha);
                // Define the request body, encoding the content string as base64
                Console.WriteLine(jsonString);
                var body = new
                {
                    message = commitMessage,
                    content = Convert.ToBase64String(Encoding.UTF8.GetBytes(jsonString)),
                    sha = sha
                };

                // Serialize the body object and encode
                var json = JsonConvert.SerializeObject(body);
                var contentAndMessage = new StringContent(json, Encoding.UTF8, "application/json");

                // Send the PUT request to the PHP proxy
                var response = await client.PutAsync($"https://samdenton.tech/GithubPut-proxy.php?section={section}", contentAndMessage);
                var responseBytes = await response.Content.ReadAsByteArrayAsync();

                // Detect and remove potential Byte Order Mark (BOM)
                var bom = Encoding.UTF8.GetPreamble();
                if (responseBytes.Take(bom.Length).SequenceEqual(bom))
                {
                    responseBytes = responseBytes.Skip(bom.Length).ToArray();
                }

                // Convert bytes to string
                var responceHeaders = Encoding.UTF8.GetString(responseBytes);
                @* Get new sha value from PUT response headers 
                Console.WriteLine("response before parsing too root: " + responceHeaders);
                var gitContent = JsonConvert.DeserializeObject<PUTContentParser>(responceHeaders);
                Console.WriteLine("response before parsing to content: " + gitContent);
                shaDictionary[section] = gitContent.content.sha;
                Console.WriteLine("sha after: " + shaDictionary[section]);
                @* Ensure the request was successful 
                response.EnsureSuccessStatusCode();
                if (!response.IsSuccessStatusCode)
                {
                    throw new Exception("Error updating content: " + response.ReasonPhrase);
                }

            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
            loadingMSG += "Error Loading Content: " + ex.Message;
            StateHasChanged();
        }
    }*@

@*    private async Task DeleteFile(string commitMessage, string section)
    {
        var sha = shaDictionary[section];
        var client = new HttpClient();

        var content = new StringContent(JsonConvert.SerializeObject(new
        {
            message = commitMessage,
            sha = sha
        }), Encoding.UTF8, "application/json");

        var response = await client.DeleteAsync($"https://samdenton.tech/GithubDelete-proxy.php?section={section}&sha={sha}");

        if (!response.IsSuccessStatusCode)
        {
            throw new Exception("Error deleting file: " + response.ReasonPhrase);
        }
    }*@
}
