@page "/{type?}/{sections?}/{subSections?}"
@using System.Net;
@using System.Net.Http;
@using System.Net.Http.Headers;
@using Newtonsoft.Json;
@using System.Timers;
@using System.Text.RegularExpressions;
@using PersonalWebsite.Shared.Model;
@using PersonalWebsite.Store.Actions;
@using PersonalWebsite.Store.State;
@using Fluxor;
@inject IState<ContentState> contentState
@inject IDispatcher Dispatcher
@inject HttpClient Http;
@inject NavigationManager Navigation;
@inject MyStateContainer myStateContainer;
@inject IJSRuntime JSRuntime;
@* Using Authorize View to only load content when user is authenticated. The editor is disabled when not authenticated *@

<PageTitle>Wiki</PageTitle>
@* Moved the searchBar marup and logic to a component so it's on all pages *@
<SearchBar 
    type="@type"
    SearchTermChanged="SearchTermChanged"
    IsSearchDisabled="false"  />
@* Using bootstrap container for layout on main content.  Using some grid layout elements *@
<div class="container-fluid mx-0 ps-0">
    <div class="row mx-0 ps-0 gx-3">
        <div class="col">
            @* Toggle between the 2 editor types.  This can be moved to one of the other conditionals doing the same. *@
            @if (type != null)
            {
                <div class="ms-1 form-group form-check form-switch kudosTextToggle">
                    <label class="form-check-label" for="sliderToggle">Light Editor</label>
                    <input type="checkbox" class="form-check-input inputCheck" id="sliderToggle" @bind="inline" @onclick="(() => ClearIsEditingArray())" />
                </div>
            }
            @* Wtf is this block... really need to tidy this up.  Most of if can move to the main foreach loop conditionals *@
            @if (type != "all" && type != null && sections != "all" && subSections != "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@sections <small class="text-muted">@subSections </small></h1>
            }
            else if (type != "all" && sections != "all" && subSections == "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@type <small class="text-muted">@sections </small></h1>
            }
            else if (type != "all" && sections == "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@type <small class="text-muted"></small></h1>
            }
            else if (type == "all")
            {
                <h1 class="kudosTextTop"></h1>
            }
            else if (type == "add")
            {
                <h1 class="kudosTextTop">Add New Section <small class="text-muted"></small></h1>
            }
            else if (type == "Search")
            {
                <h1 class="kudosTextTop">Search Results <small class="text-muted"></small></h1>
            }
            @* Show a loading message before API call is complete *@
            @* Should also add failure case if the API call returns 404 *@
            @*add back 'isContentLoaded == false || ' to conditional*@
            @if (contentState.Value.Contents == null || type == null)
            {
                <div class="container-fluid bg-dark text-light">
                    <div class="row">
                        <div class="col-12 text-center">
                            <img src="@Logo" alt="Company Logo" height="165" width="272" class="mx-auto d-block img-fluid homeImg" />
                            <h1 class="mt-3">Welcome to my Web App</h1>
                        </div>
                    </div>
                    <div class="loaderContiner">
                        @if (contentState.Value.Contents == null)
                        {
                            <div class="loader">
                                <div class="loaderBar"></div>
                            </div>
                        }
                    </div>
                    <div class="row">
                        <div class="col-12 text-center">
                            <p>This is a personal site for projects. A space for me to learn and develop skills, as well as display my credentials.  Over time I will populate it with different projects i'm working on.  The site is structured as a Wiki, so while logged in, most of the content is editable.  It's also a Progressive Web App(PWA), so feel free to install locally!</p>
                        </div>
                    </div>
                </div>
            }
            else
            {
                <AuthorizeView>
                    <Authorized>
                    @{var count = 0;
                    var username = @context.User.Identity!.Name;}
                    <div class="mainTable">
                        <table class="mainTable table rounded table-dark @(inline == true ? "border-bottom" : "table-borderless table-striped")">
                            @* @(inline == true ? "" : "") *@
                            <tbody>
                                @if (type == "Search")
                                {
                                    foreach (var item in searchResults
                                    .OrderByDescending(x => x.Score)
                                    .Select((searchResult, index) => new { searchResult, index }))
                                    {
                                        var localCount = count;
                                        int indexParsed = item.searchResult.Content.id;
                                        <WikiBlock 
                                            inline="@inline"
                                            matchTypeSectionsSubSections="false"
                                            matchTypeSections="false"
                                            matchType="false"
                                            type="@type"
                                            sections="@sections"
                                            subSections="@subSections"
                                            TinyAPIKey="@TinyAPIKey"
                                            count="@count"
                                            localCount=localCount
                                            indexParsed="@indexParsed"
                                            username="@username"
                                            RemoveSection="@(e => RemoveSection((e.Item1, e.Item2)))"
                                            ClearContent="@(e => ClearContent((e.Item1, e.Item2)))"
                                            OnDataChanged="UpdateContentHolderList"     />
                                        <p>Search Score: @item.searchResult.Score</p>
                                        @* Increment global count *@
                                        count++;
                                    }
                                }
                                else if (type == "add" && IsEditing![0] == true && contentState.Value.Contents != null)
                                {
                                    <WikiBlock
                                        inline="@inline"
                                        matchTypeSectionsSubSections="false"
                                        matchTypeSections="false"
                                        matchType="false"
                                        type="@type"
                                        sections="@sections"
                                        subSections="@subSections"
                                        TinyAPIKey="@TinyAPIKey"
                                        count="0"
                                        localCount=0
                                        indexParsed=0
                                        username="@username"
                                        RemoveSection="@(e => RemoveSection((e.Item1, e.Item2)))"
                                        ClearContent="@(e => ClearContent((e.Item1, e.Item2)))" />
                                }
                                else
                                {
                                    @* Pragmatically populate the table using my custom object array *@
                                    @foreach (var item in contentState.Value.Contents
                                    .OrderBy(x => x.page)
                                    .ThenBy(x => x.section)
                                    .ThenBy(x => x.subSection)
                                    .Select((contentHolder, index) => new { contentHolder, index }))
                                    {
                                        bool contentNotNull = contentState.Value.Contents[item.index].page != null 
                                        && contentState.Value.Contents[item.index].section != null 
                                        && contentState.Value.Contents[item.index].subSection != null 
                                        && contentState.Value.Contents[item.index].content != null;

                                        bool matchTypeSectionsSubSections = type == contentState.Value.Contents[item.index].page 
                                        && sections == contentState.Value.Contents[item.index].section 
                                        && subSections == contentState.Value.Contents[item.index].subSection;

                                        bool matchTypeSections = type == contentState.Value.Contents[item.index].page 
                                        && sections == contentState.Value.Contents[item.index].section
                                        && subSections == "all";

                                        bool matchType = type == contentState.Value.Contents[item.index].page
                                        && sections == "all";

                                        int indexParsed = contentState.Value.Contents[item.index].id;

                                        @if (item.contentHolder != null)
                                        {

                                            @if (matchTypeSectionsSubSections && contentNotNull)
                                            {
                                                var localCount = count;

                                                <WikiBlock
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    TinyAPIKey="@TinyAPIKey"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="@indexParsed"
                                                    username="@username"
                                                    RemoveSection="@(e => RemoveSection((e.Item1, e.Item2)))"
                                                    ClearContent="@(e => ClearContent((e.Item1, e.Item2)))"
                                                    OnDataChanged="UpdateContentHolderList"
                                                />

                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (matchTypeSections && contentNotNull)
                                            {
                                                var localCount = count;

                                                <WikiBlock
                                            inline="@inline"
                                            matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                            matchTypeSections="@matchTypeSections"
                                            matchType="@matchType"
                                            type="@type"
                                            sections="@sections"
                                            subSections="@subSections"
                                            TinyAPIKey="@TinyAPIKey"
                                            count="@count"
                                            localCount=localCount
                                            indexParsed="@indexParsed"
                                            username="@username"
                                            RemoveSection="@(e => RemoveSection((e.Item1, e.Item2)))"
                                            ClearContent="@(e => ClearContent((e.Item1, e.Item2)))"
                                            OnDataChanged="UpdateContentHolderList" />

                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (matchType || type == null && contentNotNull)
                                            {
                                                var localCount = count;

                                                <WikiBlock
                                            inline="@inline"
                                            matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                            matchTypeSections="@matchTypeSections"
                                            matchType="@matchType"
                                            type="@type"
                                            sections="@sections"
                                            subSections="@subSections"
                                            TinyAPIKey="@TinyAPIKey"
                                            count="@count"
                                            localCount=localCount
                                            indexParsed="@indexParsed"
                                            username="@username"
                                            RemoveSection="@(e => RemoveSection((e.Item1, e.Item2)))"
                                            ClearContent="@(e => ClearContent((e.Item1, e.Item2)))"
                                            OnDataChanged="UpdateContentHolderList" />

                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (type == "all" && contentNotNull)
                                            {
                                                var localCount = count;

                                                <WikiBlock
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    TinyAPIKey="@TinyAPIKey"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="@indexParsed"
                                                    username="@username"
                                                    RemoveSection="@(e => RemoveSection((e.Item1, e.Item2)))"
                                                    ClearContent="@(e => ClearContent((e.Item1, e.Item2)))"
                                                    OnDataChanged="UpdateContentHolderList"
                                                />

                                                @* Increment global count *@
                                                count++;
                                            }
                                            else
                                            {
                                                if (contentState.Value.Contents[item.index].page == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing title for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                                else if (contentState.Value.Contents[item.index].section == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing section name for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                                else if (contentState.Value.Contents[item.index].subSection == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing subSection name for something in section: " + contentState.Value.Contents[item.index].section)
                                                }
                                                else if (contentState.Value.Contents[item.index].content == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing content for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                            }
                                        }
                                        else
                                        {
                                            Console.WriteLine("Suppressing error?");
                                        }
                                    }
                                }
                                @if (type == "add")
                                {
                                    @if (contentState.Value.Contents == null || isContentLoaded == false || IsEditing == null)
                                    {
                                        <p><em> </em></p>
                                    }
                                    else
                                    {
                                        IsEditing[0] = false;
                                        <div class="bg-dark text-primary container-fluid">
                                            <div class="row">
                                                <div class="col-6">
                                                    @* Dropdown for section type *@
                                                    <div class="form-group">
                                                        <label class="form-label bg-dark text-light" for="typeDropdown">Select Type:</label>
                                                        <select class="form-control form-control-dark bg-dark text-primary border-primary" id="typeDropdown" @bind="typeDropdown">
                                                            <option value="Default" disabled selected>Select a type</option>
                                                            @foreach (var group in contentState.Value.Contents!.GroupBy(ch => ch.page))
                                                            {
                                                                <option value="@group.First().page">@group.Key</option>
                                                            }
                                                            <option value="Add">Add New</option>
                                                        </select>
                                                        @if (typeDropdown == "Add")
                                                        {
                                                            <input type="text" class="form-control form-control-dark bg-dark text-primary border-primary mt-2" placeholder="Enter new type name" @bind="newTypeDropdown" />
                                                        }
                                                    </div>
                                                    @* Text field for section name *@
                                                    <div class="form-group">
                                                        <label class="form-label bg-dark text-light" for="sectionDropdown">Select Section:</label>
                                                        <select class="form-control form-control-dark bg-dark text-primary border-primary" id="sectionDropdown" @bind="sectionName">
                                                            <option value="Default" disabled selected>Select a type, then section</option>
                                                            @foreach (var group in contentState.Value.Contents!.Where(ch => ch.page == typeDropdown).GroupBy(ch => ch.section))
                                                            {
                                                                <option value="@group.First().section">@group.Key</option>
                                                            }
                                                            <option value="Add">Add New</option>
                                                        </select>
                                                        @if (sectionName == "Add")
                                                        {
                                                            <input type="text" class="form-control form-control-dark bg-dark text-primary border-primary mt-2" placeholder="Enter new section name" @bind="newSectionName" />
                                                        }
                                                    </div>
                                                    @* Text field for subSection name *@
                                                    <div class="form-group bg-dark text-primary">
                                                        <label class="form-label bg-dark text-light mt-1" for="sectionContent">Select subSection:</label>
                                                        <input type="text" class="form-control form-control-dark bg-dark text-primary border-primary" id="sectionContent" placeholder="Name of the new subSection" @bind="subSectionName">
                                                    </div>
                                                    @* Add section button *@
                                                    <button class="btn btn-outline-primary mt-2" @onclick="(() => AddNewSection(username!))">Add New subSection</button>
                                                </div>
                                                <div class="col-6">
                                                    @* Spacing *@
                                                </div>
                                            </div>
                                        </div>
                                    }
                                }
                            </tbody>
                        </table>
                    </div>
                </Authorized>
                <NotAuthorized>
                    @{var count = 0;}
                    <div class="mainTable">
                        <table class="table rounded table-dark @(inline == true ? "border-bottom" : "table-borderless table-striped")">
                            @* @(inline == true ? "" : "") *@
                            <tbody>
                                @* Pragmatically populate the table using my customer object array *@
                                @if (type == "Search")
                                {
                                    foreach (var item in searchResults
                                    .OrderByDescending(x => x.Score)
                                    .Select((searchResult, index) => new { searchResult, index }))
                                    {
                                        var localCount = count;
                                        int indexParsed = item.searchResult.Content.id;
                                        <WikiBlockNoAuth 
                                            inline="@inline"
                                            matchTypeSectionsSubSections="false"
                                            matchTypeSections="false"
                                            matchType="false"
                                            type="@type"
                                            sections="@sections"
                                            subSections="@subSections"
                                            count="@count"
                                            localCount=localCount
                                            indexParsed="@indexParsed" />
                                        <p>Search Score: @item.searchResult.Score</p>
                                        @* Increment global count *@
                                        count++;
                                    }
                                }
                                else
                                {
                                    @foreach (var item in contentState.Value.Contents
                                    .OrderBy(x => x.page)
                                    .ThenBy(x => x.section)
                                    .ThenBy(x => x.subSection)
                                    .Select((contentHolder, index) => new { contentHolder, index }))
                                    {
                                        bool contentNotNull = contentState.Value.Contents[item.index].page != null 
                                        && contentState.Value.Contents[item.index].section != null 
                                        && contentState.Value.Contents[item.index].subSection != null 
                                        && contentState.Value.Contents[item.index].content != null;

                                        bool matchTypeSectionsSubSections = type == contentState.Value.Contents[item.index].page 
                                        && sections == contentState.Value.Contents[item.index].section 
                                        && subSections == contentState.Value.Contents[item.index].subSection;

                                        bool matchTypeSections = type == contentState.Value.Contents[item.index].page 
                                        && sections == contentState.Value.Contents[item.index].section
                                        && subSections == "all";

                                        bool matchType = type == contentState.Value.Contents[item.index].page
                                        && sections == "all";

                                        int indexParsed = contentState.Value.Contents[item.index].id;

                                        @if (item.contentHolder != null)
                                        {

                                            @if (matchTypeSectionsSubSections && contentNotNull)
                                            {
                                                var localCount = count;
                                                <WikiBlockNoAuth 
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="indexParsed"  />
                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (matchTypeSections && contentNotNull)
                                            {
                                                var localCount = count;
                                                <WikiBlockNoAuth 
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="indexParsed"  />
                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if ((matchType || type == null) && contentNotNull)
                                            {
                                                var localCount = count;
                                                <WikiBlockNoAuth
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="indexParsed" />
                                                @* Increment global count *@
                                                count++;
                                            }
                                            else if (type == "all" && contentNotNull)
                                            {
                                                var localCount = count;
                                                <WikiBlockNoAuth 
                                                    inline="@inline"
                                                    matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                    matchTypeSections="@matchTypeSections"
                                                    matchType="@matchType"
                                                    type="@type"
                                                    sections="@sections"
                                                    subSections="@subSections"
                                                    count="@count"
                                                    localCount=localCount
                                                    indexParsed="indexParsed"  />
                                                @* Increment global count *@
                                                count++;
                                            }
                                            else
                                            {
                                                if (contentState.Value.Contents[item.index].page == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing title for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                                else if (contentState.Value.Contents[item.index].section == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing section name for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                                else if (contentState.Value.Contents[item.index].subSection == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing subSection name for something in section: " + contentState.Value.Contents[item.index].section)
                                                }
                                                else if (contentState.Value.Contents[item.index].content == null)
                                                {
                                                    @JSRuntime.InvokeVoidAsync("alert", "Warning, missing content for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                }
                                            }
                                        }
                                        else
                                        {
                                            Console.WriteLine("Suppressing error?");
                                        }
                                    }
                                }
                            </tbody>
                        </table>
                    </div>
                    </NotAuthorized>
                </AuthorizeView>
            }
        </div>
    </div>
</div>

@code {
    @* Declare custom object array will change this for a dictionary *@
    //public contentHolder[]? contentState.Value.Contents;
    public contentHolder[]? tempContentHolderList;
    public contentHolder? tempContent;
    public string? tempContentSection;
    public List<SearchResult> searchResults = new List<SearchResult>(); 
    public string? searchTerm { get; set; }
    private string Logo = "Logo.png";
    public string loadingMSG = "Loading...";
    @* Declare var for current user selection *@
    [Parameter]
    public string? type { get; set; }
    [Parameter]
    public string? sections { get; set; }
    [Parameter]
    public string? subSections { get; set; }
    @* Declare Global Vars *@
    private bool? inline { get; set; } = true;
    private List<contentHolder> initialContent;
    private bool[]? IsEditing;
    private string? typeDropdown;
    private string? newTypeDropdown;
    private string? sectionName;
    private string? subSectionName;
    private string? newSectionName;
    private int sectionBeingEdited;
    private string TinyAPIKey = "7so5re0foy5ocvnv7m3m3rznoi0hiar7wrg9w0hk2bkgfshl";
    @* Declare/Initialize variables for API communication *@
    private string? commitText = "Test From Wiki";
    public Dictionary<string, string> shaDictionary = new Dictionary<string, string>();
    private int? updateCount = 0;
    private bool isContentLoaded { get; set; } = false;
    private bool initiating = true;

    [Inject] public AuthenticationStateProvider? AuthenticationStateProvider { get; set; }

    @* Initialize page.  Using Async initialization as I want to load content from API before rendering *@
    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("mainContent.razor initialised");
        try
        {
            @* Call method to make GET request *@
            //await Task.WhenAll(GetAllContentFromGitHubRepo<contentHolder>(false));
            contentState.StateChanged += ContentStateChanged;
            myStateContainer.OnStateChange += StateHasChanged;
            //myStateContainer.SetValue();
            @* Initialize control variables after populating contentState.Value.Contents *@

            @* Add event handler to nagigation change event to reset IsEditing array *@
            Navigation.LocationChanged += LocationChanged!;
            base.OnInitialized();
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
            loadingMSG += "Error Loading Content: " + ex.Message;
            StateHasChanged();
        }
    }

    private void ContentStateChanged(object? sender, EventArgs e)
    {
        if (contentState.Value.FileCount == contentState.Value.LoadedFilesCount)
        {
            // This will run every time the state changes
            //var orderedContentHolderList = contentState.Value.Contents.OrderBy(x => x.page).ThenBy(x => x.section).ThenBy(x => x.subSection);
            //Add this back
            //contentState.Value.Contents = orderedContentHolderList.ToArray();
            InitializeContentHolderList();
            Array.Resize(ref tempContentHolderList, contentState.Value.Contents.Count);
            timer();
            //Add this back
            //Array.Resize(ref initialContent, contentState.Value.Contents!.Count);
            IsEditing = new bool[contentState.Value.Contents.Count];
            InvokeAsync(StateHasChanged); // Update the UI
        }
    }

    protected override async void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            //Code to execute once
            await GetAuthenticationState();
        }
        base.OnAfterRender(firstRender);
    }

    public void InitializeContentHolderList()
    {
        for (int i = 0; i < contentState.Value.Contents?.Count; i++)
        {
            contentState.Value.Contents[i].id = i;
        }
    }

    public void timer()
    {
        Timer timer = new Timer(60000); // 60000 milliseconds = 1 minute
        timer.Elapsed += Timer_Elapsed;
        timer.Start();
    }

    private async void Timer_Elapsed(object? sender, ElapsedEventArgs? e)
    {
        @* Updated section *@
        Dictionary<string, string> tempShaDictionary = new Dictionary<string, string>();
        tempShaDictionary = new Dictionary<string, string>(shaDictionary); // Use a copy of the dictionary to prevent reference issues
        await GetAllContentFromGitHubRepo<contentHolder>(true);

        @* Updated code to compare dictionaries *@
        List<string> mismatchedKeys = new List<string>();

        foreach (var entry in tempShaDictionary)
        {
            if (shaDictionary.ContainsKey(entry.Key) && shaDictionary[entry.Key] != entry.Value)
            {
                mismatchedKeys.Add(entry.Key);
            }
        }

        if (mismatchedKeys.Count > 0)
        {
            Console.WriteLine("Found out of date section, updating...");
            if (IsEditing!.All(x => x == false))
            {
                //Add this back
                //Array.Copy(tempContentHolderList, contentState.Value.Contents, contentState.Value.Contents.Count);
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("alert", "Content is out of date with database, refreshing");
                for (int i = 0; i < IsEditing!.Length; i++)
                {
                    if (IsEditing[i] == true)
                    {
                        tempContentSection = contentState.Value.Contents?[i].content;
                        //add this back
                        //Array.Copy(tempContentHolderList, contentState.Value.Contents, contentState.Value.Contents.Count);
                        contentState.Value.Contents[i].content = tempContentSection;
                    }
                }
            }
            InitializeContentHolderList();
        }
    }
    @* Checks current authenticaiton state *@
    private async Task GetAuthenticationState()
    {
        var authenticationState = await AuthenticationStateProvider!.GetAuthenticationStateAsync();
        var user = authenticationState.User;
        //if (user.Identity!.IsAuthenticated)
        //{
        //    var username = user.Identity.Name;
        //}
        //else
        //{
        //    Navigation.NavigateTo($"/authentication/login");
        //}
    }
    
    private void LocationChanged(object sender, LocationChangedEventArgs e)
    {
        ClearIsEditingArray();
    }
    @* Method called in a few places, but should close all open editors, and save any content thats being edited currently *@
    private void ClearIsEditingArray()
    {
        if (IsEditing != null)
        {
            for (int i = 0; i < IsEditing!.Length; i++)
            {
                IsEditing[i] = false;
                StateHasChanged();
            }
            if (!IsEditing!.All(x => x == false))
            {
                Save((0, "Internal save by navigating away", sectionBeingEdited, true));
            }
        }
    }

    private void UpdateContentHolderList(contentHolder[] newContentHolder)
    {
        //add this back
        //contentState.Value.Contents = newContentHolder;
        InitializeContentHolderList();
    }
    @* Detects when text changes in the search component, and triggers search methods *@
    private void SearchTermChanged(string searchPhrase)
    {
        searchTerm = searchPhrase;
        if (searchTerm!.Length > 1)
        {
            @* Not a good solution, I need to add entries to contentState.Value.Contents that can be searched through, but dont get rendered. *@
            if (string.Equals(searchTerm, "CV", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/CV");
            }
            else if (string.Equals(searchTerm, "Dissertation", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/Dissertation");
            }
            else if (string.Equals(searchTerm, "Artifact", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/Artifact");
            }
            else if (string.Equals(searchTerm, "ChatBot", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/chat");
            }
            else if (searchTerm.Contains("Assistant", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/navBot");
            }
            else
            {
                //add this back
                //searchResults = PerformSearch(searchTerm, contentState.Value.Contents);
            }
        }
        if (type != "Search")
        {
            if (searchTerm!.Length > 1)
            {
                Navigation.NavigateTo($"/Search");
            }
        }
        else
        {
            if (String.IsNullOrWhiteSpace(searchTerm))
            {
                Navigation.NavigateTo($"/all");
            }
        }

    }
    @* Build a list of search results including scores *@
    private List<SearchResult> PerformSearch(string searchTerm, contentHolder[] contentList)
    {
        var results = new List<SearchResult>();

        for (int i = 0; i < contentList.Length; i++)
        {
            var content = contentList[i];
            int score = CalculateMatchScore(searchTerm, content);
            if (score > 0)
            {
                results.Add(new SearchResult{ Score = score, Content = content });
            }
        }
        return results.OrderByDescending(r => r.Score).ToList();
    }
    @* Calculate score for each item in contentState.Value.Contents.  Might need to play with the given scores for each match type *@
    public int CalculateMatchScore(string searchTerm, contentHolder content)
    {
        int score = 0;
        // Normalize search term
        searchTerm = Regex.Replace(searchTerm.Trim(), @"\p{P}", "").ToLower();

        // Split the search term into words
        var searchWords = searchTerm.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Strip HTML tags from content and normalize
        var strippedContent = Regex.Replace(content.content, "<.*?>", String.Empty);
        strippedContent = Regex.Replace(strippedContent, @"\p{P}", "").ToLower();

        // Split the content into words
        var contentWords = strippedContent.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Normalize title words
        var title = $"{content.page} {content.section} {content.subSection}";
        title = Regex.Replace(title, "<.*?>", String.Empty);
        title = Regex.Replace(title, @"\p{P}", "").ToLower();

        var titleWords = title.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Check if the entire search term appears in the content or title
        if (strippedContent.Contains(searchTerm) || title.Contains(searchTerm))
        {
            score += 4;
        }

        // Check each word in the content
        foreach (var word in contentWords)
        {
            // Check full word matches
            if (searchWords.Any(searchWord =>
                string.Equals(word, searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 2;
            }// Check partial matches
            else if (searchWords.Any(searchWord =>
                word.Contains(searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 1;
            }
        }

        // Check each word in the title
        foreach (var word in titleWords)
        {
            // Check full word matches
            if (searchWords.Any(searchWord =>
                string.Equals(word, searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 3;
            }// Check partial matches
            else if (searchWords.Any(searchWord =>
                word.Contains(searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 2;
            }
        }

        return score;
    }

    @* Method to clear specific sections content *@
    private void ClearContent((int localSectionNo, int globalSectionNo) parameters)
    {
        int localSectionNo = parameters.localSectionNo;
        int globalSectionNo = parameters.globalSectionNo;
        contentState.Value.Contents![globalSectionNo].content = "";
        IsEditing![localSectionNo] = true;
    }

    @* Set selected sections IsEditing to True, which should render the editor. It tries to check before opening the editor if the content is up to date with DB, if its not, it should update then open. 
        This is way over-complicated at the moment.  Given I have an update event every minuite, I really dont need to check for changes when clicking edit.  It makes the came check every minuite, and when you save...
    *@
    private void Edit((int localSectionNo, int globalSectionNo) parameters)
    {
        int localSectionNo = parameters.localSectionNo;
        int globalSectionNo = parameters.globalSectionNo;

        // When you click edit, save the current state so 'Cancel' button can revert changes
        tempContent = CloneContentHolder(contentState.Value.Contents![globalSectionNo]);

        // Open the editor for the selected section
        IsEditing![localSectionNo] = true;

        StateHasChanged();
    }

    // Creates a deep copy of a content holder
    private contentHolder CloneContentHolder(contentHolder original)
    {
        return JsonConvert.DeserializeObject<contentHolder>(JsonConvert.SerializeObject(original));
    }

    @* Old method, not in use *@
    private void inlineEdit((string username, int globalSectionNo) parameters)
    {
        string username = parameters.username;
        int globalSectionNo = parameters.globalSectionNo;
        initialContent![globalSectionNo] = JsonConvert.DeserializeObject<contentHolder>(JsonConvert.SerializeObject(contentState.Value.Contents![globalSectionNo]));
    }

    @* 
        as I am moving to fluxor and simplifying things, I also need to dramatically simplify this before translating it.  I have decided I think to not worry about sha matching at the moment, and just always update, since its just me using this app...
    *@
    private async void Save((int sectionNo, string username, int globalSectionNo, bool newSec) parameters)
    {
        int sectionNo = parameters.sectionNo;
        string username = parameters.username;
        int globalSectionNo = parameters.globalSectionNo;
        bool newSec = parameters.newSec;

        string? localSection;
        string oldSHA;
        int? oldUpdateCount = updateCount;
        if (newSec == true)
        {
            localSection = contentState.Value.Contents.Last().page + contentState.Value.Contents.Last().section;
            oldSHA = shaDictionary[localSection]!;
            updateCount++;
        }
        else
        {
            localSection = initialContent[globalSectionNo].page + initialContent[globalSectionNo].section;
            oldSHA = shaDictionary[localSection]!;
            await GetContentFromGitHubRepo<contentHolder>(true, localSection);
        }
        if (updateCount == oldUpdateCount + 1)
        {
            //Console.WriteLine("oldSHA: " + oldSHA + " newHSA: " + shaDictionary[localSection]);
            if (shaDictionary[localSection] == oldSHA || newSec == true)
            {
                if (newSec == true)
                {
                    Console.WriteLine("saving new section");
                    IsEditing![sectionNo] = false;
                    commitText = "Content change made by: " + username + "";
                    @* Update the array for navigation *@
                    myStateContainer.SetValue();
                    myStateContainer.OnStateChange += RefreshMe;
                    @* Serialize current object array to a JSON String *@
                    contentHolder[] localContentHolderList = contentState.Value.Contents!.Where(holder => holder.page == contentState.Value.Contents.Last().page && holder.section == contentState.Value.Contents.Last().section).ToArray();
                    var jsonString = JsonConvert.SerializeObject(localContentHolderList);
                    await UpdateJSONOnGitHub(jsonString, commitText!, localSection!);
                }
                else
                {
                    string? types = contentState.Value.Contents[globalSectionNo].page;
                    string? oldTypes = initialContent[globalSectionNo].page;
                    string? sections = contentState.Value.Contents[globalSectionNo].section;
                    string? oldSections = initialContent[globalSectionNo].section;
                    Console.WriteLine("Current: " + contentState.Value.Contents![globalSectionNo] + "Old: " + initialContent![globalSectionNo]);
                    if (contentState.Value.Contents![globalSectionNo].section != initialContent![globalSectionNo].section ||
                        contentState.Value.Contents![globalSectionNo].subSection != initialContent![globalSectionNo].subSection ||
                        contentState.Value.Contents![globalSectionNo].content != initialContent![globalSectionNo].content)
                    {
                        Console.WriteLine("saving");
                        IsEditing![sectionNo] = false;
                        commitText = "Content change made by: " + username + "";
                        @* Update the array for navigation *@
                        myStateContainer.SetValue();
                        myStateContainer.OnStateChange += RefreshMe;

                        @* Check if Type or Section names have changes, then Serialize current object array to a JSON String *@
                        if (types != oldTypes || sections != oldSections)
                        {
                            contentHolder[] oldLocalContentHolderList = contentState.Value.Contents.Where(holder => holder.page == oldTypes && holder.section == oldSections).ToArray();
                            var oldJsonString = JsonConvert.SerializeObject(oldLocalContentHolderList);
                            if (oldJsonString == "[]")
                            {
                                commitText = "Section removed by: " + username + "";
                                Console.WriteLine("Section Empty, Should remove JSON from db");
                                await DeleteFile(commitText, localSection!);
                            }
                            else
                            {
                                await UpdateJSONOnGitHub(oldJsonString, commitText!, localSection!);
                            }
                        }

                        contentHolder[] localContentHolderList = contentState.Value.Contents.Where(holder => holder.page == types && holder.section == sections).ToArray();
                        var jsonString = JsonConvert.SerializeObject(localContentHolderList);
                        var oldLocalSection = localSection;
                        localSection = contentState.Value.Contents[globalSectionNo].page + contentState.Value.Contents[globalSectionNo].section;
                        await UpdateJSONOnGitHub(jsonString, commitText!, localSection!);
                    }
                    else
                    {
                        IsEditing![sectionNo] = false;
                        Console.WriteLine("No changes detected");
                        Console.WriteLine(contentState.Value.Contents![globalSectionNo].content!);
                    }
                }
            }
            else
            {
                Console.WriteLine("Triggering the extra save logic");
                await JSRuntime.InvokeVoidAsync("alert", "Content is out of date with database, please press save again to force changes or cancel to update to database version");
                for (int i = 0; i < IsEditing!.Length; i++)
                {
                    if (IsEditing[i] == true)
                    {
                        tempContentSection = contentState.Value.Contents[i].content;
                        //add this back
                        //Array.Copy(tempContentHolderList, contentState.Value.Contents, contentState.Value.Contents.Count);
                        contentState.Value.Contents[i].content = tempContentSection;
                        break;
                    }
                }
            }
        }
        else
        {
            Console.WriteLine("Still Loading");
        }
        InitializeContentHolderList();
        StateHasChanged();
    }

    private void RefreshMe()
    {
        StateHasChanged();
    }

    @* Set sections IsEditing to false, and set the content to the stored previous state *@
    private async void Cancel((int localSectionNo, int globalSectionNo) parameters)
    {
        int localSectionNo = parameters.localSectionNo;
        int globalSectionNo = parameters.globalSectionNo;
        @* If statement needed here so canceling on a newly added section will remove it *@
        if (initialContent![globalSectionNo] != null)
        {
            contentState.Value.Contents![globalSectionNo].content = initialContent[globalSectionNo].content!;
        }
        else
        {
            await RemoveSection((contentState.Value.Contents!.Count - 1, "... (New Section)"));
        }
        IsEditing![localSectionNo] = false;
        InitializeContentHolderList();
    }
    private void CancelNew(int localSectionNo)
    {
        IsEditing![localSectionNo] = false;
    }

    @* Add a new object to my array from user input *@
    private async Task AddNewSection(string username)
    {
        @* Using data binding to tie user selection to these vars *@
        string? subName = subSectionName;
        string? newType = newTypeDropdown;
        string? newName = newSectionName;
        string finalType;
        string finalName;
        if (typeDropdown == "Add")
        {
            finalType = newTypeDropdown!;
        }
        else
        {
            finalType = typeDropdown!;
        }
        if (sectionName == "Add")
        {
            finalName = newSectionName!;
        }
        else
        {
            finalName = sectionName!;
        }
        if (!String.IsNullOrWhiteSpace(finalType) && !String.IsNullOrWhiteSpace(finalName) && !String.IsNullOrWhiteSpace(subName))
        {
            if (!contentState.Value.Contents.Any(item => item.subSection.Contains(subName)))
            {
                @* Best way to add to an array is to resize then initialize the new index *@
                //add this back
                //Array.Resize(ref contentState.Value.Contents, contentState.Value.Contents!.Count + 1);
                Array.Resize(ref tempContentHolderList, contentState.Value.Contents!.Count);
                Array.Resize(ref IsEditing, IsEditing!.Length + 1);
                contentState.Value.Contents[contentState.Value.Contents.Count - 1] = new contentHolder
                    {
                        page = finalType,
                        section = finalName,
                        subSection = subName,
                        content = "<p>Enter some details about " + subName + " here.</p>"
                    }; 
                ReInitialize();
                @* Initialize new index on control variables *@
                IsEditing[0] = true;
                sectionBeingEdited = contentState.Value.Contents.Count;
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("alert", "subName must be unique. Currently includes partial matches, so any existing subSection name containing " + subName + " will trigger a match");
                searchTerm = subName;
                SearchTermChanged(searchTerm);
            }
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("alert", "Each box must have an entry");
        }
    }

    @* Method to remove selected section *@
    private async Task RemoveSection((int sectionNo, string username) parameters)
    {
        int sectionNo = parameters.sectionNo;
        string username = parameters.username;
        bool responce = await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete the subSection: " + contentState.Value.Contents[sectionNo].subSection);
        if (responce == true)
        {
            if (contentState.Value.Contents!.Count > 1)
            {
                string? localSection = contentState.Value.Contents[sectionNo].page + contentState.Value.Contents[sectionNo].section;
                string? types = contentState.Value.Contents[sectionNo].page;
                string? sections = contentState.Value.Contents[sectionNo].section;
                @* Easiest way to remove an element from middle of array is to build a new array from the old, skipping the line to remove, then setting it back to main array *@
                contentHolder[] newArray = new contentHolder[contentState.Value.Contents.Count - 1];
                int newArrayIndex = 0;
                for (int i = 0; i < contentState.Value.Contents.Count; i++)
                {
                    if (i != sectionNo)
                    {
                        newArray[newArrayIndex++] = contentState.Value.Contents[i];
                    }
                }
                //add this back
                //contentState.Value.Contents = newArray;
                ReInitialize();
                myStateContainer.SetValue();
                myStateContainer.OnStateChange += RefreshMe;
                @* Serialize and upload to GitHub *@

                contentHolder[] localContentHolderList = contentState.Value.Contents.Where(holder => holder.page == types && holder.section == sections).ToArray();
                var jsonString = JsonConvert.SerializeObject(localContentHolderList);
                if (jsonString == "[]")
                {
                    commitText = "Section removed by: " + username + "";
                    Console.WriteLine("Section Empty, Should remove JSON from db");
                    await DeleteFile(commitText, localSection!);
                }
                else
                {
                    commitText = "subSection removed by : " + username + "";
                    await UpdateJSONOnGitHub(jsonString, commitText!, localSection!);
                }
            }
        }
        InitializeContentHolderList();
    }
    @* This method should reset lengths of different variables and re-load the page.  Called after a number of state changes *@
    private void ReInitialize()
    {
        //Add this back
        //Array.Resize(ref initialContent, contentState.Value.Contents!.Count);
        IsEditing = new bool[contentState.Value.Contents.Count];
        InitializeContentHolderList();
        StateHasChanged();
    }
    @* Method for uploading content to GitHub API via PUT *@
    private async Task UpdateJSONOnGitHub(string jsonString, string commitMessage, string section)
    {
        try
        {
            using (var client = new HttpClient())
            {
                var sha = shaDictionary[section];

                Console.WriteLine("Saving2");
                Console.WriteLine("sha before: " + sha);
                // Define the request body, encoding the content string as base64
                Console.WriteLine(jsonString);
                var body = new
                {
                    message = commitMessage,
                    content = Convert.ToBase64String(Encoding.UTF8.GetBytes(jsonString)),
                    sha = sha
                };

                // Serialize the body object and encode
                var json = JsonConvert.SerializeObject(body);
                var contentAndMessage = new StringContent(json, Encoding.UTF8, "application/json");

                // Send the PUT request to the PHP proxy
                var response = await client.PutAsync($"https://samdenton.tech/GithubPut-proxy.php?section={section}", contentAndMessage);
                var responseBytes = await response.Content.ReadAsByteArrayAsync();

                // Detect and remove potential Byte Order Mark (BOM)
                var bom = Encoding.UTF8.GetPreamble();
                if (responseBytes.Take(bom.Length).SequenceEqual(bom))
                {
                    responseBytes = responseBytes.Skip(bom.Length).ToArray();
                }

                // Convert bytes to string
                var responceHeaders = Encoding.UTF8.GetString(responseBytes);
                @* Get new sha value from PUT response headers *@
                Console.WriteLine("response before parsing too root: " + responceHeaders);
                var gitContent = JsonConvert.DeserializeObject<PUTContentParser>(responceHeaders);
                Console.WriteLine("response before parsing to content: " + gitContent);
                shaDictionary[section] = gitContent.content.sha;
                Console.WriteLine("sha after: " + shaDictionary[section]);
                @* Ensure the request was successful *@
                response.EnsureSuccessStatusCode();
                if (!response.IsSuccessStatusCode)
                {
                    throw new Exception("Error updating content: " + response.ReasonPhrase);
                }

            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
            loadingMSG += "Error Loading Content: " + ex.Message;
            StateHasChanged();
        }
    }
    @* Retrieve content from GitHub as a JSON string *@
    @* I should look to split this into a number of functions for each section *@
    @* need to think about weather I want 2 functions, 1 for all sections and one of indevidual, or if I can work out both in 1 *@
    @* Think im limted to 1000 files per request, but that might be 1000 files total for the dir to be acessable *@
    @* I'm hoping to get the whole directory in a single API call to initialise and build menu etc, but might have to get each file with sepotate calls, which till be slow... *@
    public async Task GetContentFromGitHubRepo<T>(bool checking, string section)
    {
        using (var client = new HttpClient())
        {
            // Send the GET request to the PHP proxy
            var response = await client.GetAsync($"https://samdenton.tech/GithubGet-proxy.php?section={section}");

            @* Read the response content, parse the content and convert it from base64, then de-serialize the content with my custom class *@
            try
            {
                var content = await response.Content.ReadAsStringAsync();
                // Remove potential Byte Order Mark (BOM)
                var bom = Encoding.UTF8.GetString(Encoding.UTF8.GetPreamble());
                if (content.StartsWith(bom))
                {
                    content = content.Remove(0, bom.Length);
                }
                var gitContent = JsonConvert.DeserializeObject<ContentParser>(content);
                var contentBytes = Convert.FromBase64String(gitContent!.content!);
                var jsonContent = Encoding.UTF8.GetString(contentBytes);
                var array = JsonConvert.DeserializeObject<contentHolder[]>(jsonContent);
                @* Get the sha of the retrieved file *@
                shaDictionary[section] = gitContent.sha!;

                if (checking != true)
                {
                    foreach (contentHolder updateItem in array)
                    {
                        foreach (contentHolder mainContentItem in contentState.Value.Contents)
                        {
                            Console.WriteLine("updating contentState.Value.Contents");
                            if (mainContentItem.page == updateItem.page &&
                                mainContentItem.section == updateItem.section &&
                                mainContentItem.subSection == updateItem.subSection)
                            {
                                mainContentItem.content = updateItem.content;
                            }
                        }
                    }
                }
                else
                {
                    //add this back
                    //Array.Copy(contentState.Value.Contents, tempContentHolderList, contentState.Value.Contents.Count);
                    Console.WriteLine("adding: " + array);
                    foreach (contentHolder updateItem in array)
                    {
                        Console.WriteLine("updating tempContentHolderList");
                        foreach (contentHolder mainContentItem in tempContentHolderList)
                        {
                            if (mainContentItem.page == updateItem.page &&
                                mainContentItem.section == updateItem.section &&
                                mainContentItem.subSection == updateItem.subSection)
                            {
                                Console.WriteLine("This should be copying data from the database to a temp array then chossing whether to overwrite main array");
                                //This is currently causing content on the main array to not update with user changes
                                //mainContentItem.content = updateItem.content;
                            }
                        }
                    }
                }


                isContentLoaded = true;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error: " + ex.Message);
                loadingMSG += "Error Loading single section Content: " + ex.Message + "Check size of DB";
                StateHasChanged();
            }
            InitializeContentHolderList();
            StateHasChanged();
            updateCount++;
        }
    }

    public async Task GetAllContentFromGitHubRepo<T>(bool checking)
    {
        using (var client = new HttpClient())
        {
            // Send the GET request to the PHP proxy
            var response = await client.GetAsync("https://samdenton.tech/GithubGetAll-proxy.php");

            try
            {
                var content = await response.Content.ReadAsStringAsync();
                // Remove potential Byte Order Mark (BOM)
                var bom = Encoding.UTF8.GetString(Encoding.UTF8.GetPreamble());
                if (content.StartsWith(bom))
                {
                    content = content.Remove(0, bom.Length);
                }
                var gitContents = JsonConvert.DeserializeObject<List<ContentParser>>(content);
                List<contentHolder> localContentHolderList = new List<contentHolder>();

                if (initiating)
                {
                    foreach (var gitContent in gitContents)
                    {
                        if (gitContent.type == "file")
                        {
                            // Send the GET request to the GitHub API to get the content of the individual file
                            var fileResponse = await client.GetAsync($"https://samdenton.tech/GithubGetFile-proxy.php?url={WebUtility.UrlEncode(gitContent.url)}");
                            var fileContent = await fileResponse.Content.ReadAsStringAsync();
                            // Remove potential Byte Order Mark (BOM)
                            if (fileContent.StartsWith(bom))
                            {
                                fileContent = fileContent.Remove(0, bom.Length);
                            }
                            var fileGitContent = JsonConvert.DeserializeObject<ContentParser>(fileContent);

                            var contentBytes = Convert.FromBase64String(fileGitContent.content);
                            var jsonContent = Encoding.UTF8.GetString(contentBytes);
                            var array = JsonConvert.DeserializeObject<List<contentHolder>>(jsonContent);

                            localContentHolderList.AddRange(array);
                            // Add the filename (without '_data.json') and the SHA value to the dictionary
                            string fileNameWithoutSuffix = gitContent.name.Replace("_data.json", "");
                            shaDictionary[fileNameWithoutSuffix] = fileGitContent.sha;
                        }
                    }
                    initiating = false;
                    //add this back
                    //contentState.Value.Contents = localContentHolderList.ToArray();
                }
                else
                {
                    foreach (var gitContent in gitContents)
                    {
                        string fileNameWithoutSuffix = gitContent.name.Replace("_data.json", "");
                        if (gitContent.type == "file" && gitContent.sha != shaDictionary[fileNameWithoutSuffix])
                        {
                            // Send the GET request to the GitHub API to get the content of the individual file
                            var fileResponse = await client.GetAsync($"https://samdenton.tech/GithubGetFile-proxy.php?url={WebUtility.UrlEncode(gitContent.url)}");
                            var fileContent = await fileResponse.Content.ReadAsStringAsync();
                            // Remove potential Byte Order Mark (BOM)
                            if (fileContent.StartsWith(bom))
                            {
                                fileContent = fileContent.Remove(0, bom.Length);
                            }
                            var fileGitContent = JsonConvert.DeserializeObject<ContentParser>(fileContent);

                            var contentBytes = Convert.FromBase64String(fileGitContent.content);
                            var jsonContent = Encoding.UTF8.GetString(contentBytes);
                            var array = JsonConvert.DeserializeObject<List<contentHolder>>(jsonContent);

                            localContentHolderList.AddRange(array);
                            // Add the filename (without '_data.json') and the SHA value to the dictionary

                            shaDictionary[fileNameWithoutSuffix] = fileGitContent.sha;
                        }
                    }
                }

                if (checking != true)
                {
                    foreach (contentHolder updateItem in localContentHolderList)
                    {
                        foreach (contentHolder mainContentItem in contentState.Value.Contents)
                        {
                            Console.WriteLine("updating contentState.Value.Contents");
                            if (mainContentItem.page == updateItem.page &&
                                mainContentItem.section == updateItem.section &&
                                mainContentItem.subSection == updateItem.subSection)
                            {
                                mainContentItem.content = updateItem.content;
                            }
                        }
                    }
                }
                else
                {
                    //add this back
                    //Array.Copy(contentState.Value.Contents, tempContentHolderList, contentState.Value.Contents.Count);
                    foreach (contentHolder updateItem in localContentHolderList)
                    {
                        Console.WriteLine("updating tempContentHolderList");
                        foreach (contentHolder mainContentItem in tempContentHolderList)
                        {
                            if (mainContentItem.page == updateItem.page &&
                                mainContentItem.section == updateItem.section &&
                                mainContentItem.subSection == updateItem.subSection)
                            {
                                mainContentItem.content = updateItem.content;
                            }
                        }
                    }
                }


                isContentLoaded = true;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error: " + ex.Message);
                loadingMSG += "Error Loading All Content: " + ex.Message + "Check size of DB";
                StateHasChanged();
            }
            InitializeContentHolderList();
            StateHasChanged();
            updateCount++;
        }
    }

    private async Task DeleteFile(string commitMessage, string section)
    {
        var sha = shaDictionary[section];
        var client = new HttpClient();

        var content = new StringContent(JsonConvert.SerializeObject(new
        {
            message = commitMessage,
            sha = sha
        }), Encoding.UTF8, "application/json");

        var response = await client.DeleteAsync($"https://samdenton.tech/GithubDelete-proxy.php?section={section}&sha={sha}");

        if (!response.IsSuccessStatusCode)
        {
            throw new Exception("Error deleting file: " + response.ReasonPhrase);
        }
    }

    public void Dispose()
    {
        contentState.StateChanged -= ContentStateChanged; // Clean up to avoid memory leaks
    }

    @* Class for creating custom objects from JSON string *@
@*    public class contentHolder
    {
        public string? page { get; set; }

        public string? section { get; set; }

        public string? subSection { get; set; }

        public string? content { get; set; }

        public int id { get; set; }
    }*@

    @* Class for tying search results to their score *@
    public class SearchResult
    {
        public contentHolder Content { get; set; }
        public int Score { get; set; }
    }

    @* Class for creating an object from GET response. content here will still be JSON string, so needs de-serializing further using previous class *@
    public class ContentParser
    {
        public string? content { get; set; }
        public string? encoding { get; set; }
        public int? size { get; set; }
        public string? sha { get; set; }
        public string? type { get; set; }
        public string? name { get; set; }
        public string? url { get; set; }
    }
    @* Class structure to get sha from PUT response headers *@
    public class PUTContentParser
    {
        public Content content { get; set; }
        public Commit commit { get; set; }
    }

    public class Content
    {
        public string sha { get; set; }
    }

    public class Commit
    {
        public string sha { get; set; }
    }
}
